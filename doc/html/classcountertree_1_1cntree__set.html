<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Countertree: countertree::cntree_set&lt; value_t, cnc, comp_key_t, alloc_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Countertree
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">concurrent set , multiset map and multimap with random access iterators</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcountertree_1_1cntree__set.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classcountertree_1_1cntree__set-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">countertree::cntree_set&lt; value_t, cnc, comp_key_t, alloc_t &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class have the same interface than the STL set, plus access by position with the function at, and random access iterators.  
 <a href="classcountertree_1_1cntree__set.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a196f6e183c5dd70c835a48efe785b62b"><td class="memItemLeft" align="right" valign="top">typedef value_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a196f6e183c5dd70c835a48efe785b62b">key_t</a></td></tr>
<tr class="separator:a196f6e183c5dd70c835a48efe785b62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb587276553b09c1e3f2b5ff51dd4d4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structcountertree_1_1filter__set.html">filter_set</a>&lt; <a class="el" href="classcountertree_1_1cntree__set.html#a196f6e183c5dd70c835a48efe785b62b">key_t</a>, <br class="typebreak"/>
value_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#abdb587276553b09c1e3f2b5ff51dd4d4">filter_t</a></td></tr>
<tr class="separator:abdb587276553b09c1e3f2b5ff51dd4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b123109035b474c184d82de04330d4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">c_forest::sorted_tree</a><br class="typebreak"/>
&lt; value_t, <a class="el" href="classcountertree_1_1cntree__set.html#a196f6e183c5dd70c835a48efe785b62b">key_t</a>, <a class="el" href="classcountertree_1_1cntree__set.html#abdb587276553b09c1e3f2b5ff51dd4d4">filter_t</a>, <br class="typebreak"/>
comp_key_t, alloc_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#ab8b123109035b474c184d82de04330d4">srt_tree_t</a></td></tr>
<tr class="separator:ab8b123109035b474c184d82de04330d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa094be346ef7863afae8833a149718"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structcountertree_1_1config__barrier.html">config_barrier</a>&lt; cnc &gt;<br class="typebreak"/>
::<a class="el" href="classcountertree_1_1cntree__set.html#a5aa094be346ef7863afae8833a149718">barrier_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a5aa094be346ef7863afae8833a149718">barrier_data</a></td></tr>
<tr class="separator:a5aa094be346ef7863afae8833a149718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e200626bbc80510cff0f1e9eca8407"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structcountertree_1_1config__barrier.html">config_barrier</a>&lt; cnc &gt;<br class="typebreak"/>
::<a class="el" href="classcountertree_1_1cntree__set.html#a98e200626bbc80510cff0f1e9eca8407">barrier_read</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a98e200626bbc80510cff0f1e9eca8407">barrier_read</a></td></tr>
<tr class="separator:a98e200626bbc80510cff0f1e9eca8407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aca29e3930a2005f7ae6095bab46d5f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structcountertree_1_1config__barrier.html">config_barrier</a>&lt; cnc &gt;<br class="typebreak"/>
::<a class="el" href="classcountertree_1_1cntree__set.html#a4aca29e3930a2005f7ae6095bab46d5f">barrier_modify</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a4aca29e3930a2005f7ae6095bab46d5f">barrier_modify</a></td></tr>
<tr class="separator:a4aca29e3930a2005f7ae6095bab46d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142d158c5cd5097d80e3ca5f82486395"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1cntree__set.html#a196f6e183c5dd70c835a48efe785b62b">key_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a142d158c5cd5097d80e3ca5f82486395">key_type</a></td></tr>
<tr class="separator:a142d158c5cd5097d80e3ca5f82486395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c320efb21a90299334c684f1c9aa32"><td class="memItemLeft" align="right" valign="top">typedef value_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a></td></tr>
<tr class="separator:a49c320efb21a90299334c684f1c9aa32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59583855f02b16841854fe7421beed38"><td class="memItemLeft" align="right" valign="top">typedef value_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a59583855f02b16841854fe7421beed38">pointer</a></td></tr>
<tr class="separator:a59583855f02b16841854fe7421beed38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2eef2d4200f796f567ebb76a786b184"><td class="memItemLeft" align="right" valign="top">typedef const value_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#af2eef2d4200f796f567ebb76a786b184">const_pointer</a></td></tr>
<tr class="separator:af2eef2d4200f796f567ebb76a786b184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e11332f4c9943fb16a70aeacc22fcf"><td class="memItemLeft" align="right" valign="top">typedef value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#ae4e11332f4c9943fb16a70aeacc22fcf">reference</a></td></tr>
<tr class="separator:ae4e11332f4c9943fb16a70aeacc22fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef9228b8ac85d5c3c626a21b1621a40"><td class="memItemLeft" align="right" valign="top">typedef const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a8ef9228b8ac85d5c3c626a21b1621a40">const_reference</a></td></tr>
<tr class="separator:a8ef9228b8ac85d5c3c626a21b1621a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b2cff2f68d23095cf1e5b4acfc20f3"><td class="memItemLeft" align="right" valign="top">typedef comp_key_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a16b2cff2f68d23095cf1e5b4acfc20f3">key_compare</a></td></tr>
<tr class="separator:a16b2cff2f68d23095cf1e5b4acfc20f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f5e2422ec58470b19259f956763d07"><td class="memItemLeft" align="right" valign="top">typedef comp_key_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a82f5e2422ec58470b19259f956763d07">value_compare</a></td></tr>
<tr class="separator:a82f5e2422ec58470b19259f956763d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ee54c2f9b8a3282ce2af5b54f2c39f"><td class="memItemLeft" align="right" valign="top">typedef alloc_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a54ee54c2f9b8a3282ce2af5b54f2c39f">allocator_type</a></td></tr>
<tr class="separator:a54ee54c2f9b8a3282ce2af5b54f2c39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b3b59c6fcdc46d8d9cd14b5ebeef32"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a435616fae6b22fcb60996905ea17aef1">srt_tree_t::tree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a99b3b59c6fcdc46d8d9cd14b5ebeef32">tree</a></td></tr>
<tr class="separator:a99b3b59c6fcdc46d8d9cd14b5ebeef32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3745b0a456cf2bd200d743eb028f8e2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">srt_tree_t::node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#ad3745b0a456cf2bd200d743eb028f8e2">node_t</a></td></tr>
<tr class="separator:ad3745b0a456cf2bd200d743eb028f8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af919b766e7e832128bcefe7aecb41b7e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a2a86f27200857c04dd1f46e11973e2a1">srt_tree_t::node_alloc_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#af919b766e7e832128bcefe7aecb41b7e">node_alloc_t</a></td></tr>
<tr class="separator:af919b766e7e832128bcefe7aecb41b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd74276cf1bfb742233ab324a13866f3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">srt_tree_t::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#afd74276cf1bfb742233ab324a13866f3">iterator</a></td></tr>
<tr class="separator:afd74276cf1bfb742233ab324a13866f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef86483cd89fac74df4600332d14376f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">srt_tree_t::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a></td></tr>
<tr class="separator:aef86483cd89fac74df4600332d14376f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136e00e6b17bb9b30223c2a9257ff96a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacecountertree_1_1common.html#aacea70d0e38fcfefebf3b6ad0a88ae6f">c_common::signed_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a136e00e6b17bb9b30223c2a9257ff96a">size_type</a></td></tr>
<tr class="separator:a136e00e6b17bb9b30223c2a9257ff96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e448bff7ba8b0337930749a89c99a7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacecountertree_1_1common.html#aacea70d0e38fcfefebf3b6ad0a88ae6f">c_common::signed_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#af5e448bff7ba8b0337930749a89c99a7">difference_type</a></td></tr>
<tr class="separator:af5e448bff7ba8b0337930749a89c99a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117dd410af94c84f30928f35cef904c9"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">srt_tree_t::const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a117dd410af94c84f30928f35cef904c9">reverse_iterator</a></td></tr>
<tr class="separator:a117dd410af94c84f30928f35cef904c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ec4cfe18a49437b9b736830843d6bd"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">srt_tree_t::const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a30ec4cfe18a49437b9b736830843d6bd">const_reverse_iterator</a></td></tr>
<tr class="separator:a30ec4cfe18a49437b9b736830843d6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb366f2902148e5fc9841e311e664f01"><td class="memItemLeft" align="right" valign="top">typedef std::pair<br class="typebreak"/>
&lt; <a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#aeb366f2902148e5fc9841e311e664f01">mypair</a></td></tr>
<tr class="separator:aeb366f2902148e5fc9841e311e664f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03510aa8ff80ed2b0505f5310a30d8f5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structcountertree_1_1forest_1_1connector.html">c_forest::connector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a03510aa8ff80ed2b0505f5310a30d8f5">connector</a></td></tr>
<tr class="separator:a03510aa8ff80ed2b0505f5310a30d8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2054d35d0d6a9a520b9063690fae634b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a2054d35d0d6a9a520b9063690fae634b">cntree_set</a> (const <a class="el" href="classcountertree_1_1cntree__set.html#a16b2cff2f68d23095cf1e5b4acfc20f3">key_compare</a> &amp;C1=<a class="el" href="classcountertree_1_1cntree__set.html#a16b2cff2f68d23095cf1e5b4acfc20f3">key_compare</a>(), const alloc_t &amp;A1=alloc_t())</td></tr>
<tr class="memdesc:a2054d35d0d6a9a520b9063690fae634b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from an object Comparer and an object Allocator.  <a href="#a2054d35d0d6a9a520b9063690fae634b">More...</a><br/></td></tr>
<tr class="separator:a2054d35d0d6a9a520b9063690fae634b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62513c8d07075b61953d9486be428fa4"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a62513c8d07075b61953d9486be428fa4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a62513c8d07075b61953d9486be428fa4">cntree_set</a> (InputIterator first, InputIterator last, const <a class="el" href="classcountertree_1_1cntree__set.html#a16b2cff2f68d23095cf1e5b4acfc20f3">key_compare</a> &amp;C1=<a class="el" href="classcountertree_1_1cntree__set.html#a16b2cff2f68d23095cf1e5b4acfc20f3">key_compare</a>(), const alloc_t &amp;A1=alloc_t())</td></tr>
<tr class="memdesc:a62513c8d07075b61953d9486be428fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from a pair of iterators and an object Comparer and an object Allocator.  <a href="#a62513c8d07075b61953d9486be428fa4">More...</a><br/></td></tr>
<tr class="separator:a62513c8d07075b61953d9486be428fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b879b9031b8e9b7de40c85f15e9966"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a29b879b9031b8e9b7de40c85f15e9966">cntree_set</a> (const <a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a> &amp;x)</td></tr>
<tr class="memdesc:a29b879b9031b8e9b7de40c85f15e9966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a29b879b9031b8e9b7de40c85f15e9966">More...</a><br/></td></tr>
<tr class="separator:a29b879b9031b8e9b7de40c85f15e9966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414cd143222f7c45b0d4cf8d7d5d6763"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a414cd143222f7c45b0d4cf8d7d5d6763">cntree_set</a> (<a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a> &amp;&amp;x)</td></tr>
<tr class="memdesc:a414cd143222f7c45b0d4cf8d7d5d6763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a414cd143222f7c45b0d4cf8d7d5d6763">More...</a><br/></td></tr>
<tr class="separator:a414cd143222f7c45b0d4cf8d7d5d6763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2702c78eb385e1c91a90d4c5a1e8d66"><td class="memTemplParams" colspan="2">template&lt;bool cnc2&gt; </td></tr>
<tr class="memitem:ac2702c78eb385e1c91a90d4c5a1e8d66"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#ac2702c78eb385e1c91a90d4c5a1e8d66">cntree_set</a> (<a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a>&lt; value_t, cnc2, comp_key_t, alloc_t &gt; &amp;&amp;x)</td></tr>
<tr class="memdesc:ac2702c78eb385e1c91a90d4c5a1e8d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#ac2702c78eb385e1c91a90d4c5a1e8d66">More...</a><br/></td></tr>
<tr class="separator:ac2702c78eb385e1c91a90d4c5a1e8d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f79d365f3c4894bd8996a92a0f9405"><td class="memTemplParams" colspan="2">template&lt;typename alloc_t2 , bool cnc2&gt; </td></tr>
<tr class="memitem:a48f79d365f3c4894bd8996a92a0f9405"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a48f79d365f3c4894bd8996a92a0f9405">cntree_set</a> (const <a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a>&lt; value_t, cnc2, comp_key_t, alloc_t2 &gt; &amp;x)</td></tr>
<tr class="memdesc:a48f79d365f3c4894bd8996a92a0f9405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a48f79d365f3c4894bd8996a92a0f9405">More...</a><br/></td></tr>
<tr class="separator:a48f79d365f3c4894bd8996a92a0f9405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe82423acbb3403e5d1426f890484336"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#abe82423acbb3403e5d1426f890484336">~cntree_set</a> (void)</td></tr>
<tr class="memdesc:abe82423acbb3403e5d1426f890484336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#abe82423acbb3403e5d1426f890484336">More...</a><br/></td></tr>
<tr class="separator:abe82423acbb3403e5d1426f890484336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5563263ac7c294f3ac51466eaec589"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#abe5563263ac7c294f3ac51466eaec589">operator=</a> (const <a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a> &amp;S)</td></tr>
<tr class="memdesc:abe5563263ac7c294f3ac51466eaec589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asignation operator.  <a href="#abe5563263ac7c294f3ac51466eaec589">More...</a><br/></td></tr>
<tr class="separator:abe5563263ac7c294f3ac51466eaec589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9005467f1d05e7d5395efbda0b1774a6"><td class="memTemplParams" colspan="2">template&lt;typename alloc_t2 , bool cnc2&gt; </td></tr>
<tr class="memitem:a9005467f1d05e7d5395efbda0b1774a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a9005467f1d05e7d5395efbda0b1774a6">operator=</a> (const <a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a>&lt; value_t, cnc2, comp_key_t, alloc_t2 &gt; &amp;S)</td></tr>
<tr class="memdesc:a9005467f1d05e7d5395efbda0b1774a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asignation operator.  <a href="#a9005467f1d05e7d5395efbda0b1774a6">More...</a><br/></td></tr>
<tr class="separator:a9005467f1d05e7d5395efbda0b1774a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af8567dcc86d1548fc8e46ff01887b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a6af8567dcc86d1548fc8e46ff01887b5">operator=</a> (<a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a> &amp;&amp;S)</td></tr>
<tr class="memdesc:a6af8567dcc86d1548fc8e46ff01887b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asignation operator.  <a href="#a6af8567dcc86d1548fc8e46ff01887b5">More...</a><br/></td></tr>
<tr class="separator:a6af8567dcc86d1548fc8e46ff01887b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f1268a7981798327cbcb735301f1fb"><td class="memTemplParams" colspan="2">template&lt;bool cnc2&gt; </td></tr>
<tr class="memitem:ac0f1268a7981798327cbcb735301f1fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#ac0f1268a7981798327cbcb735301f1fb">operator=</a> (<a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a>&lt; value_t, cnc2, comp_key_t, alloc_t &gt; &amp;&amp;x)</td></tr>
<tr class="memdesc:ac0f1268a7981798327cbcb735301f1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#ac0f1268a7981798327cbcb735301f1fb">More...</a><br/></td></tr>
<tr class="separator:ac0f1268a7981798327cbcb735301f1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abddf88e99f2b7f249ae7c35775eba942"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#abddf88e99f2b7f249ae7c35775eba942">clear</a> (void)</td></tr>
<tr class="memdesc:abddf88e99f2b7f249ae7c35775eba942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all the elements of the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a>.  <a href="#abddf88e99f2b7f249ae7c35775eba942">More...</a><br/></td></tr>
<tr class="separator:abddf88e99f2b7f249ae7c35775eba942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e3660ea7ef2a49f36924ec7e1ee12a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a44e3660ea7ef2a49f36924ec7e1ee12a">swap</a> (<a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a> &amp;s1)</td></tr>
<tr class="memdesc:a44e3660ea7ef2a49f36924ec7e1ee12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap the data of the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> st with the actual <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a>  <a href="#a44e3660ea7ef2a49f36924ec7e1ee12a">More...</a><br/></td></tr>
<tr class="separator:a44e3660ea7ef2a49f36924ec7e1ee12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c924d018918848d91bfad273844353d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a1c924d018918848d91bfad273844353d">empty</a> (void) const </td></tr>
<tr class="memdesc:a1c924d018918848d91bfad273844353d"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicate if the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> is empty  <a href="#a1c924d018918848d91bfad273844353d">More...</a><br/></td></tr>
<tr class="separator:a1c924d018918848d91bfad273844353d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d07d61883fc23f0898c6307e7102007"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a2d07d61883fc23f0898c6307e7102007">size</a> (void) const </td></tr>
<tr class="memdesc:a2d07d61883fc23f0898c6307e7102007"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of elements in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a>  <a href="#a2d07d61883fc23f0898c6307e7102007">More...</a><br/></td></tr>
<tr class="separator:a2d07d61883fc23f0898c6307e7102007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c301e7916f8a02346bb10f9335b2ab7"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a4c301e7916f8a02346bb10f9335b2ab7">max_size</a> (void) const </td></tr>
<tr class="memdesc:a4c301e7916f8a02346bb10f9335b2ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the maximun size of the container  <a href="#a4c301e7916f8a02346bb10f9335b2ab7">More...</a><br/></td></tr>
<tr class="separator:a4c301e7916f8a02346bb10f9335b2ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0451556ed950495364a88d88483841d8"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a0451556ed950495364a88d88483841d8">pos</a> (unsigned_type Pos1) const </td></tr>
<tr class="memdesc:a0451556ed950495364a88d88483841d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to an element by their position in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a>.  <a href="#a0451556ed950495364a88d88483841d8">More...</a><br/></td></tr>
<tr class="separator:a0451556ed950495364a88d88483841d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6a44f8a261b171edf154969a92c586"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#acd6a44f8a261b171edf154969a92c586">front</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:acd6a44f8a261b171edf154969a92c586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const_reference to the first element in the sorted_tree.  <a href="#acd6a44f8a261b171edf154969a92c586">More...</a><br/></td></tr>
<tr class="separator:acd6a44f8a261b171edf154969a92c586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492355ba6b502b8e8e6237ed526dbba6"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a492355ba6b502b8e8e6237ed526dbba6">back</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a492355ba6b502b8e8e6237ed526dbba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const_reference to the last element in the sorted_tree.  <a href="#a492355ba6b502b8e8e6237ed526dbba6">More...</a><br/></td></tr>
<tr class="separator:a492355ba6b502b8e8e6237ed526dbba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb2359fa3d83bf0c50e9f67ad1f4a9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#afd74276cf1bfb742233ab324a13866f3">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#accb2359fa3d83bf0c50e9f67ad1f4a9e">find</a> (const <a class="el" href="classcountertree_1_1cntree__set.html#a142d158c5cd5097d80e3ca5f82486395">key_type</a> &amp;x) const </td></tr>
<tr class="memdesc:accb2359fa3d83bf0c50e9f67ad1f4a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the iterator to the element with the key x  <a href="#accb2359fa3d83bf0c50e9f67ad1f4a9e">More...</a><br/></td></tr>
<tr class="separator:accb2359fa3d83bf0c50e9f67ad1f4a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe1ae46e484de47e76c9497bc7004a0"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#acfe1ae46e484de47e76c9497bc7004a0">count</a> (const <a class="el" href="classcountertree_1_1cntree__set.html#a142d158c5cd5097d80e3ca5f82486395">key_type</a> &amp;x) const </td></tr>
<tr class="memdesc:acfe1ae46e484de47e76c9497bc7004a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of elements in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> with the key x  <a href="#acfe1ae46e484de47e76c9497bc7004a0">More...</a><br/></td></tr>
<tr class="separator:acfe1ae46e484de47e76c9497bc7004a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84152e465bc5c628579adcd9ccb5bad3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#afd74276cf1bfb742233ab324a13866f3">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a84152e465bc5c628579adcd9ccb5bad3">lower_bound</a> (const <a class="el" href="classcountertree_1_1cntree__set.html#a142d158c5cd5097d80e3ca5f82486395">key_type</a> &amp;x) const </td></tr>
<tr class="memdesc:a84152e465bc5c628579adcd9ccb5bad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">return one iterator to the first appearance of the key x if exist <br/>
 and if don't exist return one iterator to the first element greather than x  <a href="#a84152e465bc5c628579adcd9ccb5bad3">More...</a><br/></td></tr>
<tr class="separator:a84152e465bc5c628579adcd9ccb5bad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a856776911aebcf019c94371f6d3889"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#afd74276cf1bfb742233ab324a13866f3">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a5a856776911aebcf019c94371f6d3889">upper_bound</a> (const <a class="el" href="classcountertree_1_1cntree__set.html#a142d158c5cd5097d80e3ca5f82486395">key_type</a> &amp;x) const </td></tr>
<tr class="memdesc:a5a856776911aebcf019c94371f6d3889"><td class="mdescLeft">&#160;</td><td class="mdescRight">return one iterator to the first element greather than x. If don't exist any element greather than x , return <a class="el" href="classcountertree_1_1cntree__set.html#ac674e4c83dddaed3c6d9e1d17bf1e560">end()</a>  <a href="#a5a856776911aebcf019c94371f6d3889">More...</a><br/></td></tr>
<tr class="separator:a5a856776911aebcf019c94371f6d3889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70adbcc09def0f0c73c108dd110c0db3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classcountertree_1_1cntree__set.html#afd74276cf1bfb742233ab324a13866f3">iterator</a>, <a class="el" href="classcountertree_1_1cntree__set.html#afd74276cf1bfb742233ab324a13866f3">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a70adbcc09def0f0c73c108dd110c0db3">equal_range</a> (const <a class="el" href="classcountertree_1_1cntree__set.html#a142d158c5cd5097d80e3ca5f82486395">key_type</a> &amp;x) const </td></tr>
<tr class="memdesc:a70adbcc09def0f0c73c108dd110c0db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a pair of iterators, the first is the lower_bound (x) and the second is upper_bound (x)  <a href="#a70adbcc09def0f0c73c108dd110c0db3">More...</a><br/></td></tr>
<tr class="separator:a70adbcc09def0f0c73c108dd110c0db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bacab84d0249cddb1c406631f6793e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a78bacab84d0249cddb1c406631f6793e">const_iterator_pos</a> (signed_type Pos1) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a78bacab84d0249cddb1c406631f6793e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a position in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a>.  <a href="#a78bacab84d0249cddb1c406631f6793e">More...</a><br/></td></tr>
<tr class="separator:a78bacab84d0249cddb1c406631f6793e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569fbae496e961efbac5c422bccfef52"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a569fbae496e961efbac5c422bccfef52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a569fbae496e961efbac5c422bccfef52">emplace_internal</a> (<a class="el" href="classcountertree_1_1cntree__set.html#a4aca29e3930a2005f7ae6095bab46d5f">barrier_modify</a> &amp;BM, <a class="el" href="classcountertree_1_1cntree__set.html#a03510aa8ff80ed2b0505f5310a30d8f5">connector</a> C, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a569fbae496e961efbac5c422bccfef52"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in a the position specified by the connector  <a href="#a569fbae496e961efbac5c422bccfef52">More...</a><br/></td></tr>
<tr class="separator:a569fbae496e961efbac5c422bccfef52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92018e42671a2b7b6b9a1e9899a6a27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#aeb366f2902148e5fc9841e311e664f01">mypair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#ac92018e42671a2b7b6b9a1e9899a6a27">insert</a> (const value_t &amp;Val)</td></tr>
<tr class="memdesc:ac92018e42671a2b7b6b9a1e9899a6a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a value in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a>  <a href="#ac92018e42671a2b7b6b9a1e9899a6a27">More...</a><br/></td></tr>
<tr class="separator:ac92018e42671a2b7b6b9a1e9899a6a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39a3296072b34607dc59abb7194ed78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#aeb366f2902148e5fc9841e311e664f01">mypair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#af39a3296072b34607dc59abb7194ed78">insert_if</a> (std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt; M, const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;Val)</td></tr>
<tr class="memdesc:af39a3296072b34607dc59abb7194ed78"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a value in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a>  <a href="#af39a3296072b34607dc59abb7194ed78">More...</a><br/></td></tr>
<tr class="separator:af39a3296072b34607dc59abb7194ed78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d439a881c4225cf23dc2ca7799cc048"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#aeb366f2902148e5fc9841e311e664f01">mypair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a0d439a881c4225cf23dc2ca7799cc048">insert</a> (<a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:a0d439a881c4225cf23dc2ca7799cc048"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a value in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a>  <a href="#a0d439a881c4225cf23dc2ca7799cc048">More...</a><br/></td></tr>
<tr class="separator:a0d439a881c4225cf23dc2ca7799cc048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6708c2590821948f780262d5c0eb9ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#aeb366f2902148e5fc9841e311e664f01">mypair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#aa6708c2590821948f780262d5c0eb9ce">insert_if</a> (std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt; M, <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:aa6708c2590821948f780262d5c0eb9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a value in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a>  <a href="#aa6708c2590821948f780262d5c0eb9ce">More...</a><br/></td></tr>
<tr class="separator:aa6708c2590821948f780262d5c0eb9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b486d9368f28560b6bcaf0d1ff86d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a40b486d9368f28560b6bcaf0d1ff86d7">insert</a> (<a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>, const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a40b486d9368f28560b6bcaf0d1ff86d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a value in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a>  <a href="#a40b486d9368f28560b6bcaf0d1ff86d7">More...</a><br/></td></tr>
<tr class="separator:a40b486d9368f28560b6bcaf0d1ff86d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e355a6ba42d796a3b3749835d3836e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a4e355a6ba42d796a3b3749835d3836e1">insert</a> (<a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>, <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:a4e355a6ba42d796a3b3749835d3836e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a value in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a>  <a href="#a4e355a6ba42d796a3b3749835d3836e1">More...</a><br/></td></tr>
<tr class="separator:a4e355a6ba42d796a3b3749835d3836e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2a4f758027d942a73f0c76a4bf4fc5"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a4f2a4f758027d942a73f0c76a4bf4fc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#aeb366f2902148e5fc9841e311e664f01">mypair</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a4f2a4f758027d942a73f0c76a4bf4fc5">emplace</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a4f2a4f758027d942a73f0c76a4bf4fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a value in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a>  <a href="#a4f2a4f758027d942a73f0c76a4bf4fc5">More...</a><br/></td></tr>
<tr class="separator:a4f2a4f758027d942a73f0c76a4bf4fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760d66ab532606ef6630f9201d5d1207"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a760d66ab532606ef6630f9201d5d1207"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#aeb366f2902148e5fc9841e311e664f01">mypair</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a760d66ab532606ef6630f9201d5d1207">emplace_if</a> (std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt; M, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a760d66ab532606ef6630f9201d5d1207"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a value in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a>  <a href="#a760d66ab532606ef6630f9201d5d1207">More...</a><br/></td></tr>
<tr class="separator:a760d66ab532606ef6630f9201d5d1207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6185bf37c647eb51aa0f8703402e9764"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a6185bf37c647eb51aa0f8703402e9764"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a6185bf37c647eb51aa0f8703402e9764">emplace_hint</a> (<a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a6185bf37c647eb51aa0f8703402e9764"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a value in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a>  <a href="#a6185bf37c647eb51aa0f8703402e9764">More...</a><br/></td></tr>
<tr class="separator:a6185bf37c647eb51aa0f8703402e9764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38af24759f823d752961eacb0987e14f"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a38af24759f823d752961eacb0987e14f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a38af24759f823d752961eacb0987e14f">insert</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a38af24759f823d752961eacb0987e14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion of range of elements from two iterators.  <a href="#a38af24759f823d752961eacb0987e14f">More...</a><br/></td></tr>
<tr class="separator:a38af24759f823d752961eacb0987e14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b400a74b890670f8a139cd6f5a74b4"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a20b400a74b890670f8a139cd6f5a74b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a20b400a74b890670f8a139cd6f5a74b4">insert_if</a> (InputIterator first, InputIterator last, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt; M)</td></tr>
<tr class="memdesc:a20b400a74b890670f8a139cd6f5a74b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion of range of elements from two iterators.  <a href="#a20b400a74b890670f8a139cd6f5a74b4">More...</a><br/></td></tr>
<tr class="separator:a20b400a74b890670f8a139cd6f5a74b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f43e9c110300f81b284a0a4e629ebcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a4f43e9c110300f81b284a0a4e629ebcd">pop_front</a> (void)</td></tr>
<tr class="memdesc:a4f43e9c110300f81b284a0a4e629ebcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the container  <a href="#a4f43e9c110300f81b284a0a4e629ebcd">More...</a><br/></td></tr>
<tr class="separator:a4f43e9c110300f81b284a0a4e629ebcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56e1116e4a8f862d4e6678231edbd4d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#aa56e1116e4a8f862d4e6678231edbd4d">pop_front_if</a> (std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt; M1)</td></tr>
<tr class="memdesc:aa56e1116e4a8f862d4e6678231edbd4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the container  <a href="#aa56e1116e4a8f862d4e6678231edbd4d">More...</a><br/></td></tr>
<tr class="separator:aa56e1116e4a8f862d4e6678231edbd4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1de98e763fcdbf0e1d6966a20b3d61"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#aee1de98e763fcdbf0e1d6966a20b3d61">pop_copy_front</a> (value_t &amp;V)</td></tr>
<tr class="memdesc:aee1de98e763fcdbf0e1d6966a20b3d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the tree and return a copy  <a href="#aee1de98e763fcdbf0e1d6966a20b3d61">More...</a><br/></td></tr>
<tr class="separator:aee1de98e763fcdbf0e1d6966a20b3d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6be1192800471504afd6c01375e3bf"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#acb6be1192800471504afd6c01375e3bf">pop_copy_front_if</a> (value_t &amp;V, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt; M1)</td></tr>
<tr class="memdesc:acb6be1192800471504afd6c01375e3bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the tree and return a copy  <a href="#acb6be1192800471504afd6c01375e3bf">More...</a><br/></td></tr>
<tr class="separator:acb6be1192800471504afd6c01375e3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a82f60fa63ea3c27b40ce352aba127"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#ac2a82f60fa63ea3c27b40ce352aba127">pop_move_front</a> (value_t &amp;V)</td></tr>
<tr class="memdesc:ac2a82f60fa63ea3c27b40ce352aba127"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the tree and return a copy with rvalues  <a href="#ac2a82f60fa63ea3c27b40ce352aba127">More...</a><br/></td></tr>
<tr class="separator:ac2a82f60fa63ea3c27b40ce352aba127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23487d4936b5dc6e8e11af0fcc9f9bda"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a23487d4936b5dc6e8e11af0fcc9f9bda">pop_move_front_if</a> (value_t &amp;V, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt; M1)</td></tr>
<tr class="memdesc:a23487d4936b5dc6e8e11af0fcc9f9bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the tree and return a copy with rvalues  <a href="#a23487d4936b5dc6e8e11af0fcc9f9bda">More...</a><br/></td></tr>
<tr class="separator:a23487d4936b5dc6e8e11af0fcc9f9bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacf62f327e42c0ef8a70fb8fff03f2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#acacf62f327e42c0ef8a70fb8fff03f2f">pop_back</a> (void)</td></tr>
<tr class="memdesc:acacf62f327e42c0ef8a70fb8fff03f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the container  <a href="#acacf62f327e42c0ef8a70fb8fff03f2f">More...</a><br/></td></tr>
<tr class="separator:acacf62f327e42c0ef8a70fb8fff03f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836ac53c0c83bac2070a23f41601f4d0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a836ac53c0c83bac2070a23f41601f4d0">pop_back_if</a> (std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt; M1)</td></tr>
<tr class="memdesc:a836ac53c0c83bac2070a23f41601f4d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the container  <a href="#a836ac53c0c83bac2070a23f41601f4d0">More...</a><br/></td></tr>
<tr class="separator:a836ac53c0c83bac2070a23f41601f4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cd317a3c702ec19c0c546d440edfcc"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a48cd317a3c702ec19c0c546d440edfcc">pop_copy_back</a> (value_t &amp;V)</td></tr>
<tr class="memdesc:a48cd317a3c702ec19c0c546d440edfcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the tree and return a copy  <a href="#a48cd317a3c702ec19c0c546d440edfcc">More...</a><br/></td></tr>
<tr class="separator:a48cd317a3c702ec19c0c546d440edfcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35fd4fd1e14b3dded8c751926750a834"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a35fd4fd1e14b3dded8c751926750a834">pop_copy_back_if</a> (value_t &amp;V, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt; M1)</td></tr>
<tr class="memdesc:a35fd4fd1e14b3dded8c751926750a834"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the tree and return a copy  <a href="#a35fd4fd1e14b3dded8c751926750a834">More...</a><br/></td></tr>
<tr class="separator:a35fd4fd1e14b3dded8c751926750a834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34e6fa4b630d8318803424e52410e32"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#ab34e6fa4b630d8318803424e52410e32">pop_move_back</a> (value_t &amp;V)</td></tr>
<tr class="memdesc:ab34e6fa4b630d8318803424e52410e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the tree and return a copy with rvalues  <a href="#ab34e6fa4b630d8318803424e52410e32">More...</a><br/></td></tr>
<tr class="separator:ab34e6fa4b630d8318803424e52410e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af816d12cfdeb45491c873e64838a9fff"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#af816d12cfdeb45491c873e64838a9fff">pop_move_back_if</a> (value_t &amp;V, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt; M1)</td></tr>
<tr class="memdesc:af816d12cfdeb45491c873e64838a9fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the tree and return a copy with rvalues  <a href="#af816d12cfdeb45491c873e64838a9fff">More...</a><br/></td></tr>
<tr class="separator:af816d12cfdeb45491c873e64838a9fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ff2b72655bab3c87402913304dd24e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#ac4ff2b72655bab3c87402913304dd24e">erase</a> (<a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a> iter)</td></tr>
<tr class="memdesc:ac4ff2b72655bab3c87402913304dd24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element pointed by iter  <a href="#ac4ff2b72655bab3c87402913304dd24e">More...</a><br/></td></tr>
<tr class="separator:ac4ff2b72655bab3c87402913304dd24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc5a2c107052c1eebba512a44dfaaff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a9cc5a2c107052c1eebba512a44dfaaff">erase_if</a> (<a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a> iter, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt; M)</td></tr>
<tr class="memdesc:a9cc5a2c107052c1eebba512a44dfaaff"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element pointed by iter  <a href="#a9cc5a2c107052c1eebba512a44dfaaff">More...</a><br/></td></tr>
<tr class="separator:a9cc5a2c107052c1eebba512a44dfaaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8b010b9ee0fbfef4c4b2f042cd1dea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#afb8b010b9ee0fbfef4c4b2f042cd1dea">erase</a> (<a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a> first, <a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a> last)</td></tr>
<tr class="memdesc:afb8b010b9ee0fbfef4c4b2f042cd1dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase a range of elements in the range first, last  <a href="#afb8b010b9ee0fbfef4c4b2f042cd1dea">More...</a><br/></td></tr>
<tr class="separator:afb8b010b9ee0fbfef4c4b2f042cd1dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2bdcbec0f9057dbbf39a2eaf76113e"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a3e2bdcbec0f9057dbbf39a2eaf76113e">erase_if</a> (<a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a> first_it, <a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a> last_it, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt; M)</td></tr>
<tr class="memdesc:a3e2bdcbec0f9057dbbf39a2eaf76113e"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase a range of elements between first_it and last_it  <a href="#a3e2bdcbec0f9057dbbf39a2eaf76113e">More...</a><br/></td></tr>
<tr class="separator:a3e2bdcbec0f9057dbbf39a2eaf76113e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa251745fa4964f4fe8e1c5a4e1e4280f"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#aa251745fa4964f4fe8e1c5a4e1e4280f">erase</a> (const <a class="el" href="classcountertree_1_1cntree__set.html#a142d158c5cd5097d80e3ca5f82486395">key_type</a> &amp;x)</td></tr>
<tr class="memdesc:aa251745fa4964f4fe8e1c5a4e1e4280f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all the elements with a key.  <a href="#aa251745fa4964f4fe8e1c5a4e1e4280f">More...</a><br/></td></tr>
<tr class="separator:aa251745fa4964f4fe8e1c5a4e1e4280f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c788e16aa03ec27f40a1cb335d9a11a"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a2c788e16aa03ec27f40a1cb335d9a11a">erase_if</a> (const <a class="el" href="classcountertree_1_1cntree__set.html#a142d158c5cd5097d80e3ca5f82486395">key_type</a> &amp;x, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt; M)</td></tr>
<tr class="memdesc:a2c788e16aa03ec27f40a1cb335d9a11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all the elements with a key.  <a href="#a2c788e16aa03ec27f40a1cb335d9a11a">More...</a><br/></td></tr>
<tr class="separator:a2c788e16aa03ec27f40a1cb335d9a11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eeb03f92270daaf17419b8d4872b289"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a3eeb03f92270daaf17419b8d4872b289">erase_pos</a> (signed_type Pos)</td></tr>
<tr class="memdesc:a3eeb03f92270daaf17419b8d4872b289"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element of the position pos  <a href="#a3eeb03f92270daaf17419b8d4872b289">More...</a><br/></td></tr>
<tr class="separator:a3eeb03f92270daaf17419b8d4872b289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94aa58e7e47572cea11bb84b2ccf1ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#af94aa58e7e47572cea11bb84b2ccf1ad">erase_pos_if</a> (signed_type Pos, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt; M)</td></tr>
<tr class="memdesc:af94aa58e7e47572cea11bb84b2ccf1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element of the position pos  <a href="#af94aa58e7e47572cea11bb84b2ccf1ad">More...</a><br/></td></tr>
<tr class="separator:af94aa58e7e47572cea11bb84b2ccf1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1f5317a9a02eb5bed1d6d559951612"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a3a1f5317a9a02eb5bed1d6d559951612">erase_pos</a> (signed_type Prim, signed_type NElem)</td></tr>
<tr class="memdesc:a3a1f5317a9a02eb5bed1d6d559951612"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the lements between the position Prim and the position Ult. The position Ult is deleted  <a href="#a3a1f5317a9a02eb5bed1d6d559951612">More...</a><br/></td></tr>
<tr class="separator:a3a1f5317a9a02eb5bed1d6d559951612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1ec56896ca24428e335c437d7454b3"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a0d1ec56896ca24428e335c437d7454b3">erase_pos_if</a> (signed_type Prim, signed_type NElem, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt; M)</td></tr>
<tr class="memdesc:a0d1ec56896ca24428e335c437d7454b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the lements between the position Prim and the position Ult. The position Ult is deleted  <a href="#a0d1ec56896ca24428e335c437d7454b3">More...</a><br/></td></tr>
<tr class="separator:a0d1ec56896ca24428e335c437d7454b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae03e5268c87e251977ea7eb72a0d18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#a16b2cff2f68d23095cf1e5b4acfc20f3">key_compare</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a2ae03e5268c87e251977ea7eb72a0d18">key_comp</a> () const </td></tr>
<tr class="memdesc:a2ae03e5268c87e251977ea7eb72a0d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the object used to compare two keys  <a href="#a2ae03e5268c87e251977ea7eb72a0d18">More...</a><br/></td></tr>
<tr class="separator:a2ae03e5268c87e251977ea7eb72a0d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343dc91aff1b7e9b63e0140f405ff603"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#a82f5e2422ec58470b19259f956763d07">value_compare</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a343dc91aff1b7e9b63e0140f405ff603">value_comp</a> () const </td></tr>
<tr class="memdesc:a343dc91aff1b7e9b63e0140f405ff603"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the object used to compare two values  <a href="#a343dc91aff1b7e9b63e0140f405ff603">More...</a><br/></td></tr>
<tr class="separator:a343dc91aff1b7e9b63e0140f405ff603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb16c18fc488a178828fbe63d3ccf41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#a54ee54c2f9b8a3282ce2af5b54f2c39f">allocator_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#addb16c18fc488a178828fbe63d3ccf41">get_allocator</a> () const </td></tr>
<tr class="memdesc:addb16c18fc488a178828fbe63d3ccf41"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the object allocator of the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a>  <a href="#addb16c18fc488a178828fbe63d3ccf41">More...</a><br/></td></tr>
<tr class="separator:addb16c18fc488a178828fbe63d3ccf41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2084bc5ea5b68224460193e55ca68bd9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a2084bc5ea5b68224460193e55ca68bd9">is_mine</a> (<a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a> it) const </td></tr>
<tr class="memdesc:a2084bc5ea5b68224460193e55ca68bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the iterator is pointing to this <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a>.  <a href="#a2084bc5ea5b68224460193e55ca68bd9">More...</a><br/></td></tr>
<tr class="separator:a2084bc5ea5b68224460193e55ca68bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356695e1cb7a2bc69248ca7914dba77f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a356695e1cb7a2bc69248ca7914dba77f">is_mine</a> (<a class="el" href="classcountertree_1_1cntree__set.html#a30ec4cfe18a49437b9b736830843d6bd">const_reverse_iterator</a> it) const </td></tr>
<tr class="memdesc:a356695e1cb7a2bc69248ca7914dba77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the iterator is pointing to this <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a>.  <a href="#a356695e1cb7a2bc69248ca7914dba77f">More...</a><br/></td></tr>
<tr class="separator:a356695e1cb7a2bc69248ca7914dba77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1fe858e18fd7b5ef0d8880d4ef8297"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a2c1fe858e18fd7b5ef0d8880d4ef8297">cit_begin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a2c1fe858e18fd7b5ef0d8880d4ef8297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d11d2c13a52d91727787e825414ed1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a91d11d2c13a52d91727787e825414ed1">begin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a91d11d2c13a52d91727787e825414ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cfead246466f3d98c6aae999be5d4a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a1cfead246466f3d98c6aae999be5d4a2">cbegin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a1cfead246466f3d98c6aae999be5d4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc84153640e1943523df0197201f9743"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#afc84153640e1943523df0197201f9743">cit_end</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:afc84153640e1943523df0197201f9743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac674e4c83dddaed3c6d9e1d17bf1e560"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#ac674e4c83dddaed3c6d9e1d17bf1e560">end</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ac674e4c83dddaed3c6d9e1d17bf1e560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8c2825cfcdb4fb1648d9f1337a4e5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a5d8c2825cfcdb4fb1648d9f1337a4e5e">cend</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a5d8c2825cfcdb4fb1648d9f1337a4e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2601a23df63455253317ee9c583d0df3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a2601a23df63455253317ee9c583d0df3">cit_rbegin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a2601a23df63455253317ee9c583d0df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0004cc2dc2b01630fbdbc4c6c647fa96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a0004cc2dc2b01630fbdbc4c6c647fa96">cit_rend</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a0004cc2dc2b01630fbdbc4c6c647fa96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5aed5b4179d4c7bbf24aa17f749f5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#a30ec4cfe18a49437b9b736830843d6bd">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a3c5aed5b4179d4c7bbf24aa17f749f5f">crit_begin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a3c5aed5b4179d4c7bbf24aa17f749f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13f2289316b1bd2a1926c90d42017ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#a30ec4cfe18a49437b9b736830843d6bd">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#ac13f2289316b1bd2a1926c90d42017ed">crit_end</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ac13f2289316b1bd2a1926c90d42017ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab718ec504ea041287ad90ade105e0195"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#a30ec4cfe18a49437b9b736830843d6bd">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#ab718ec504ea041287ad90ade105e0195">crit_rbegin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ab718ec504ea041287ad90ade105e0195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3ac4378167a9916d9561f020b817d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#a30ec4cfe18a49437b9b736830843d6bd">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a1a3ac4378167a9916d9561f020b817d5">rbegin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a1a3ac4378167a9916d9561f020b817d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1792946a5a1cc6b2e502b13866c33a75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#a30ec4cfe18a49437b9b736830843d6bd">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a1792946a5a1cc6b2e502b13866c33a75">crbegin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a1792946a5a1cc6b2e502b13866c33a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae1222704112f7539cdb55813cf9e9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#a30ec4cfe18a49437b9b736830843d6bd">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a5ae1222704112f7539cdb55813cf9e9d">crit_rend</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a5ae1222704112f7539cdb55813cf9e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9580cf049e3515eccc73655937144b8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#a30ec4cfe18a49437b9b736830843d6bd">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a9580cf049e3515eccc73655937144b8f">rend</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a9580cf049e3515eccc73655937144b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cc4c324cd9c95f2258c5dd7d8786c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#a30ec4cfe18a49437b9b736830843d6bd">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a25cc4c324cd9c95f2258c5dd7d8786c2">crend</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a25cc4c324cd9c95f2258c5dd7d8786c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a60f5dfe2878f9d36e42b0d9c5797d472"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__set.html#a5aa094be346ef7863afae8833a149718">barrier_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a60f5dfe2878f9d36e42b0d9c5797d472">BD</a></td></tr>
<tr class="separator:a60f5dfe2878f9d36e42b0d9c5797d472"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a5fe7b75d71ee9e25d2ab8e361676c077"><td class="memTemplParams" colspan="2">template&lt;class value_t2 , bool cnc2, typename comp_key_t2 , typename alloc_t2 &gt; </td></tr>
<tr class="memitem:a5fe7b75d71ee9e25d2ab8e361676c077"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a5fe7b75d71ee9e25d2ab8e361676c077">cntree_set</a></td></tr>
<tr class="separator:a5fe7b75d71ee9e25d2ab8e361676c077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2322fd5e1cffe75b7cf1508b4f3b6d44"><td class="memTemplParams" colspan="2">template&lt;class value_t2 , bool cnc2, typename comp_key_t2 , typename alloc_t2 &gt; </td></tr>
<tr class="memitem:a2322fd5e1cffe75b7cf1508b4f3b6d44"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__set.html#a2322fd5e1cffe75b7cf1508b4f3b6d44">cntree_multiset</a></td></tr>
<tr class="separator:a2322fd5e1cffe75b7cf1508b4f3b6d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt;<br/>
class countertree::cntree_set&lt; value_t, cnc, comp_key_t, alloc_t &gt;</h3>

<p>This class have the same interface than the STL set, plus access by position with the function at, and random access iterators. </p>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00057">57</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a54ee54c2f9b8a3282ce2af5b54f2c39f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef alloc_t <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#a54ee54c2f9b8a3282ce2af5b54f2c39f">allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00081">81</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5aa094be346ef7863afae8833a149718"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcountertree_1_1config__barrier.html">config_barrier</a>&lt;cnc&gt;::<a class="el" href="classcountertree_1_1cntree__set.html#a5aa094be346ef7863afae8833a149718">barrier_data</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#a5aa094be346ef7863afae8833a149718">barrier_data</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00068">68</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4aca29e3930a2005f7ae6095bab46d5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcountertree_1_1config__barrier.html">config_barrier</a>&lt;cnc&gt;::<a class="el" href="classcountertree_1_1cntree__set.html#a4aca29e3930a2005f7ae6095bab46d5f">barrier_modify</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#a4aca29e3930a2005f7ae6095bab46d5f">barrier_modify</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00070">70</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a98e200626bbc80510cff0f1e9eca8407"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcountertree_1_1config__barrier.html">config_barrier</a>&lt;cnc&gt;::<a class="el" href="classcountertree_1_1cntree__set.html#a98e200626bbc80510cff0f1e9eca8407">barrier_read</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#a98e200626bbc80510cff0f1e9eca8407">barrier_read</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00069">69</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a03510aa8ff80ed2b0505f5310a30d8f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcountertree_1_1forest_1_1connector.html">c_forest::connector</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#a03510aa8ff80ed2b0505f5310a30d8f5">connector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00093">93</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef86483cd89fac74df4600332d14376f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">srt_tree_t::const_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00087">87</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af2eef2d4200f796f567ebb76a786b184"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const value_t* <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#af2eef2d4200f796f567ebb76a786b184">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00075">75</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8ef9228b8ac85d5c3c626a21b1621a40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const value_t&amp; <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#a8ef9228b8ac85d5c3c626a21b1621a40">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00077">77</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a30ec4cfe18a49437b9b736830843d6bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">srt_tree_t::const_reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#a30ec4cfe18a49437b9b736830843d6bd">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00091">91</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af5e448bff7ba8b0337930749a89c99a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacecountertree_1_1common.html#aacea70d0e38fcfefebf3b6ad0a88ae6f">c_common::signed_type</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#af5e448bff7ba8b0337930749a89c99a7">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00089">89</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abdb587276553b09c1e3f2b5ff51dd4d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcountertree_1_1filter__set.html">filter_set</a>&lt;<a class="el" href="classcountertree_1_1cntree__set.html#a196f6e183c5dd70c835a48efe785b62b">key_t</a>,value_t&gt; <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#abdb587276553b09c1e3f2b5ff51dd4d4">filter_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00064">64</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afd74276cf1bfb742233ab324a13866f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">srt_tree_t::const_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#afd74276cf1bfb742233ab324a13866f3">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00086">86</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a16b2cff2f68d23095cf1e5b4acfc20f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef comp_key_t <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#a16b2cff2f68d23095cf1e5b4acfc20f3">key_compare</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00079">79</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a196f6e183c5dd70c835a48efe785b62b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef value_t <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#a196f6e183c5dd70c835a48efe785b62b">key_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00063">63</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a142d158c5cd5097d80e3ca5f82486395"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1cntree__set.html#a196f6e183c5dd70c835a48efe785b62b">key_t</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#a142d158c5cd5097d80e3ca5f82486395">key_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00072">72</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeb366f2902148e5fc9841e311e664f01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>,bool&gt; <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#aeb366f2902148e5fc9841e311e664f01">mypair</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00092">92</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af919b766e7e832128bcefe7aecb41b7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a2a86f27200857c04dd1f46e11973e2a1">srt_tree_t::node_alloc_t</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#af919b766e7e832128bcefe7aecb41b7e">node_alloc_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00085">85</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad3745b0a456cf2bd200d743eb028f8e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">srt_tree_t::node_t</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#ad3745b0a456cf2bd200d743eb028f8e2">node_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00084">84</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a59583855f02b16841854fe7421beed38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef value_t* <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#a59583855f02b16841854fe7421beed38">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00074">74</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae4e11332f4c9943fb16a70aeacc22fcf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef value_t&amp; <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#ae4e11332f4c9943fb16a70aeacc22fcf">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00076">76</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a117dd410af94c84f30928f35cef904c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">srt_tree_t::const_reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#a117dd410af94c84f30928f35cef904c9">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00090">90</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a136e00e6b17bb9b30223c2a9257ff96a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacecountertree_1_1common.html#aacea70d0e38fcfefebf3b6ad0a88ae6f">c_common::signed_type</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#a136e00e6b17bb9b30223c2a9257ff96a">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00088">88</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab8b123109035b474c184d82de04330d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">c_forest::sorted_tree</a>&lt;value_t,<a class="el" href="classcountertree_1_1cntree__set.html#a196f6e183c5dd70c835a48efe785b62b">key_t</a>,<a class="el" href="classcountertree_1_1cntree__set.html#abdb587276553b09c1e3f2b5ff51dd4d4">filter_t</a>,comp_key_t,alloc_t&gt; <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#ab8b123109035b474c184d82de04330d4">srt_tree_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00066">66</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a99b3b59c6fcdc46d8d9cd14b5ebeef32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a435616fae6b22fcb60996905ea17aef1">srt_tree_t::tree</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#a99b3b59c6fcdc46d8d9cd14b5ebeef32">tree</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00083">83</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a82f5e2422ec58470b19259f956763d07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef comp_key_t <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#a82f5e2422ec58470b19259f956763d07">value_compare</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00080">80</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a49c320efb21a90299334c684f1c9aa32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef value_t <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00073">73</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2054d35d0d6a9a520b9063690fae634b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1cntree__set.html#a16b2cff2f68d23095cf1e5b4acfc20f3">key_compare</a> &amp;&#160;</td>
          <td class="paramname"><em>C1</em> = <code><a class="el" href="classcountertree_1_1cntree__set.html#a16b2cff2f68d23095cf1e5b4acfc20f3">key_compare</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const alloc_t &amp;&#160;</td>
          <td class="paramname"><em>A1</em> = <code>alloc_t&#160;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from an object Comparer and an object Allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C1</td><td>: Comparer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A1</td><td>: Allocator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00146">146</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a62513c8d07075b61953d9486be428fa4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1cntree__set.html#a16b2cff2f68d23095cf1e5b4acfc20f3">key_compare</a> &amp;&#160;</td>
          <td class="paramname"><em>C1</em> = <code><a class="el" href="classcountertree_1_1cntree__set.html#a16b2cff2f68d23095cf1e5b4acfc20f3">key_compare</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const alloc_t &amp;&#160;</td>
          <td class="paramname"><em>A1</em> = <code>alloc_t&#160;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from a pair of iterators and an object Comparer and an object Allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>: iterator to the first element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>: iterator to the last element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C1</td><td>: Comparer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A1</td><td>: Allocator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00160">160</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a29b879b9031b8e9b7de40c85f15e9966"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00173">173</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a414cd143222f7c45b0d4cf8d7d5d6763"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00185">185</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac2702c78eb385e1c91a90d4c5a1e8d66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;bool cnc2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a>&lt; value_t, cnc2, comp_key_t, alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00199">199</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a48f79d365f3c4894bd8996a92a0f9405"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename alloc_t2 , bool cnc2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a>&lt; value_t, cnc2, comp_key_t, alloc_t2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00214">214</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abe82423acbb3403e5d1426f890484336"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::~<a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00226">226</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a492355ba6b502b8e8e6237ed526dbba6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t&amp; <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const_reference to the last element in the sorted_tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the last element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00426">426</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a91d11d2c13a52d91727787e825414ed1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01323">1323</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1cfead246466f3d98c6aae999be5d4a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01331">1331</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5d8c2825cfcdb4fb1648d9f1337a4e5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::cend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01355">1355</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2c1fe858e18fd7b5ef0d8880d4ef8297"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::cit_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01315">1315</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afc84153640e1943523df0197201f9743"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::cit_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01339">1339</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2601a23df63455253317ee9c583d0df3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::cit_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01363">1363</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0004cc2dc2b01630fbdbc4c6c647fa96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::cit_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01371">1371</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abddf88e99f2b7f249ae7c35775eba942"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete all the elements of the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00312">312</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a78bacab84d0249cddb1c406631f6793e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::const_iterator_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos1</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a position in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the position. If don't exists throws an exception </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log N) </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00506">506</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acfe1ae46e484de47e76c9497bc7004a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1cntree__set.html#a142d158c5cd5097d80e3ca5f82486395">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the number of elements in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> with the key x </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> with the key x </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is log (N) </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00461">461</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1792946a5a1cc6b2e502b13866c33a75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#a30ec4cfe18a49437b9b736830843d6bd">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::crbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01427">1427</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a25cc4c324cd9c95f2258c5dd7d8786c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#a30ec4cfe18a49437b9b736830843d6bd">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::crend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01451">1451</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3c5aed5b4179d4c7bbf24aa17f749f5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#a30ec4cfe18a49437b9b736830843d6bd">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::crit_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01395">1395</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac13f2289316b1bd2a1926c90d42017ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#a30ec4cfe18a49437b9b736830843d6bd">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::crit_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01403">1403</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab718ec504ea041287ad90ade105e0195"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#a30ec4cfe18a49437b9b736830843d6bd">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::crit_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01411">1411</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5ae1222704112f7539cdb55813cf9e9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#a30ec4cfe18a49437b9b736830843d6bd">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::crit_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01435">1435</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f2a4f758027d942a73f0c76a4bf4fc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#aeb366f2902148e5fc9841e311e664f01">mypair</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a value in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>: arguments needed for to build the node to insert in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair &lt;iterator,bool&gt; with the iterator to the element inserted or or to the element that prevented the insertion, and a bool indication if the insertion is done </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00676">676</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6185bf37c647eb51aa0f8703402e9764"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::emplace_hint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a value in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair &lt;iterator,bool&gt; with the iterator to the element inserted or or to the element that prevented the insertion, and a bool indication if the insertion is done </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00743">743</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a760d66ab532606ef6630f9201d5d1207"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#aeb366f2902148e5fc9841e311e664f01">mypair</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::emplace_if </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a value in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair &lt;iterator,bool&gt; with the iterator to the element inserted or or to the element that prevented the insertion, and a bool indication if the insertion is done. When the element is rejected by the function , the itertor of the pair is <a class="el" href="classcountertree_1_1cntree__set.html#ac674e4c83dddaed3c6d9e1d17bf1e560">end()</a> and the bool false </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00707">707</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a569fbae496e961efbac5c422bccfef52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::emplace_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__set.html#a4aca29e3930a2005f7ae6095bab46d5f">barrier_modify</a> &amp;&#160;</td>
          <td class="paramname"><em>BM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__set.html#a03510aa8ff80ed2b0505f5310a30d8f5">connector</a>&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in a the position specified by the connector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>: connector which indicate where must insert the node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>: arguments to build the node to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00557">557</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1c924d018918848d91bfad273844353d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>indicate if the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> is empty </p>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> is empty, false in any other case </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00347">347</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac674e4c83dddaed3c6d9e1d17bf1e560"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01347">1347</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a70adbcc09def0f0c73c108dd110c0db3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classcountertree_1_1cntree__set.html#afd74276cf1bfb742233ab324a13866f3">iterator</a>,<a class="el" href="classcountertree_1_1cntree__set.html#afd74276cf1bfb742233ab324a13866f3">iterator</a>&gt; <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1cntree__set.html#a142d158c5cd5097d80e3ca5f82486395">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a pair of iterators, the first is the lower_bound (x) and the second is upper_bound (x) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>:key to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of iterators </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00494">494</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac4ff2b72655bab3c87402913304dd24e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element pointed by iter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>: iterator to the element to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01057">1057</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afb8b010b9ee0fbfef4c4b2f042cd1dea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase a range of elements in the range first, last </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>: iterator to the first element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>: iterator to the last element of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01086">1086</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa251745fa4964f4fe8e1c5a4e1e4280f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1cntree__set.html#a142d158c5cd5097d80e3ca5f82486395">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase all the elements with a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key of all the elements to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements erased </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01114">1114</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9cc5a2c107052c1eebba512a44dfaaff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element pointed by iter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>: iterator to the element to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01070">1070</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3e2bdcbec0f9057dbbf39a2eaf76113e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase a range of elements between first_it and last_it </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first_it</td><td>: const_iterator to the first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last_it</td><td>: const_iterator to the final element of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements erased </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01101">1101</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2c788e16aa03ec27f40a1cb335d9a11a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::erase_if </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1cntree__set.html#a142d158c5cd5097d80e3ca5f82486395">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase all the elements with a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key of all the elements to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements erased </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01129">1129</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3eeb03f92270daaf17419b8d4872b289"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::erase_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element of the position pos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>: position to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01150">1150</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3a1f5317a9a02eb5bed1d6d559951612"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::erase_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Prim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>NElem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the lements between the position Prim and the position Ult. The position Ult is deleted </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Prim</td><td>: position to the first element to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NElem</td><td>: Number of elements to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01183">1183</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af94aa58e7e47572cea11bb84b2ccf1ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::erase_pos_if </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element of the position pos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>: position to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01164">1164</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0d1ec56896ca24428e335c437d7454b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::erase_pos_if </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Prim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>NElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the lements between the position Prim and the position Ult. The position Ult is deleted </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Prim</td><td>: position to the first element to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NElem</td><td>: Number of elements to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01198">1198</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="accb2359fa3d83bf0c50e9f67ad1f4a9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#afd74276cf1bfb742233ab324a13866f3">iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1cntree__set.html#a142d158c5cd5097d80e3ca5f82486395">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the iterator to the element with the key x </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key to find in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element with the key x. If don't exist return <a class="el" href="classcountertree_1_1cntree__set.html#ac674e4c83dddaed3c6d9e1d17bf1e560">end()</a> </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00450">450</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acd6a44f8a261b171edf154969a92c586"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t&amp; <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const_reference to the first element in the sorted_tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the first element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00415">415</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="addb16c18fc488a178828fbe63d3ccf41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#a54ee54c2f9b8a3282ce2af5b54f2c39f">allocator_type</a>&amp; <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the object allocator of the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>object allocator </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01251">1251</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac92018e42671a2b7b6b9a1e9899a6a27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#aeb366f2902148e5fc9841e311e664f01">mypair</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a value in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair &lt;iterator,bool&gt; with the iterator to the element inserted or or to the element that prevented the insertion, and a bool indication if the insertion is done </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00573">573</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0d439a881c4225cf23dc2ca7799cc048"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#aeb366f2902148e5fc9841e311e664f01">mypair</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a value in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair &lt;iterator,bool&gt; with the iterator to the element inserted or or to the element that prevented the insertion, and a bool indication if the insertion is done </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00614">614</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a40b486d9368f28560b6bcaf0d1ff86d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a value in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns an iterator to the inserted element, or to the element that prevented the insertion. </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00655">655</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4e355a6ba42d796a3b3749835d3836e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a value in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns an iterator to the inserted element, or to the element that prevented the insertion. </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00665">665</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a38af24759f823d752961eacb0987e14f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insertion of range of elements from two iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>: Iterator to the first element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>: Iterator to the last lement of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00755">755</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af39a3296072b34607dc59abb7194ed78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#aeb366f2902148e5fc9841e311e664f01">mypair</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::insert_if </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>Val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a value in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>: value to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function whixh decide if the node is inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair &lt;iterator,bool&gt; with the iterator to the element inserted or or to the element that prevented the insertion, and a bool indication if the insertion is done. When the element is rejected by the function , the itertor of the pair is <a class="el" href="classcountertree_1_1cntree__set.html#ac674e4c83dddaed3c6d9e1d17bf1e560">end()</a> and the bool false </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00592">592</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa6708c2590821948f780262d5c0eb9ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#aeb366f2902148e5fc9841e311e664f01">mypair</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::insert_if </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a value in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>: value to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function whixh decide if the node is inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair &lt;iterator,bool&gt; with the iterator to the element inserted or or to the element that prevented the insertion, and a bool indication if the insertion is done. When the element is rejected by the function , the itertor of the pair is <a class="el" href="classcountertree_1_1cntree__set.html#ac674e4c83dddaed3c6d9e1d17bf1e560">end()</a> and the bool false </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00634">634</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a20b400a74b890670f8a139cd6f5a74b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::insert_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insertion of range of elements from two iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>: Iterator to the first element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>: Iterator to the last lement of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00769">769</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2084bc5ea5b68224460193e55ca68bd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::is_mine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__set.html#aef86483cd89fac74df4600332d14376f">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the iterator is pointing to this <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: iterator to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(true/false ) Indicate if it is pointing to this <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01280">1280</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a356695e1cb7a2bc69248ca7914dba77f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::is_mine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__set.html#a30ec4cfe18a49437b9b736830843d6bd">const_reverse_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the iterator is pointing to this <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: iterator to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(true/false ) Indicate if it is pointing to this <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01291">1291</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2ae03e5268c87e251977ea7eb72a0d18"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#a16b2cff2f68d23095cf1e5b4acfc20f3">key_compare</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::key_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the object used to compare two keys </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>object used to compare two keys </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01231">1231</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a84152e465bc5c628579adcd9ccb5bad3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#afd74276cf1bfb742233ab324a13866f3">iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1cntree__set.html#a142d158c5cd5097d80e3ca5f82486395">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return one iterator to the first appearance of the key x if exist <br/>
 and if don't exist return one iterator to the first element greather than x </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00472">472</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4c301e7916f8a02346bb10f9335b2ab7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::max_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the maximun size of the container </p>
<dl class="section return"><dt>Returns</dt><dd>maximun size of the container </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00365">365</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abe5563263ac7c294f3ac51466eaec589"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a>&amp; <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asignation operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>: cntree_setr from where copy the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> after the copy </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00253">253</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9005467f1d05e7d5395efbda0b1774a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename alloc_t2 , bool cnc2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a>&amp; <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a>&lt; value_t, cnc2, comp_key_t, alloc_t2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asignation operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>: cntree_setr from where copy the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> after the copy </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00268">268</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6af8567dcc86d1548fc8e46ff01887b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a>&amp; <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asignation operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>: cntree_setr from where copy the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> after the copy </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00282">282</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac0f1268a7981798327cbcb735301f1fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;bool cnc2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a>&amp; <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a>&lt; value_t, cnc2, comp_key_t, alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00297">297</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acacf62f327e42c0ef8a70fb8fff03f2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pop_back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant) </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00948">948</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a836ac53c0c83bac2070a23f41601f4d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pop_back_if </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M1</td><td>: function to check the value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree 2 - Function returns false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant) </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00963">963</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a48cd317a3c702ec19c0c546d440edfcc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pop_copy_back </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the tree and return a copy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00982">982</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a35fd4fd1e14b3dded8c751926750a834"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pop_copy_back_if </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the tree and return a copy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree 2 - Function returns false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01001">1001</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aee1de98e763fcdbf0e1d6966a20b3d61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pop_copy_front </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the tree and return a copy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00872">872</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acb6be1192800471504afd6c01375e3bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pop_copy_front_if </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the tree and return a copy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree 2 - Function returns false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00891">891</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f43e9c110300f81b284a0a4e629ebcd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pop_front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (constant) </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00837">837</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa56e1116e4a8f862d4e6678231edbd4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pop_front_if </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree 2 - Function returns false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (constant) </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00852">852</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab34e6fa4b630d8318803424e52410e32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pop_move_back </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the tree and return a copy with rvalues </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01021">1021</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af816d12cfdeb45491c873e64838a9fff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pop_move_back_if </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the tree and return a copy with rvalues </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01039">1039</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac2a82f60fa63ea3c27b40ce352aba127"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pop_move_front </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the tree and return a copy with rvalues </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00911">911</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a23487d4936b5dc6e8e11af0fcc9f9bda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pop_move_front_if </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__set.html#a49c320efb21a90299334c684f1c9aa32">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the tree and return a copy with rvalues </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00929">929</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0451556ed950495364a88d88483841d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t&amp; <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pos </td>
          <td>(</td>
          <td class="paramtype">unsigned_type&#160;</td>
          <td class="paramname"><em>Pos1</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to an element by their position in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the object selected </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is an random access function of the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a>.<br/>
 I didn't use the operator [ ] because it is used in the map class, and the function at is used in std map in C++11<br/>
 It is very important to be uniform access method in the four classes( cntree_set, multiset, map and multimap)<br/>
 This operation is O (log(N)) </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00403">403</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1a3ac4378167a9916d9561f020b817d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#a30ec4cfe18a49437b9b736830843d6bd">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01419">1419</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9580cf049e3515eccc73655937144b8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#a30ec4cfe18a49437b9b736830843d6bd">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01443">1443</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d07d61883fc23f0898c6307e7102007"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the number of elements in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> </p>
<dl class="section return"><dt>Returns</dt><dd>number of elements in the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00356">356</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a44e3660ea7ef2a49f36924ec7e1ee12a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>swap the data of the <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> st with the actual <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">st</td><td>: <a class="el" href="classcountertree_1_1cntree__set.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a> to swap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00324">324</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a856776911aebcf019c94371f6d3889"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#afd74276cf1bfb742233ab324a13866f3">iterator</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1cntree__set.html#a142d158c5cd5097d80e3ca5f82486395">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return one iterator to the first element greather than x. If don't exist any element greather than x , return <a class="el" href="classcountertree_1_1cntree__set.html#ac674e4c83dddaed3c6d9e1d17bf1e560">end()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00483">483</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a343dc91aff1b7e9b63e0140f405ff603"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#a82f5e2422ec58470b19259f956763d07">value_compare</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::value_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the object used to compare two values </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>object used to compare two values </dd></dl>

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l01241">1241</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a2322fd5e1cffe75b7cf1508b4f3b6d44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class value_t2 , bool cnc2, typename comp_key_t2 , typename alloc_t2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classcountertree_1_1cntree__multiset.html">cntree_multiset</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00103">103</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5fe7b75d71ee9e25d2ab8e361676c077"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class value_t2 , bool cnc2, typename comp_key_t2 , typename alloc_t2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00102">102</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a60f5dfe2878f9d36e42b0d9c5797d472"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__set.html#a5aa094be346ef7863afae8833a149718">barrier_data</a> <a class="el" href="classcountertree_1_1cntree__set.html">countertree::cntree_set</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::BD</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__set_8hpp_source.html#l00113">113</a> of file <a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="cntree__set_8hpp_source.html">cntree_set.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecountertree.html">countertree</a></li><li class="navelem"><a class="el" href="classcountertree_1_1cntree__set.html">cntree_set</a></li>
    <li class="footer">Generated on Tue Jul 30 2013 18:10:27 for Countertree by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
