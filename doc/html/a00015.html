<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>[ countertree + suballocator ]: countertree::cntree_map&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">[ countertree + suballocator ]
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00015.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="a00153.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">countertree::cntree_map&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class have the same interface and functions than the class <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> defined in the Standard Template Library ( STL), plus a function at which permit to access to the elements of the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> by their position This class <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> have too, iterators with random access, which permit increment and decrement any value to the iterators.  
 <a href="a00015.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00110_source.html">cntree_map.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad209b6cd561d7bae16e18dd036a6ebfe"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00023.html">config_fastmutex</a>&lt; cnc &gt;<br class="typebreak"/>
::fastmutex_data&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ad209b6cd561d7bae16e18dd036a6ebfe">mtx_data</a></td></tr>
<tr class="separator:ad209b6cd561d7bae16e18dd036a6ebfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70be7a2259964708a7bc00798fcf62ba"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00051.html">mutex_read</a>&lt; <a class="el" href="a00015.html#ad209b6cd561d7bae16e18dd036a6ebfe">mtx_data</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a70be7a2259964708a7bc00798fcf62ba">mtx_read</a></td></tr>
<tr class="separator:a70be7a2259964708a7bc00798fcf62ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2c3e763a91b97e522dd5b9be2da203"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00053.html">mutex_write</a>&lt; <a class="el" href="a00015.html#ad209b6cd561d7bae16e18dd036a6ebfe">mtx_data</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a7b2c3e763a91b97e522dd5b9be2da203">mtx_write</a></td></tr>
<tr class="separator:a7b2c3e763a91b97e522dd5b9be2da203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb91887d36faf70731a2a84fb6d63a4"><td class="memItemLeft" align="right" valign="top">typedef key_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a></td></tr>
<tr class="separator:afdb91887d36faf70731a2a84fb6d63a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc0f862dcefd392196cb0e51d0ed8e4"><td class="memItemLeft" align="right" valign="top">typedef data_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a5cc0f862dcefd392196cb0e51d0ed8e4">mapped_type</a></td></tr>
<tr class="separator:a5cc0f862dcefd392196cb0e51d0ed8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c93eb0ba9c92dcb8256f4650f1e4bd"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; const key_t, <br class="typebreak"/>
data_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a></td></tr>
<tr class="separator:a06c93eb0ba9c92dcb8256f4650f1e4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442ed442682056445874aa1992df9202"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00037.html">filter_map</a>&lt; key_t, <br class="typebreak"/>
<a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a442ed442682056445874aa1992df9202">filter_t</a></td></tr>
<tr class="separator:a442ed442682056445874aa1992df9202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000fe93c80698c64b7e1a0a253935e9f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00096.html">c_forest::sorted_tree</a><br class="typebreak"/>
&lt; <a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a>, key_t, <a class="el" href="a00015.html#a442ed442682056445874aa1992df9202">filter_t</a>, <br class="typebreak"/>
comp_key_t, alloc_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a000fe93c80698c64b7e1a0a253935e9f">srt_tree_t</a></td></tr>
<tr class="separator:a000fe93c80698c64b7e1a0a253935e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc525d440865165939b4a954441ce9e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00096.html#a4d796f7eda7fcabc120664f917121dc6">srt_tree_t::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#abcc525d440865165939b4a954441ce9e">size_type</a></td></tr>
<tr class="separator:abcc525d440865165939b4a954441ce9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690cdb7721b6f9fcd4d7859a49f1a063"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00096.html#a326fc76dfea8f0343a1e92da0e5a3c5d">srt_tree_t::difference_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a690cdb7721b6f9fcd4d7859a49f1a063">difference_type</a></td></tr>
<tr class="separator:a690cdb7721b6f9fcd4d7859a49f1a063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563d5dc39e397ddbe0f35d7d40fe46e3"><td class="memItemLeft" align="right" valign="top">typedef comp_key_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a563d5dc39e397ddbe0f35d7d40fe46e3">key_compare</a></td></tr>
<tr class="separator:a563d5dc39e397ddbe0f35d7d40fe46e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280cd3d872e8104516c54871a8ccc6cf"><td class="memItemLeft" align="right" valign="top">typedef alloc_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a280cd3d872e8104516c54871a8ccc6cf">allocator_type</a></td></tr>
<tr class="separator:a280cd3d872e8104516c54871a8ccc6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d55e3eabaadaf47dcafb60e0dc1fe4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ac5d55e3eabaadaf47dcafb60e0dc1fe4">reference</a></td></tr>
<tr class="separator:ac5d55e3eabaadaf47dcafb60e0dc1fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d254c985e2caf0dd0b1404986511c4"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#af8d254c985e2caf0dd0b1404986511c4">const_reference</a></td></tr>
<tr class="separator:af8d254c985e2caf0dd0b1404986511c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be187269c8ae0ec3328d8c5fe363e41"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a2be187269c8ae0ec3328d8c5fe363e41">pointer</a></td></tr>
<tr class="separator:a2be187269c8ae0ec3328d8c5fe363e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af149eecaf83026d75b4733f00399c205"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#af149eecaf83026d75b4733f00399c205">const_pointer</a></td></tr>
<tr class="separator:af149eecaf83026d75b4733f00399c205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79a264ab6bdb7e0ef8f8ef6da2b0016"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00020.html">comp_pair</a>&lt; key_t, <br class="typebreak"/>
data_t, comp_key_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ae79a264ab6bdb7e0ef8f8ef6da2b0016">ValueCompare</a></td></tr>
<tr class="separator:ae79a264ab6bdb7e0ef8f8ef6da2b0016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a754dde4bca34a54b2b3de20c57b20c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00037.html">filter_map</a>&lt; key_t, <br class="typebreak"/>
<a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a8a754dde4bca34a54b2b3de20c57b20c">filter</a></td></tr>
<tr class="separator:a8a754dde4bca34a54b2b3de20c57b20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae7df1494a2256a5cdcfb0fa010f26b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00096.html#a435616fae6b22fcb60996905ea17aef1">srt_tree_t::tree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a3ae7df1494a2256a5cdcfb0fa010f26b">tree</a></td></tr>
<tr class="separator:a3ae7df1494a2256a5cdcfb0fa010f26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa088e37426a562c47741b2a48db0366"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00096.html#ae2502bd7010efa55a0f7f7e0906a8aeb">srt_tree_t::node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#aaa088e37426a562c47741b2a48db0366">node_t</a></td></tr>
<tr class="separator:aaa088e37426a562c47741b2a48db0366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757ce2104645777e2d4ca845296bbeca"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00096.html#a59c7473d19fefb5f0c5208211a62093a">srt_tree_t::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a></td></tr>
<tr class="separator:a757ce2104645777e2d4ca845296bbeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d18e6aa65e1edbac5f4e5fce606be3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00096.html#a25b5bd26451460adb2ec43a8ed1815bb">srt_tree_t::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a></td></tr>
<tr class="separator:a93d18e6aa65e1edbac5f4e5fce606be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4da70f289c93e90698e4171dd14faa1"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="a00096.html#a0cf6219c86ddf7632a671098d3c02b22">srt_tree_t::reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ad4da70f289c93e90698e4171dd14faa1">reverse_iterator</a></td></tr>
<tr class="separator:ad4da70f289c93e90698e4171dd14faa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17f9740bf5572d465ce68c782858eb2"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="a00096.html#a80d2d1888631c7aa84f1740348557a8e">srt_tree_t::const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ab17f9740bf5572d465ce68c782858eb2">const_reverse_iterator</a></td></tr>
<tr class="separator:ab17f9740bf5572d465ce68c782858eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ced6d91afee8791fb0143addc93555"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; <a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#af4ced6d91afee8791fb0143addc93555">mypair</a></td></tr>
<tr class="separator:af4ced6d91afee8791fb0143addc93555"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaafd974ac06007d5506dbdf76c5c6b1f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#aaafd974ac06007d5506dbdf76c5c6b1f">cntree_map</a> (const comp_key_t &amp;C1=comp_key_t(), const alloc_t &amp;A=alloc_t())</td></tr>
<tr class="memdesc:aaafd974ac06007d5506dbdf76c5c6b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from an object Comparer and an object Allocator.  <a href="#aaafd974ac06007d5506dbdf76c5c6b1f">More...</a><br/></td></tr>
<tr class="separator:aaafd974ac06007d5506dbdf76c5c6b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8700056cb4d8f36c545dc000824a4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#afb8700056cb4d8f36c545dc000824a4d">cntree_map</a> (const alloc_t &amp;A)</td></tr>
<tr class="memdesc:afb8700056cb4d8f36c545dc000824a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from an object Allocator.  <a href="#afb8700056cb4d8f36c545dc000824a4d">More...</a><br/></td></tr>
<tr class="separator:afb8700056cb4d8f36c545dc000824a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52eb369f2fcb0fff7c673ca7c2186bc"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:ac52eb369f2fcb0fff7c673ca7c2186bc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#ac52eb369f2fcb0fff7c673ca7c2186bc">cntree_map</a> (InputIterator first, InputIterator last, const comp_key_t &amp;C1=comp_key_t(), const alloc_t &amp;A1=alloc_t())</td></tr>
<tr class="memdesc:ac52eb369f2fcb0fff7c673ca7c2186bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from a pair of iterators and an object Comparer and an object Allocator.  <a href="#ac52eb369f2fcb0fff7c673ca7c2186bc">More...</a><br/></td></tr>
<tr class="separator:ac52eb369f2fcb0fff7c673ca7c2186bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb228fd257c098cba372644e27302b4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#aeb228fd257c098cba372644e27302b4f">cntree_map</a> (const <a class="el" href="a00015.html">cntree_map</a> &amp;m)</td></tr>
<tr class="memdesc:aeb228fd257c098cba372644e27302b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#aeb228fd257c098cba372644e27302b4f">More...</a><br/></td></tr>
<tr class="separator:aeb228fd257c098cba372644e27302b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902968cd85a72e4d6bfb8e06ca98144a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a902968cd85a72e4d6bfb8e06ca98144a">cntree_map</a> (const <a class="el" href="a00015.html">cntree_map</a> &amp;m, const alloc_t &amp;A)</td></tr>
<tr class="memdesc:a902968cd85a72e4d6bfb8e06ca98144a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a902968cd85a72e4d6bfb8e06ca98144a">More...</a><br/></td></tr>
<tr class="separator:a902968cd85a72e4d6bfb8e06ca98144a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d34bc2bbd7eb73d489d48b11514c7a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a33d34bc2bbd7eb73d489d48b11514c7a">cntree_map</a> (<a class="el" href="a00015.html">cntree_map</a> &amp;&amp;m)</td></tr>
<tr class="memdesc:a33d34bc2bbd7eb73d489d48b11514c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a33d34bc2bbd7eb73d489d48b11514c7a">More...</a><br/></td></tr>
<tr class="separator:a33d34bc2bbd7eb73d489d48b11514c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509db1381c0b162454f827afa49363ff"><td class="memTemplParams" colspan="2">template&lt;typename alloc_t2 , bool cnc2&gt; </td></tr>
<tr class="memitem:a509db1381c0b162454f827afa49363ff"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#a509db1381c0b162454f827afa49363ff">cntree_map</a> (const <a class="el" href="a00015.html">cntree_map</a>&lt; key_t, data_t, cnc2, comp_key_t, alloc_t2 &gt; &amp;m)</td></tr>
<tr class="memdesc:a509db1381c0b162454f827afa49363ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a509db1381c0b162454f827afa49363ff">More...</a><br/></td></tr>
<tr class="separator:a509db1381c0b162454f827afa49363ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270b29faedf40e2b44d949e90478c9a1"><td class="memTemplParams" colspan="2">template&lt;bool cnc2&gt; </td></tr>
<tr class="memitem:a270b29faedf40e2b44d949e90478c9a1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#a270b29faedf40e2b44d949e90478c9a1">cntree_map</a> (<a class="el" href="a00015.html">cntree_map</a>&lt; key_t, data_t, cnc2, comp_key_t, alloc_t &gt; &amp;&amp;m)</td></tr>
<tr class="memdesc:a270b29faedf40e2b44d949e90478c9a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a270b29faedf40e2b44d949e90478c9a1">More...</a><br/></td></tr>
<tr class="separator:a270b29faedf40e2b44d949e90478c9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1becdaa27a5d7f3be8b9958fbd4986a3"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a1becdaa27a5d7f3be8b9958fbd4986a3">~cntree_map</a> ()</td></tr>
<tr class="memdesc:a1becdaa27a5d7f3be8b9958fbd4986a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a1becdaa27a5d7f3be8b9958fbd4986a3">More...</a><br/></td></tr>
<tr class="separator:a1becdaa27a5d7f3be8b9958fbd4986a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdb4dab16861062b01008339b82b12f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html">cntree_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a9bdb4dab16861062b01008339b82b12f">operator=</a> (const <a class="el" href="a00015.html">cntree_map</a> &amp;m)</td></tr>
<tr class="memdesc:a9bdb4dab16861062b01008339b82b12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asignation operator.  <a href="#a9bdb4dab16861062b01008339b82b12f">More...</a><br/></td></tr>
<tr class="separator:a9bdb4dab16861062b01008339b82b12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae981c188dc4e0cf6b52069991994308a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html">cntree_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ae981c188dc4e0cf6b52069991994308a">operator=</a> (<a class="el" href="a00015.html">cntree_map</a> &amp;&amp;m)</td></tr>
<tr class="memdesc:ae981c188dc4e0cf6b52069991994308a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asignation operator.  <a href="#ae981c188dc4e0cf6b52069991994308a">More...</a><br/></td></tr>
<tr class="separator:ae981c188dc4e0cf6b52069991994308a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c812ce7e9077735e311f0b945800e7"><td class="memTemplParams" colspan="2">template&lt;typename alloc_t2 , bool cnc2&gt; </td></tr>
<tr class="memitem:a75c812ce7e9077735e311f0b945800e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00015.html">cntree_map</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#a75c812ce7e9077735e311f0b945800e7">operator=</a> (const <a class="el" href="a00015.html">cntree_map</a>&lt; key_t, data_t, cnc2, comp_key_t, alloc_t2 &gt; &amp;m)</td></tr>
<tr class="memdesc:a75c812ce7e9077735e311f0b945800e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asignation operator.  <a href="#a75c812ce7e9077735e311f0b945800e7">More...</a><br/></td></tr>
<tr class="separator:a75c812ce7e9077735e311f0b945800e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf81297c37387042d017f14fe4751920"><td class="memTemplParams" colspan="2">template&lt;bool cnc2&gt; </td></tr>
<tr class="memitem:acf81297c37387042d017f14fe4751920"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00015.html">cntree_map</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#acf81297c37387042d017f14fe4751920">operator=</a> (<a class="el" href="a00015.html">cntree_map</a>&lt; key_t, data_t, cnc2, comp_key_t, alloc_t &gt; &amp;&amp;m)</td></tr>
<tr class="memdesc:acf81297c37387042d017f14fe4751920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asignation operator.  <a href="#acf81297c37387042d017f14fe4751920">More...</a><br/></td></tr>
<tr class="separator:acf81297c37387042d017f14fe4751920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53dafa34186a341c7909b2e739671a29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a53dafa34186a341c7909b2e739671a29">swap</a> (<a class="el" href="a00015.html">cntree_map</a> &amp;mp)</td></tr>
<tr class="memdesc:a53dafa34186a341c7909b2e739671a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap the data of the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> st with the actual <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a>  <a href="#a53dafa34186a341c7909b2e739671a29">More...</a><br/></td></tr>
<tr class="separator:a53dafa34186a341c7909b2e739671a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335a0e746af8564242d13d0864d25d62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a335a0e746af8564242d13d0864d25d62">clear</a> (void)</td></tr>
<tr class="memdesc:a335a0e746af8564242d13d0864d25d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all the elements of the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a>.  <a href="#a335a0e746af8564242d13d0864d25d62">More...</a><br/></td></tr>
<tr class="separator:a335a0e746af8564242d13d0864d25d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d80e9192134ee0d28f40239ca88d27a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a7d80e9192134ee0d28f40239ca88d27a">empty</a> (void) const </td></tr>
<tr class="memdesc:a7d80e9192134ee0d28f40239ca88d27a"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicate if the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> is empty  <a href="#a7d80e9192134ee0d28f40239ca88d27a">More...</a><br/></td></tr>
<tr class="separator:a7d80e9192134ee0d28f40239ca88d27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fdbf972c57464124c142ffa35fd5b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#abcc525d440865165939b4a954441ce9e">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ad9fdbf972c57464124c142ffa35fd5b0">size</a> (void) const </td></tr>
<tr class="memdesc:ad9fdbf972c57464124c142ffa35fd5b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of elements in the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a>  <a href="#ad9fdbf972c57464124c142ffa35fd5b0">More...</a><br/></td></tr>
<tr class="separator:ad9fdbf972c57464124c142ffa35fd5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c6cabcae2730b9bac241acd75a8676"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#abcc525d440865165939b4a954441ce9e">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#af8c6cabcae2730b9bac241acd75a8676">max_size</a> (void) const </td></tr>
<tr class="memdesc:af8c6cabcae2730b9bac241acd75a8676"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the maximun size of the container  <a href="#af8c6cabcae2730b9bac241acd75a8676">More...</a><br/></td></tr>
<tr class="separator:af8c6cabcae2730b9bac241acd75a8676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12baa13bb74657c45c2d3145598b674"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ac12baa13bb74657c45c2d3145598b674">pos</a> (signed_type Pos1) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ac12baa13bb74657c45c2d3145598b674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to an element by their position in the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a>.  <a href="#ac12baa13bb74657c45c2d3145598b674">More...</a><br/></td></tr>
<tr class="separator:ac12baa13bb74657c45c2d3145598b674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a34786bd25166b1b5487f0a08073ece"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a8a34786bd25166b1b5487f0a08073ece">pos</a> (signed_type Pos1) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a8a34786bd25166b1b5487f0a08073ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to an element by their position in the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a>.  <a href="#a8a34786bd25166b1b5487f0a08073ece">More...</a><br/></td></tr>
<tr class="separator:a8a34786bd25166b1b5487f0a08073ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab801ec21e1e8d8629e31bc410b471cc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ab801ec21e1e8d8629e31bc410b471cc7">iterator_pos</a> (signed_type Pos1) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ab801ec21e1e8d8629e31bc410b471cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a position in the sorted_tree.  <a href="#ab801ec21e1e8d8629e31bc410b471cc7">More...</a><br/></td></tr>
<tr class="separator:ab801ec21e1e8d8629e31bc410b471cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30456c29e4f711df3c960308b0c1901"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ac30456c29e4f711df3c960308b0c1901">const_iterator_pos</a> (signed_type Pos1) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ac30456c29e4f711df3c960308b0c1901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a position in the sorted_tree.  <a href="#ac30456c29e4f711df3c960308b0c1901">More...</a><br/></td></tr>
<tr class="separator:ac30456c29e4f711df3c960308b0c1901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7abecb0988185399dc432d668b0a42a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ae7abecb0988185399dc432d668b0a42a">front</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ae7abecb0988185399dc432d668b0a42a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const_reference to the first element.  <a href="#ae7abecb0988185399dc432d668b0a42a">More...</a><br/></td></tr>
<tr class="separator:ae7abecb0988185399dc432d668b0a42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f3d7fe8fadc90b3f6c06f565a27913"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a75f3d7fe8fadc90b3f6c06f565a27913">front</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a75f3d7fe8fadc90b3f6c06f565a27913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const_reference to the first element.  <a href="#a75f3d7fe8fadc90b3f6c06f565a27913">More...</a><br/></td></tr>
<tr class="separator:a75f3d7fe8fadc90b3f6c06f565a27913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178745243f5943bfe3d20bbc28407d49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a178745243f5943bfe3d20bbc28407d49">back</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a178745243f5943bfe3d20bbc28407d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const_reference to the last element.  <a href="#a178745243f5943bfe3d20bbc28407d49">More...</a><br/></td></tr>
<tr class="separator:a178745243f5943bfe3d20bbc28407d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68deeed62aedb09059e8a09907a3c66"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ab68deeed62aedb09059e8a09907a3c66">back</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ab68deeed62aedb09059e8a09907a3c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const_reference to the last element.  <a href="#ab68deeed62aedb09059e8a09907a3c66">More...</a><br/></td></tr>
<tr class="separator:ab68deeed62aedb09059e8a09907a3c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e81c5315f8c470c1c98fba9c0995a1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a9e81c5315f8c470c1c98fba9c0995a1e">find</a> (const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;x)</td></tr>
<tr class="memdesc:a9e81c5315f8c470c1c98fba9c0995a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the iterator to the element with the key x  <a href="#a9e81c5315f8c470c1c98fba9c0995a1e">More...</a><br/></td></tr>
<tr class="separator:a9e81c5315f8c470c1c98fba9c0995a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778c5a7d9b4533f36b41d7028859cf65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a778c5a7d9b4533f36b41d7028859cf65">find</a> (const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;x) const </td></tr>
<tr class="memdesc:a778c5a7d9b4533f36b41d7028859cf65"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the const_iterator to the element with the key x  <a href="#a778c5a7d9b4533f36b41d7028859cf65">More...</a><br/></td></tr>
<tr class="separator:a778c5a7d9b4533f36b41d7028859cf65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2bc5630d9142ba60159186b31aaf317"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ab2bc5630d9142ba60159186b31aaf317">read</a> (<a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;V, const key_t &amp;K) const </td></tr>
<tr class="memdesc:ab2bc5630d9142ba60159186b31aaf317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an copy of the object in the tree. If exist return true. If don't exist return false <br/>
 This function supouse there is only one element with the key.  <a href="#ab2bc5630d9142ba60159186b31aaf317">More...</a><br/></td></tr>
<tr class="separator:ab2bc5630d9142ba60159186b31aaf317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5568688eb94bab7c39dc2b209bd6967"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#abcc525d440865165939b4a954441ce9e">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ad5568688eb94bab7c39dc2b209bd6967">count</a> (const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;x) const </td></tr>
<tr class="memdesc:ad5568688eb94bab7c39dc2b209bd6967"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of elements in the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> with the key x  <a href="#ad5568688eb94bab7c39dc2b209bd6967">More...</a><br/></td></tr>
<tr class="separator:ad5568688eb94bab7c39dc2b209bd6967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d84873d95325074b0bed657394d31b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ab9d84873d95325074b0bed657394d31b">lower_bound</a> (const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;x)</td></tr>
<tr class="memdesc:ab9d84873d95325074b0bed657394d31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return one iterator to the first appearance of the key x if exist and if don't exist return one iterator to the first element greather than x  <a href="#ab9d84873d95325074b0bed657394d31b">More...</a><br/></td></tr>
<tr class="separator:ab9d84873d95325074b0bed657394d31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1027150a6e92cb893b1fa0f60204b864"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a1027150a6e92cb893b1fa0f60204b864">lower_bound</a> (const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;x) const </td></tr>
<tr class="memdesc:a1027150a6e92cb893b1fa0f60204b864"><td class="mdescLeft">&#160;</td><td class="mdescRight">return one const_iterator to the first appearance of the key x if exist <br/>
 and if don't exist return one iterator to the first element greather than x  <a href="#a1027150a6e92cb893b1fa0f60204b864">More...</a><br/></td></tr>
<tr class="separator:a1027150a6e92cb893b1fa0f60204b864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e46957435029cccf8de1e762f09976"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a54e46957435029cccf8de1e762f09976">upper_bound</a> (const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;x)</td></tr>
<tr class="memdesc:a54e46957435029cccf8de1e762f09976"><td class="mdescLeft">&#160;</td><td class="mdescRight">return one iterator to the first element greather than x. If don't exist any element greather than x , return <a class="el" href="a00015.html#a964f1bdc3ea05d048e4f638eabc9064b">end()</a>  <a href="#a54e46957435029cccf8de1e762f09976">More...</a><br/></td></tr>
<tr class="separator:a54e46957435029cccf8de1e762f09976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86dd570c71566782d70f6b4ac1b557c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#af86dd570c71566782d70f6b4ac1b557c">upper_bound</a> (const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;x) const </td></tr>
<tr class="memdesc:af86dd570c71566782d70f6b4ac1b557c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return one const_iterator to the first element greather than x. If don't exist any element greather than x , return <a class="el" href="a00015.html#a964f1bdc3ea05d048e4f638eabc9064b">end()</a>  <a href="#af86dd570c71566782d70f6b4ac1b557c">More...</a><br/></td></tr>
<tr class="separator:af86dd570c71566782d70f6b4ac1b557c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e95bd7fce26f461ed606bf3e65605f6"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a>, <a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a5e95bd7fce26f461ed606bf3e65605f6">equal_range</a> (const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;x)</td></tr>
<tr class="memdesc:a5e95bd7fce26f461ed606bf3e65605f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a pair of iterators, the first is the lower_bound (x) and the second is upper_bound (x)  <a href="#a5e95bd7fce26f461ed606bf3e65605f6">More...</a><br/></td></tr>
<tr class="separator:a5e95bd7fce26f461ed606bf3e65605f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83eab5600bd0f47a84c4e4001e062d53"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>, <br class="typebreak"/>
<a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a83eab5600bd0f47a84c4e4001e062d53">equal_range</a> (const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;x) const </td></tr>
<tr class="memdesc:a83eab5600bd0f47a84c4e4001e062d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a pair of const_iterators, the first is the lower_bound(x) and the second is upper_bound (x)  <a href="#a83eab5600bd0f47a84c4e4001e062d53">More...</a><br/></td></tr>
<tr class="separator:a83eab5600bd0f47a84c4e4001e062d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aef29f2de1ce6401963d8e4cbd94371"><td class="memItemLeft" align="right" valign="top">data_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a0aef29f2de1ce6401963d8e4cbd94371">operator[]</a> (const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;K)</td></tr>
<tr class="memdesc:a0aef29f2de1ce6401963d8e4cbd94371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Data with the key K, if don't exist , inserts a new pair (key, Data) with that key and returns a reference to this pair.  <a href="#a0aef29f2de1ce6401963d8e4cbd94371">More...</a><br/></td></tr>
<tr class="separator:a0aef29f2de1ce6401963d8e4cbd94371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8892f38f7bc51fab39aad597808afc4e"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a8892f38f7bc51fab39aad597808afc4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00015.html#af4ced6d91afee8791fb0143addc93555">mypair</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#a8892f38f7bc51fab39aad597808afc4e">insert</a> (P &amp;&amp;val)</td></tr>
<tr class="memdesc:a8892f38f7bc51fab39aad597808afc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a value in the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a>. Can ve a value, a reference or an rvalue  <a href="#a8892f38f7bc51fab39aad597808afc4e">More...</a><br/></td></tr>
<tr class="separator:a8892f38f7bc51fab39aad597808afc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a4062d2c29555a169460156ac58b53"><td class="memTemplParams" colspan="2">template&lt;class P , class Function &gt; </td></tr>
<tr class="memitem:af7a4062d2c29555a169460156ac58b53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00015.html#af4ced6d91afee8791fb0143addc93555">mypair</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#af7a4062d2c29555a169460156ac58b53">insert_if</a> (Function &amp;&amp;M, P &amp;&amp;val)</td></tr>
<tr class="memdesc:af7a4062d2c29555a169460156ac58b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a value in the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a>. Can ve a value, a reference or an rvalue  <a href="#af7a4062d2c29555a169460156ac58b53">More...</a><br/></td></tr>
<tr class="separator:af7a4062d2c29555a169460156ac58b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3145245e3b9dab5a749ce8f57dd801d1"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a3145245e3b9dab5a749ce8f57dd801d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#a3145245e3b9dab5a749ce8f57dd801d1">insert</a> (<a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>, P &amp;&amp;val)</td></tr>
<tr class="memdesc:a3145245e3b9dab5a749ce8f57dd801d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a value in the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a>. Can ve a value, a reference or an rvalue  <a href="#a3145245e3b9dab5a749ce8f57dd801d1">More...</a><br/></td></tr>
<tr class="separator:a3145245e3b9dab5a749ce8f57dd801d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8079adf4f5052909a6d7b1c88b0d62"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:afa8079adf4f5052909a6d7b1c88b0d62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00015.html#af4ced6d91afee8791fb0143addc93555">mypair</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#afa8079adf4f5052909a6d7b1c88b0d62">emplace</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:afa8079adf4f5052909a6d7b1c88b0d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a value in the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a>  <a href="#afa8079adf4f5052909a6d7b1c88b0d62">More...</a><br/></td></tr>
<tr class="separator:afa8079adf4f5052909a6d7b1c88b0d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba1276d5b2e958e167c167cad48ee4e"><td class="memTemplParams" colspan="2">template&lt;class Function , class... Args&gt; </td></tr>
<tr class="memitem:a1ba1276d5b2e958e167c167cad48ee4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00015.html#af4ced6d91afee8791fb0143addc93555">mypair</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#a1ba1276d5b2e958e167c167cad48ee4e">emplace_if</a> (Function &amp;&amp;M, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a1ba1276d5b2e958e167c167cad48ee4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a value in the set  <a href="#a1ba1276d5b2e958e167c167cad48ee4e">More...</a><br/></td></tr>
<tr class="separator:a1ba1276d5b2e958e167c167cad48ee4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1012b6d8c66dc69bb1455ddf2b23e7d"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ad1012b6d8c66dc69bb1455ddf2b23e7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#ad1012b6d8c66dc69bb1455ddf2b23e7d">emplace_hint</a> (<a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ad1012b6d8c66dc69bb1455ddf2b23e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a value in the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a>  <a href="#ad1012b6d8c66dc69bb1455ddf2b23e7d">More...</a><br/></td></tr>
<tr class="separator:ad1012b6d8c66dc69bb1455ddf2b23e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc54310b8bfa39db29d4299950b79a9"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a4dc54310b8bfa39db29d4299950b79a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#a4dc54310b8bfa39db29d4299950b79a9">insert</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a4dc54310b8bfa39db29d4299950b79a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion of range of elements from two iterators.  <a href="#a4dc54310b8bfa39db29d4299950b79a9">More...</a><br/></td></tr>
<tr class="separator:a4dc54310b8bfa39db29d4299950b79a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbda8ff5264e7232c454b5e978a6e99"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Function &gt; </td></tr>
<tr class="memitem:a5fbda8ff5264e7232c454b5e978a6e99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#a5fbda8ff5264e7232c454b5e978a6e99">insert_if</a> (InputIterator first, InputIterator last, Function &amp;&amp;M)</td></tr>
<tr class="memdesc:a5fbda8ff5264e7232c454b5e978a6e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion of range of elements from two iterators.  <a href="#a5fbda8ff5264e7232c454b5e978a6e99">More...</a><br/></td></tr>
<tr class="separator:a5fbda8ff5264e7232c454b5e978a6e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eec2682acfa06b346089c5b52b7dbd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a0eec2682acfa06b346089c5b52b7dbd8">pop_front</a> (void)</td></tr>
<tr class="memdesc:a0eec2682acfa06b346089c5b52b7dbd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the container  <a href="#a0eec2682acfa06b346089c5b52b7dbd8">More...</a><br/></td></tr>
<tr class="separator:a0eec2682acfa06b346089c5b52b7dbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eeef753d23113fd0c40b1928bfd3c24"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a5eeef753d23113fd0c40b1928bfd3c24"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#a5eeef753d23113fd0c40b1928bfd3c24">pop_front_if</a> (Function &amp;&amp;M1)</td></tr>
<tr class="memdesc:a5eeef753d23113fd0c40b1928bfd3c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the container  <a href="#a5eeef753d23113fd0c40b1928bfd3c24">More...</a><br/></td></tr>
<tr class="separator:a5eeef753d23113fd0c40b1928bfd3c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071fecb96c4f2e185b87ce0de3a0f280"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a071fecb96c4f2e185b87ce0de3a0f280">pop_copy_front</a> (<a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;V)</td></tr>
<tr class="memdesc:a071fecb96c4f2e185b87ce0de3a0f280"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the tree and return a copy  <a href="#a071fecb96c4f2e185b87ce0de3a0f280">More...</a><br/></td></tr>
<tr class="separator:a071fecb96c4f2e185b87ce0de3a0f280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885c19f2d3b576dc0244f70bfc05f214"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a885c19f2d3b576dc0244f70bfc05f214"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#a885c19f2d3b576dc0244f70bfc05f214">pop_copy_front_if</a> (<a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;V, Function &amp;&amp;M1)</td></tr>
<tr class="memdesc:a885c19f2d3b576dc0244f70bfc05f214"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the tree and return a copy  <a href="#a885c19f2d3b576dc0244f70bfc05f214">More...</a><br/></td></tr>
<tr class="separator:a885c19f2d3b576dc0244f70bfc05f214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629dae6c57f6ef4bdc692f0915c03af6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a629dae6c57f6ef4bdc692f0915c03af6">pop_move_front</a> (<a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;V)</td></tr>
<tr class="memdesc:a629dae6c57f6ef4bdc692f0915c03af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the tree and return a copy with rvalues  <a href="#a629dae6c57f6ef4bdc692f0915c03af6">More...</a><br/></td></tr>
<tr class="separator:a629dae6c57f6ef4bdc692f0915c03af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad724526ff3eec6ef2a69694c721c8e77"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:ad724526ff3eec6ef2a69694c721c8e77"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#ad724526ff3eec6ef2a69694c721c8e77">pop_move_front_if</a> (<a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;V, Function &amp;&amp;M1)</td></tr>
<tr class="memdesc:ad724526ff3eec6ef2a69694c721c8e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the tree and return a copy with rvalues  <a href="#ad724526ff3eec6ef2a69694c721c8e77">More...</a><br/></td></tr>
<tr class="separator:ad724526ff3eec6ef2a69694c721c8e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8945acf3d01b2f02d36ca9ebd7cdce08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a8945acf3d01b2f02d36ca9ebd7cdce08">pop_back</a> (void)</td></tr>
<tr class="memdesc:a8945acf3d01b2f02d36ca9ebd7cdce08"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the container  <a href="#a8945acf3d01b2f02d36ca9ebd7cdce08">More...</a><br/></td></tr>
<tr class="separator:a8945acf3d01b2f02d36ca9ebd7cdce08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3a78915e75ceb93d0763202fe4046e"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:afa3a78915e75ceb93d0763202fe4046e"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#afa3a78915e75ceb93d0763202fe4046e">pop_back_if</a> (Function &amp;&amp;M1)</td></tr>
<tr class="memdesc:afa3a78915e75ceb93d0763202fe4046e"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the container  <a href="#afa3a78915e75ceb93d0763202fe4046e">More...</a><br/></td></tr>
<tr class="separator:afa3a78915e75ceb93d0763202fe4046e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01cfbb8e078cfe0bedde199c2f19e843"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a01cfbb8e078cfe0bedde199c2f19e843">pop_copy_back</a> (<a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;V)</td></tr>
<tr class="memdesc:a01cfbb8e078cfe0bedde199c2f19e843"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the tree and return a copy  <a href="#a01cfbb8e078cfe0bedde199c2f19e843">More...</a><br/></td></tr>
<tr class="separator:a01cfbb8e078cfe0bedde199c2f19e843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29de113db20337a2bde538425817262f"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a29de113db20337a2bde538425817262f"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#a29de113db20337a2bde538425817262f">pop_copy_back_if</a> (<a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;V, Function &amp;&amp;M1)</td></tr>
<tr class="memdesc:a29de113db20337a2bde538425817262f"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the tree and return a copy  <a href="#a29de113db20337a2bde538425817262f">More...</a><br/></td></tr>
<tr class="separator:a29de113db20337a2bde538425817262f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02776ab054982f8c134cc21d6123e8e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#aa02776ab054982f8c134cc21d6123e8e">pop_move_back</a> (<a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;V)</td></tr>
<tr class="memdesc:aa02776ab054982f8c134cc21d6123e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the tree and return a copy with rvalues  <a href="#aa02776ab054982f8c134cc21d6123e8e">More...</a><br/></td></tr>
<tr class="separator:aa02776ab054982f8c134cc21d6123e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01ea23fff8ac77e89accd66f91ad564"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:aa01ea23fff8ac77e89accd66f91ad564"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#aa01ea23fff8ac77e89accd66f91ad564">pop_move_back_if</a> (<a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;V, Function &amp;&amp;M1)</td></tr>
<tr class="memdesc:aa01ea23fff8ac77e89accd66f91ad564"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the tree and return a copy with rvalues  <a href="#aa01ea23fff8ac77e89accd66f91ad564">More...</a><br/></td></tr>
<tr class="separator:aa01ea23fff8ac77e89accd66f91ad564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf79dace33a3fb114efafe246a6e3fbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#aaf79dace33a3fb114efafe246a6e3fbe">erase</a> (<a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a> iter)</td></tr>
<tr class="memdesc:aaf79dace33a3fb114efafe246a6e3fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element pointed by iter  <a href="#aaf79dace33a3fb114efafe246a6e3fbe">More...</a><br/></td></tr>
<tr class="separator:aaf79dace33a3fb114efafe246a6e3fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfdb1607e023d528800f52f74246ef3"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a7cfdb1607e023d528800f52f74246ef3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00015.html#af4ced6d91afee8791fb0143addc93555">mypair</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#a7cfdb1607e023d528800f52f74246ef3">erase_if</a> (<a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a> iter, Function &amp;&amp;M1)</td></tr>
<tr class="memdesc:a7cfdb1607e023d528800f52f74246ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element pointed by iter if the function return true  <a href="#a7cfdb1607e023d528800f52f74246ef3">More...</a><br/></td></tr>
<tr class="separator:a7cfdb1607e023d528800f52f74246ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8062a8d3da1dde67bdf5f74d9ec5e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#abcc525d440865165939b4a954441ce9e">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#aee8062a8d3da1dde67bdf5f74d9ec5e2">erase</a> (const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;x)</td></tr>
<tr class="memdesc:aee8062a8d3da1dde67bdf5f74d9ec5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all the elements with a key.  <a href="#aee8062a8d3da1dde67bdf5f74d9ec5e2">More...</a><br/></td></tr>
<tr class="separator:aee8062a8d3da1dde67bdf5f74d9ec5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e222c59f6bf3ee28b711cc0bad3360d"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a1e222c59f6bf3ee28b711cc0bad3360d"><td class="memTemplItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#a1e222c59f6bf3ee28b711cc0bad3360d">erase_if</a> (const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;x, Function &amp;&amp;M1)</td></tr>
<tr class="memdesc:a1e222c59f6bf3ee28b711cc0bad3360d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all the elements with a key.  <a href="#a1e222c59f6bf3ee28b711cc0bad3360d">More...</a><br/></td></tr>
<tr class="separator:a1e222c59f6bf3ee28b711cc0bad3360d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41bd35e2f4f0125f061fa133c862d9ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a41bd35e2f4f0125f061fa133c862d9ca">erase</a> (<a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a> first, <a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a> last)</td></tr>
<tr class="memdesc:a41bd35e2f4f0125f061fa133c862d9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase a range of elements in the range first, last  <a href="#a41bd35e2f4f0125f061fa133c862d9ca">More...</a><br/></td></tr>
<tr class="separator:a41bd35e2f4f0125f061fa133c862d9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c37156407fb00b5cae8f553b55a625b"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a7c37156407fb00b5cae8f553b55a625b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#a7c37156407fb00b5cae8f553b55a625b">erase_if</a> (<a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a> first, <a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a> last, Function &amp;&amp;M1)</td></tr>
<tr class="memdesc:a7c37156407fb00b5cae8f553b55a625b"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase a range of elements in the range first, last  <a href="#a7c37156407fb00b5cae8f553b55a625b">More...</a><br/></td></tr>
<tr class="separator:a7c37156407fb00b5cae8f553b55a625b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364a2e24105c3716441e96db7d2562af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a364a2e24105c3716441e96db7d2562af">erase_pos</a> (signed_type Pos)</td></tr>
<tr class="memdesc:a364a2e24105c3716441e96db7d2562af"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element of the position pos  <a href="#a364a2e24105c3716441e96db7d2562af">More...</a><br/></td></tr>
<tr class="separator:a364a2e24105c3716441e96db7d2562af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae526f0865f79bcb8ec9b7ca415b543da"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:ae526f0865f79bcb8ec9b7ca415b543da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#ae526f0865f79bcb8ec9b7ca415b543da">erase_pos_if</a> (signed_type Pos, Function &amp;&amp;M)</td></tr>
<tr class="memdesc:ae526f0865f79bcb8ec9b7ca415b543da"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element of the position pos  <a href="#ae526f0865f79bcb8ec9b7ca415b543da">More...</a><br/></td></tr>
<tr class="separator:ae526f0865f79bcb8ec9b7ca415b543da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac2fbed170351ea58a63c4af6158e27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a0ac2fbed170351ea58a63c4af6158e27">erase_pos</a> (signed_type Prim, signed_type NElem)</td></tr>
<tr class="memdesc:a0ac2fbed170351ea58a63c4af6158e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase NElem elements beginning in the position Prim  <a href="#a0ac2fbed170351ea58a63c4af6158e27">More...</a><br/></td></tr>
<tr class="separator:a0ac2fbed170351ea58a63c4af6158e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7301c0bed349fcd84f2992d81257d5"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:aaa7301c0bed349fcd84f2992d81257d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#aaa7301c0bed349fcd84f2992d81257d5">erase_pos_if</a> (signed_type Prim, signed_type NElem, Function &amp;&amp;M)</td></tr>
<tr class="memdesc:aaa7301c0bed349fcd84f2992d81257d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase NElem elements beginning in the position Prim  <a href="#aaa7301c0bed349fcd84f2992d81257d5">More...</a><br/></td></tr>
<tr class="separator:aaa7301c0bed349fcd84f2992d81257d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1fcb055bc361b26e0f7a396604f331"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#acc1fcb055bc361b26e0f7a396604f331">modify</a> (<a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a> It, const data_t &amp;D)</td></tr>
<tr class="memdesc:acc1fcb055bc361b26e0f7a396604f331"><td class="mdescLeft">&#160;</td><td class="mdescRight">modify the element pointed by the iterator It  <a href="#acc1fcb055bc361b26e0f7a396604f331">More...</a><br/></td></tr>
<tr class="separator:acc1fcb055bc361b26e0f7a396604f331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4b683eb6f7bf673d39949570c8ca59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a4a4b683eb6f7bf673d39949570c8ca59">modify</a> (<a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a> It, data_t &amp;&amp;D)</td></tr>
<tr class="memdesc:a4a4b683eb6f7bf673d39949570c8ca59"><td class="mdescLeft">&#160;</td><td class="mdescRight">modify the element pointed by the iterator It  <a href="#a4a4b683eb6f7bf673d39949570c8ca59">More...</a><br/></td></tr>
<tr class="separator:a4a4b683eb6f7bf673d39949570c8ca59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6170412390c4b357e1cbddc7798d287c"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a6170412390c4b357e1cbddc7798d287c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#a6170412390c4b357e1cbddc7798d287c">modify</a> (<a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a> It, Function &amp;&amp;M)</td></tr>
<tr class="memdesc:a6170412390c4b357e1cbddc7798d287c"><td class="mdescLeft">&#160;</td><td class="mdescRight">modify the element pointed by the iterator It  <a href="#a6170412390c4b357e1cbddc7798d287c">More...</a><br/></td></tr>
<tr class="separator:a6170412390c4b357e1cbddc7798d287c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10702d3adde4de014c2f2a3cc9a78ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#aa10702d3adde4de014c2f2a3cc9a78ea">modify</a> (const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;x, const data_t &amp;val)</td></tr>
<tr class="memdesc:aa10702d3adde4de014c2f2a3cc9a78ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">modify the element with the key x  <a href="#aa10702d3adde4de014c2f2a3cc9a78ea">More...</a><br/></td></tr>
<tr class="separator:aa10702d3adde4de014c2f2a3cc9a78ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b6d81999ff60b28f0c964f76869dae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a62b6d81999ff60b28f0c964f76869dae">modify</a> (const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;x, data_t &amp;&amp;val)</td></tr>
<tr class="memdesc:a62b6d81999ff60b28f0c964f76869dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">modify the element with the key x  <a href="#a62b6d81999ff60b28f0c964f76869dae">More...</a><br/></td></tr>
<tr class="separator:a62b6d81999ff60b28f0c964f76869dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58aca5ffe83e81934092e25547137f8"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:af58aca5ffe83e81934092e25547137f8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#af58aca5ffe83e81934092e25547137f8">modify</a> (const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;x, Function &amp;&amp;M)</td></tr>
<tr class="memdesc:af58aca5ffe83e81934092e25547137f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">modify the element with the key x with the function M  <a href="#af58aca5ffe83e81934092e25547137f8">More...</a><br/></td></tr>
<tr class="separator:af58aca5ffe83e81934092e25547137f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c904582361d94e1107472ae8a0c893e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a2c904582361d94e1107472ae8a0c893e">modify_pos</a> (signed_type Pos, const data_t &amp;val)</td></tr>
<tr class="memdesc:a2c904582361d94e1107472ae8a0c893e"><td class="mdescLeft">&#160;</td><td class="mdescRight">modify the element of the position pos with the value val  <a href="#a2c904582361d94e1107472ae8a0c893e">More...</a><br/></td></tr>
<tr class="separator:a2c904582361d94e1107472ae8a0c893e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26f22d78aff6c7d8c74769767b40b87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ab26f22d78aff6c7d8c74769767b40b87">modify_pos</a> (signed_type Pos, data_t &amp;&amp;val)</td></tr>
<tr class="memdesc:ab26f22d78aff6c7d8c74769767b40b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">modify the element of the position pos with the value val  <a href="#ab26f22d78aff6c7d8c74769767b40b87">More...</a><br/></td></tr>
<tr class="separator:ab26f22d78aff6c7d8c74769767b40b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56529fd348c5c58b66b744f59293f1b8"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a56529fd348c5c58b66b744f59293f1b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#a56529fd348c5c58b66b744f59293f1b8">modify_pos</a> (signed_type Pos, Function &amp;&amp;M)</td></tr>
<tr class="memdesc:a56529fd348c5c58b66b744f59293f1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">modify the element of the position pos with the function M  <a href="#a56529fd348c5c58b66b744f59293f1b8">More...</a><br/></td></tr>
<tr class="separator:a56529fd348c5c58b66b744f59293f1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32746ce559de6cccbd114f54839125a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#af4ced6d91afee8791fb0143addc93555">mypair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#aa32746ce559de6cccbd114f54839125a">insert_or_modify</a> (const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;x, const data_t &amp;D)</td></tr>
<tr class="memdesc:aa32746ce559de6cccbd114f54839125a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the element with key x don't exist, it is inserted the pair (x,D) if the element exist, the second part is asigned to the value D.  <a href="#aa32746ce559de6cccbd114f54839125a">More...</a><br/></td></tr>
<tr class="separator:aa32746ce559de6cccbd114f54839125a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f19e2761969c0ca35c840424906f7e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#af4ced6d91afee8791fb0143addc93555">mypair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a5f19e2761969c0ca35c840424906f7e5">insert_or_modify</a> (const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;x, data_t &amp;&amp;D)</td></tr>
<tr class="memdesc:a5f19e2761969c0ca35c840424906f7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the element with key x don't exist, it is inserted the pair (x,D) if the element exist, the second part is asigned to the value D.  <a href="#a5f19e2761969c0ca35c840424906f7e5">More...</a><br/></td></tr>
<tr class="separator:a5f19e2761969c0ca35c840424906f7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847ebcffd69877205c668f245bc3db2c"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a847ebcffd69877205c668f245bc3db2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00015.html#af4ced6d91afee8791fb0143addc93555">mypair</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#a847ebcffd69877205c668f245bc3db2c">insert_or_modify</a> (const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;x, const data_t &amp;D, Function &amp;&amp;M)</td></tr>
<tr class="memdesc:a847ebcffd69877205c668f245bc3db2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the element with key x don't exist, it is inserted the pair (x,D) if the element exist, the function M is executed over the element.  <a href="#a847ebcffd69877205c668f245bc3db2c">More...</a><br/></td></tr>
<tr class="separator:a847ebcffd69877205c668f245bc3db2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e3ed553179cb04ac9d454cd70a8c3f"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:ad2e3ed553179cb04ac9d454cd70a8c3f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00015.html#af4ced6d91afee8791fb0143addc93555">mypair</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#ad2e3ed553179cb04ac9d454cd70a8c3f">insert_or_modify</a> (const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;x, data_t &amp;&amp;D, Function &amp;&amp;M)</td></tr>
<tr class="memdesc:ad2e3ed553179cb04ac9d454cd70a8c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the element with key x don't exist, it is inserted the pair (x,D) if the element exist, the function M is executed over the element.  <a href="#ad2e3ed553179cb04ac9d454cd70a8c3f">More...</a><br/></td></tr>
<tr class="separator:ad2e3ed553179cb04ac9d454cd70a8c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60c3a8fb765dab1191e1cab9d1e4406"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a563d5dc39e397ddbe0f35d7d40fe46e3">key_compare</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ad60c3a8fb765dab1191e1cab9d1e4406">key_comp</a> () const </td></tr>
<tr class="memdesc:ad60c3a8fb765dab1191e1cab9d1e4406"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the object used to compare two keys  <a href="#ad60c3a8fb765dab1191e1cab9d1e4406">More...</a><br/></td></tr>
<tr class="separator:ad60c3a8fb765dab1191e1cab9d1e4406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1946738c5b245dc68f1474bb1678ac7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#ae79a264ab6bdb7e0ef8f8ef6da2b0016">ValueCompare</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a1946738c5b245dc68f1474bb1678ac7d">value_comp</a> () const </td></tr>
<tr class="memdesc:a1946738c5b245dc68f1474bb1678ac7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the object used to compare two values  <a href="#a1946738c5b245dc68f1474bb1678ac7d">More...</a><br/></td></tr>
<tr class="separator:a1946738c5b245dc68f1474bb1678ac7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c749fcff2e69b50ccc62eca48d33462"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a280cd3d872e8104516c54871a8ccc6cf">allocator_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a5c749fcff2e69b50ccc62eca48d33462">get_allocator</a> () const </td></tr>
<tr class="memdesc:a5c749fcff2e69b50ccc62eca48d33462"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the object allocator of the set  <a href="#a5c749fcff2e69b50ccc62eca48d33462">More...</a><br/></td></tr>
<tr class="separator:a5c749fcff2e69b50ccc62eca48d33462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174fcd2b56fd5077a36e6d2316de4063"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a174fcd2b56fd5077a36e6d2316de4063">is_mine</a> (<a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a> it) const </td></tr>
<tr class="memdesc:a174fcd2b56fd5077a36e6d2316de4063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the iterator is pointing to this <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a>.  <a href="#a174fcd2b56fd5077a36e6d2316de4063">More...</a><br/></td></tr>
<tr class="separator:a174fcd2b56fd5077a36e6d2316de4063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088dc16cf3ea09d89b20744d637e1f1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a088dc16cf3ea09d89b20744d637e1f1a">is_mine</a> (<a class="el" href="a00015.html#ab17f9740bf5572d465ce68c782858eb2">const_reverse_iterator</a> it) const </td></tr>
<tr class="memdesc:a088dc16cf3ea09d89b20744d637e1f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the iterator is pointing to this <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a>.  <a href="#a088dc16cf3ea09d89b20744d637e1f1a">More...</a><br/></td></tr>
<tr class="separator:a088dc16cf3ea09d89b20744d637e1f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae118488cd0b6207b04ae16cdb7f18860"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ae118488cd0b6207b04ae16cdb7f18860">it_begin</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ae118488cd0b6207b04ae16cdb7f18860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefe3f1eb8066afab4d4dd2c0aa7fc65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#acefe3f1eb8066afab4d4dd2c0aa7fc65">begin</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:acefe3f1eb8066afab4d4dd2c0aa7fc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33a9c0421720a613e25862cdf68080d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ad33a9c0421720a613e25862cdf68080d">it_end</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ad33a9c0421720a613e25862cdf68080d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964f1bdc3ea05d048e4f638eabc9064b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a964f1bdc3ea05d048e4f638eabc9064b">end</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a964f1bdc3ea05d048e4f638eabc9064b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46390bd3bcf45c9bf6260cea0a353bc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a46390bd3bcf45c9bf6260cea0a353bc5">it_rbegin</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a46390bd3bcf45c9bf6260cea0a353bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfbe905613989911420cb50757d9229"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a0bfbe905613989911420cb50757d9229">it_rend</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a0bfbe905613989911420cb50757d9229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ad4ed385180a053a8edfd117c6a9e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ae8ad4ed385180a053a8edfd117c6a9e1">cit_begin</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ae8ad4ed385180a053a8edfd117c6a9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9894eccefa53ca08266a25845213bb88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a9894eccefa53ca08266a25845213bb88">begin</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a9894eccefa53ca08266a25845213bb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b86e6bb00fe081b7f21bc44c46b4b23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a4b86e6bb00fe081b7f21bc44c46b4b23">cbegin</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a4b86e6bb00fe081b7f21bc44c46b4b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6126f7d2298385c43ac204703624b605"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a6126f7d2298385c43ac204703624b605">cit_end</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a6126f7d2298385c43ac204703624b605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15a2a64865a32af1d574b3f7dda1178"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ac15a2a64865a32af1d574b3f7dda1178">end</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ac15a2a64865a32af1d574b3f7dda1178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb876891986bf816887f19f11f4a3d09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#abb876891986bf816887f19f11f4a3d09">cend</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:abb876891986bf816887f19f11f4a3d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6442ddf25af688b08a4c72ea030cd843"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a6442ddf25af688b08a4c72ea030cd843">cit_rbegin</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a6442ddf25af688b08a4c72ea030cd843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04832f5d13ddc7b9589b95228dfcc13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#af04832f5d13ddc7b9589b95228dfcc13">cit_rend</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:af04832f5d13ddc7b9589b95228dfcc13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3360b8bf0fd2498d7b9e55cc5f151120"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#ad4da70f289c93e90698e4171dd14faa1">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a3360b8bf0fd2498d7b9e55cc5f151120">rit_begin</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a3360b8bf0fd2498d7b9e55cc5f151120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6425364878204585187d983f0b47821"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#ad4da70f289c93e90698e4171dd14faa1">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#af6425364878204585187d983f0b47821">rit_end</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:af6425364878204585187d983f0b47821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797f09dda93dd7db3146a03618328694"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#ad4da70f289c93e90698e4171dd14faa1">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a797f09dda93dd7db3146a03618328694">rit_rbegin</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a797f09dda93dd7db3146a03618328694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b788e5992dec406ca1616cf27b1f711"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#ad4da70f289c93e90698e4171dd14faa1">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a0b788e5992dec406ca1616cf27b1f711">rbegin</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a0b788e5992dec406ca1616cf27b1f711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdfdd0620656994caa15b3a4ee8e886"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#ad4da70f289c93e90698e4171dd14faa1">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#aebdfdd0620656994caa15b3a4ee8e886">rit_rend</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aebdfdd0620656994caa15b3a4ee8e886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236ca22b974255464d8785b27ae47896"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#ad4da70f289c93e90698e4171dd14faa1">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a236ca22b974255464d8785b27ae47896">rend</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a236ca22b974255464d8785b27ae47896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5114bea9a8c13a16d635f9f9ab67ac53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#ab17f9740bf5572d465ce68c782858eb2">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a5114bea9a8c13a16d635f9f9ab67ac53">crit_begin</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a5114bea9a8c13a16d635f9f9ab67ac53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec15f65a841f9a9f8dd08a5ddee4dfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#ab17f9740bf5572d465ce68c782858eb2">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#aeec15f65a841f9a9f8dd08a5ddee4dfb">crit_end</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aeec15f65a841f9a9f8dd08a5ddee4dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1eef1ce15831b83dabd92e0f36bfa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#ab17f9740bf5572d465ce68c782858eb2">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ada1eef1ce15831b83dabd92e0f36bfa6">crit_rbegin</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ada1eef1ce15831b83dabd92e0f36bfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07b3ecf79c6a3b781efd0bfd2e37c2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#ab17f9740bf5572d465ce68c782858eb2">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#af07b3ecf79c6a3b781efd0bfd2e37c2c">rbegin</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:af07b3ecf79c6a3b781efd0bfd2e37c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac829fe4d92581e7aec257cbbf6947d6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#ab17f9740bf5572d465ce68c782858eb2">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ac829fe4d92581e7aec257cbbf6947d6a">crbegin</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ac829fe4d92581e7aec257cbbf6947d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d843d1fb52a97b7b744fe8df36e7b76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#ab17f9740bf5572d465ce68c782858eb2">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a2d843d1fb52a97b7b744fe8df36e7b76">crit_rend</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a2d843d1fb52a97b7b744fe8df36e7b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33166c96820309f250d72d4a17ce6eae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#ab17f9740bf5572d465ce68c782858eb2">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a33166c96820309f250d72d4a17ce6eae">rend</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a33166c96820309f250d72d4a17ce6eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfe72c2b20bb4899ede43a22d669179"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#ab17f9740bf5572d465ce68c782858eb2">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a0dfe72c2b20bb4899ede43a22d669179">crend</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a0dfe72c2b20bb4899ede43a22d669179"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aa95b6d569ee7930fca89273b514400c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00015.html#ad209b6cd561d7bae16e18dd036a6ebfe">mtx_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#aa95b6d569ee7930fca89273b514400c8">BD</a></td></tr>
<tr class="separator:aa95b6d569ee7930fca89273b514400c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:afed9ed36b4aa427dbf94ec6e15d9aee9"><td class="memTemplParams" colspan="2">template&lt;class key_t2 , class data_t2 , bool cnc2, class comp_key_t2 , class alloc_t2 &gt; </td></tr>
<tr class="memitem:afed9ed36b4aa427dbf94ec6e15d9aee9"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#afed9ed36b4aa427dbf94ec6e15d9aee9">cntree_map</a></td></tr>
<tr class="separator:afed9ed36b4aa427dbf94ec6e15d9aee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdff38632eb4e67520c049544acad28b"><td class="memTemplParams" colspan="2">template&lt;class key_t2 , class data_t2 , bool cnc2, class comp_key_t2 , class alloc_t2 &gt; </td></tr>
<tr class="memitem:acdff38632eb4e67520c049544acad28b"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00015.html#acdff38632eb4e67520c049544acad28b">cntree_multimap</a></td></tr>
<tr class="separator:acdff38632eb4e67520c049544acad28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt;<br/>
class countertree::cntree_map&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;</h3>

<p>This class have the same interface and functions than the class <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> defined in the Standard Template Library ( STL), plus a function at which permit to access to the elements of the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> by their position This class <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> have too, iterators with random access, which permit increment and decrement any value to the iterators. </p>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00054">54</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a280cd3d872e8104516c54871a8ccc6cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef alloc_t <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html#a280cd3d872e8104516c54871a8ccc6cf">allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00075">75</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a93d18e6aa65e1edbac5f4e5fce606be3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00096.html#a25b5bd26451460adb2ec43a8ed1815bb">srt_tree_t::const_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00088">88</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af149eecaf83026d75b4733f00399c205"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a>* <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html#af149eecaf83026d75b4733f00399c205">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00080">80</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af8d254c985e2caf0dd0b1404986511c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a>&amp; <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html#af8d254c985e2caf0dd0b1404986511c4">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00078">78</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab17f9740bf5572d465ce68c782858eb2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00096.html#a80d2d1888631c7aa84f1740348557a8e">srt_tree_t::const_reverse_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html#ab17f9740bf5572d465ce68c782858eb2">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00090">90</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a690cdb7721b6f9fcd4d7859a49f1a063"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00096.html#a326fc76dfea8f0343a1e92da0e5a3c5d">srt_tree_t::difference_type</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html#a690cdb7721b6f9fcd4d7859a49f1a063">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00073">73</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a754dde4bca34a54b2b3de20c57b20c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00037.html">filter_map</a>&lt;key_t , <a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a>&gt; <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html#a8a754dde4bca34a54b2b3de20c57b20c">filter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00083">83</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a442ed442682056445874aa1992df9202"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00037.html">filter_map</a>&lt;key_t , <a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a>&gt; <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html#a442ed442682056445874aa1992df9202">filter_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00069">69</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a757ce2104645777e2d4ca845296bbeca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00096.html#a59c7473d19fefb5f0c5208211a62093a">srt_tree_t::iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00087">87</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a563d5dc39e397ddbe0f35d7d40fe46e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef comp_key_t <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html#a563d5dc39e397ddbe0f35d7d40fe46e3">key_compare</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00074">74</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afdb91887d36faf70731a2a84fb6d63a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef key_t <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00066">66</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5cc0f862dcefd392196cb0e51d0ed8e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef data_t <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html#a5cc0f862dcefd392196cb0e51d0ed8e4">mapped_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00067">67</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad209b6cd561d7bae16e18dd036a6ebfe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00023.html">config_fastmutex</a>&lt;cnc&gt;::fastmutex_data <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html#ad209b6cd561d7bae16e18dd036a6ebfe">mtx_data</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00061">61</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a70be7a2259964708a7bc00798fcf62ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00051.html">mutex_read</a>&lt;<a class="el" href="a00015.html#ad209b6cd561d7bae16e18dd036a6ebfe">mtx_data</a>&gt; <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html#a70be7a2259964708a7bc00798fcf62ba">mtx_read</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00062">62</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7b2c3e763a91b97e522dd5b9be2da203"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00053.html">mutex_write</a>&lt;<a class="el" href="a00015.html#ad209b6cd561d7bae16e18dd036a6ebfe">mtx_data</a>&gt; <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html#a7b2c3e763a91b97e522dd5b9be2da203">mtx_write</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00063">63</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af4ced6d91afee8791fb0143addc93555"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a>, bool &gt; <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html#af4ced6d91afee8791fb0143addc93555">mypair</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00091">91</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaa088e37426a562c47741b2a48db0366"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00096.html#ae2502bd7010efa55a0f7f7e0906a8aeb">srt_tree_t::node_t</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html#aaa088e37426a562c47741b2a48db0366">node_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00086">86</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2be187269c8ae0ec3328d8c5fe363e41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a>* <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html#a2be187269c8ae0ec3328d8c5fe363e41">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00079">79</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac5d55e3eabaadaf47dcafb60e0dc1fe4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a>&amp; <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html#ac5d55e3eabaadaf47dcafb60e0dc1fe4">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00077">77</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad4da70f289c93e90698e4171dd14faa1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00096.html#a0cf6219c86ddf7632a671098d3c02b22">srt_tree_t::reverse_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html#ad4da70f289c93e90698e4171dd14faa1">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00089">89</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abcc525d440865165939b4a954441ce9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00096.html#a4d796f7eda7fcabc120664f917121dc6">srt_tree_t::size_type</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html#abcc525d440865165939b4a954441ce9e">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00072">72</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a000fe93c80698c64b7e1a0a253935e9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00096.html">c_forest::sorted_tree</a>&lt;<a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a>,key_t,<a class="el" href="a00015.html#a442ed442682056445874aa1992df9202">filter_t</a>,comp_key_t,alloc_t&gt; <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html#a000fe93c80698c64b7e1a0a253935e9f">srt_tree_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00070">70</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3ae7df1494a2256a5cdcfb0fa010f26b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00096.html#a435616fae6b22fcb60996905ea17aef1">srt_tree_t::tree</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html#a3ae7df1494a2256a5cdcfb0fa010f26b">tree</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00085">85</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a06c93eb0ba9c92dcb8256f4650f1e4bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;const key_t,data_t &gt; <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00068">68</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae79a264ab6bdb7e0ef8f8ef6da2b0016"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00020.html">comp_pair</a>&lt;key_t,data_t,comp_key_t&gt; <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html#ae79a264ab6bdb7e0ef8f8ef6da2b0016">ValueCompare</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00082">82</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aaafd974ac06007d5506dbdf76c5c6b1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html">cntree_map</a> </td>
          <td>(</td>
          <td class="paramtype">const comp_key_t &amp;&#160;</td>
          <td class="paramname"><em>C1</em> = <code>comp_key_t()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const alloc_t &amp;&#160;</td>
          <td class="paramname"><em>A</em> = <code>alloc_t()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from an object Comparer and an object Allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C1</td><td>: Comparer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A1</td><td>: Allocator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00157">157</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afb8700056cb4d8f36c545dc000824a4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html">cntree_map</a> </td>
          <td>(</td>
          <td class="paramtype">const alloc_t &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from an object Allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A1</td><td>: Allocator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00165">165</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac52eb369f2fcb0fff7c673ca7c2186bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html">cntree_map</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const comp_key_t &amp;&#160;</td>
          <td class="paramname"><em>C1</em> = <code>comp_key_t()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const alloc_t &amp;&#160;</td>
          <td class="paramname"><em>A1</em> = <code>alloc_t()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from a pair of iterators and an object Comparer and an object Allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>: iterator to the first element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>: iterator to the last element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C1</td><td>: Comparer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A1</td><td>: Allocator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00177">177</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeb228fd257c098cba372644e27302b4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html">cntree_map</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00015.html">cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>:<a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00191">191</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a902968cd85a72e4d6bfb8e06ca98144a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html">cntree_map</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00015.html">cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const alloc_t &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>:<a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> from where copy the data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>: Allocator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00203">203</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a33d34bc2bbd7eb73d489d48b11514c7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html">cntree_map</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00015.html">cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>:<a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00214">214</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a509db1381c0b162454f827afa49363ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename alloc_t2 , bool cnc2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html">cntree_map</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00015.html">cntree_map</a>&lt; key_t, data_t, cnc2, comp_key_t, alloc_t2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>:<a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00227">227</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a270b29faedf40e2b44d949e90478c9a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;bool cnc2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00015.html">cntree_map</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00015.html">cntree_map</a>&lt; key_t, data_t, cnc2, comp_key_t, alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>:<a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00241">241</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1becdaa27a5d7f3be8b9958fbd4986a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::~<a class="el" href="a00015.html">cntree_map</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="a00110_source.html#l00254">254</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a178745243f5943bfe3d20bbc28407d49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a>&amp; <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const_reference to the last element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the last element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00511">511</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab68deeed62aedb09059e8a09907a3c66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a>&amp; <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const_reference to the last element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the last element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00522">522</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acefe3f1eb8066afab4d4dd2c0aa7fc65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01838">1838</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9894eccefa53ca08266a25845213bb88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01901">1901</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4b86e6bb00fe081b7f21bc44c46b4b23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01909">1909</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abb876891986bf816887f19f11f4a3d09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::cend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01933">1933</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae8ad4ed385180a053a8edfd117c6a9e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::cit_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01893">1893</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6126f7d2298385c43ac204703624b605"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::cit_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01917">1917</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6442ddf25af688b08a4c72ea030cd843"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::cit_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01941">1941</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af04832f5d13ddc7b9589b95228dfcc13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::cit_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01949">1949</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a335a0e746af8564242d13d0864d25d62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete all the elements of the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00356">356</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac30456c29e4f711df3c960308b0c1901"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::const_iterator_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos1</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a position in the sorted_tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the position. If don't exists throws an exception </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log N) </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00478">478</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad5568688eb94bab7c39dc2b209bd6967"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#abcc525d440865165939b4a954441ce9e">size_type</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the number of elements in the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> with the key x </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements in the set with the key x </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is log (N) </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00596">596</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac829fe4d92581e7aec257cbbf6947d6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#ab17f9740bf5572d465ce68c782858eb2">const_reverse_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::crbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l02065">2065</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0dfe72c2b20bb4899ede43a22d669179"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#ab17f9740bf5572d465ce68c782858eb2">const_reverse_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::crend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l02089">2089</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5114bea9a8c13a16d635f9f9ab67ac53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#ab17f9740bf5572d465ce68c782858eb2">const_reverse_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::crit_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l02033">2033</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeec15f65a841f9a9f8dd08a5ddee4dfb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#ab17f9740bf5572d465ce68c782858eb2">const_reverse_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::crit_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l02041">2041</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ada1eef1ce15831b83dabd92e0f36bfa6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#ab17f9740bf5572d465ce68c782858eb2">const_reverse_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::crit_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l02049">2049</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d843d1fb52a97b7b744fe8df36e7b76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#ab17f9740bf5572d465ce68c782858eb2">const_reverse_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::crit_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l02073">2073</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afa8079adf4f5052909a6d7b1c88b0d62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#af4ced6d91afee8791fb0143addc93555">mypair</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a value in the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>: argument for to compose the element to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of elements, the first is one iterator to the element inserted <br/>
 and the second is a boolean which indcate if the iterator is <a class="el" href="a00015.html#a964f1bdc3ea05d048e4f638eabc9064b">end()</a> </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00803">803</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad1012b6d8c66dc69bb1455ddf2b23e7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::emplace_hint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a value in the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>: argument for to compose the element to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of elements, the first is one iterator to the element inserted <br/>
 and the second is a boolean which indcate if the iterator is <a class="el" href="a00015.html#a964f1bdc3ea05d048e4f638eabc9064b">end()</a> </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00871">871</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1ba1276d5b2e958e167c167cad48ee4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#af4ced6d91afee8791fb0143addc93555">mypair</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::emplace_if </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a value in the set </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format (bool M (value_t &amp;)) if return true the element is iserted , if false not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>: argument for to compose the element to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair &lt;iterator,bool&gt; with the iterator to the element inserted or or to the element that prevented the insertion, and a bool indication if the insertion is done. When the element is rejected by the function , the itertor of the pair is <a class="el" href="a00015.html#a964f1bdc3ea05d048e4f638eabc9064b">end()</a> and the bool false </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00836">836</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7d80e9192134ee0d28f40239ca88d27a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>indicate if the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> is empty </p>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> is empty, false in any other case </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00376">376</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a964f1bdc3ea05d048e4f638eabc9064b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01854">1854</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac15a2a64865a32af1d574b3f7dda1178"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01925">1925</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5e95bd7fce26f461ed606bf3e65605f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a>,<a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a>&gt; <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a pair of iterators, the first is the lower_bound (x) and the second is upper_bound (x) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>:key to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of iterators </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00653">653</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a83eab5600bd0f47a84c4e4001e062d53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>,<a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>&gt; <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a pair of const_iterators, the first is the lower_bound(x) and the second is upper_bound (x) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>:key to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of const_iterators </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00664">664</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaf79dace33a3fb114efafe246a6e3fbe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element pointed by iter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>: iterator to the element to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01237">1237</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aee8062a8d3da1dde67bdf5f74d9ec5e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#abcc525d440865165939b4a954441ce9e">size_type</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase all the elements with a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key of all the elements to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements erased </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01270">1270</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a41bd35e2f4f0125f061fa133c862d9ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase a range of elements in the range first, last </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>: iterator to the first element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>: iterator to the last element of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01304">1304</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7cfdb1607e023d528800f52f74246ef3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#af4ced6d91afee8791fb0143addc93555">mypair</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element pointed by iter if the function return true </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>: iterator to the element to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M1</td><td>: function with the format ( bool M (value_t &amp;)) if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01252">1252</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1e222c59f6bf3ee28b711cc0bad3360d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::erase_if </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase all the elements with a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key of all the elements to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M1</td><td>: function with the format ( bool M (value_t &amp;)) if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements erased </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01288">1288</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7c37156407fb00b5cae8f553b55a625b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase a range of elements in the range first, last </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>: iterator to the first element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>: iterator to the last element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M1</td><td>: function with the format ( bool M (value_t &amp;)) if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01321">1321</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a364a2e24105c3716441e96db7d2562af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::erase_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element of the position pos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>: position to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01335">1335</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0ac2fbed170351ea58a63c4af6158e27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::erase_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Prim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>NElem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase NElem elements beginning in the position Prim </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Prim</td><td>: position to the first element to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NElem</td><td>: number of elements to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01377">1377</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae526f0865f79bcb8ec9b7ca415b543da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::erase_pos_if </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element of the position pos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>: position to delete </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format ( bool M (value_t &amp;)) if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true -&gt;deleted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01355">1355</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaa7301c0bed349fcd84f2992d81257d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::erase_pos_if </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Prim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>NElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase NElem elements beginning in the position Prim </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Prim</td><td>: position to the first element to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NElem</td><td>: number of elements to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format ( bool M (value_t &amp;)) if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01394">1394</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9e81c5315f8c470c1c98fba9c0995a1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the iterator to the element with the key x </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key to find in the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element with the key x. If don't exist return <a class="el" href="a00015.html#a964f1bdc3ea05d048e4f638eabc9064b">end()</a> </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00554">554</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a778c5a7d9b4533f36b41d7028859cf65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the const_iterator to the element with the key x </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key to find in the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the element with the key x. If don't exist return <a class="el" href="a00015.html#a964f1bdc3ea05d048e4f638eabc9064b">end()</a> </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00565">565</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae7abecb0988185399dc432d668b0a42a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a>&amp; <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const_reference to the first element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the first element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00489">489</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a75f3d7fe8fadc90b3f6c06f565a27913"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a>&amp; <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const_reference to the first element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the first element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00500">500</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5c749fcff2e69b50ccc62eca48d33462"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a280cd3d872e8104516c54871a8ccc6cf">allocator_type</a>&amp; <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the object allocator of the set </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>object allocator </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01759">1759</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8892f38f7bc51fab39aad597808afc4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#af4ced6d91afee8791fb0143addc93555">mypair</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a value in the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a>. Can ve a value, a reference or an rvalue </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>: value to insert. Can ve a value, a reference or an rvalue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of elements, the first is one iterator to the element inserted <br/>
 and the second is a boolean which indcate if the iterator is <a class="el" href="a00015.html#a964f1bdc3ea05d048e4f638eabc9064b">end()</a> </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00739">739</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3145245e3b9dab5a749ce8f57dd801d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a value in the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a>. Can ve a value, a reference or an rvalue </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>: value to insert. Can ve a value, a reference or an rvalue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element inserted. If it is not possible return <a class="el" href="a00015.html#a964f1bdc3ea05d048e4f638eabc9064b">end()</a> </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00790">790</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4dc54310b8bfa39db29d4299950b79a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insertion of range of elements from two iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>: Iterator to the first element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>: Iterator to the last lement of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00884">884</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af7a4062d2c29555a169460156ac58b53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class P , class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#af4ced6d91afee8791fb0143addc93555">mypair</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::insert_if </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a value in the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a>. Can ve a value, a reference or an rvalue </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format (bool M (value_t &amp;)). if return true the element is iserted , if false not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>: value to insert. Can ve a value, a reference or an rvalue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of elements, the first is one iterator to the element inserted <br/>
 and the second is a boolean which indcate if the iterator is <a class="el" href="a00015.html#a964f1bdc3ea05d048e4f638eabc9064b">end()</a> </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00765">765</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5fbda8ff5264e7232c454b5e978a6e99"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator , class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::insert_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insertion of range of elements from two iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>: Iterator to the first element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>: Iterator to the last lement of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format (bool M (value_t &amp;)) if return true the element is iserted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00900">900</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa32746ce559de6cccbd114f54839125a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#af4ced6d91afee8791fb0143addc93555">mypair</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::insert_or_modify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const data_t &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the element with key x don't exist, it is inserted the pair (x,D) if the element exist, the second part is asigned to the value D. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: data value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair &lt;iterator,bool&gt; with an iterator to the element inserted or modified, and the value true means inserted and the false modified </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01603">1603</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5f19e2761969c0ca35c840424906f7e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#af4ced6d91afee8791fb0143addc93555">mypair</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::insert_or_modify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">data_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the element with key x don't exist, it is inserted the pair (x,D) if the element exist, the second part is asigned to the value D. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: data value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair &lt;iterator,bool&gt; with an iterator to the element inserted or modified, and the value true means inserted and the false modified </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01632">1632</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a847ebcffd69877205c668f245bc3db2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#af4ced6d91afee8791fb0143addc93555">mypair</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::insert_or_modify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const data_t &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the element with key x don't exist, it is inserted the pair (x,D) if the element exist, the function M is executed over the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: data value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function to modify the existing element with the format ( void M ( value_type &amp; ) ) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair &lt;iterator,bool&gt; with an iterator to the element inserted or modified, and the value true means inserted and the false modified </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01664">1664</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad2e3ed553179cb04ac9d454cd70a8c3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#af4ced6d91afee8791fb0143addc93555">mypair</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::insert_or_modify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">data_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the element with key x don't exist, it is inserted the pair (x,D) if the element exist, the function M is executed over the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: data value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function to modify the existing element with the format ( void M ( value_type &amp; ) ) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair &lt;iterator,bool&gt; with an iterator to the element inserted or modified, and the value true means inserted and the false modified </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01694">1694</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a174fcd2b56fd5077a36e6d2316de4063"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::is_mine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the iterator is pointing to this <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: iterator to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(true/false ) Indicate if it is pointing to this <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01798">1798</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a088dc16cf3ea09d89b20744d637e1f1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::is_mine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00015.html#ab17f9740bf5572d465ce68c782858eb2">const_reverse_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the iterator is pointing to this <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: iterator to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(true/false ) Indicate if it is pointing to this <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01809">1809</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae118488cd0b6207b04ae16cdb7f18860"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::it_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01830">1830</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad33a9c0421720a613e25862cdf68080d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::it_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01846">1846</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a46390bd3bcf45c9bf6260cea0a353bc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::it_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01862">1862</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0bfbe905613989911420cb50757d9229"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::it_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01870">1870</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab801ec21e1e8d8629e31bc410b471cc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::iterator_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a position in the sorted_tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the position. If don't exists throws an exception </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log N) </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00466">466</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad60c3a8fb765dab1191e1cab9d1e4406"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a563d5dc39e397ddbe0f35d7d40fe46e3">key_compare</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::key_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the object used to compare two keys </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>object used to compare two keys </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01739">1739</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab9d84873d95325074b0bed657394d31b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return one iterator to the first appearance of the key x if exist and if don't exist return one iterator to the first element greather than x </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00608">608</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1027150a6e92cb893b1fa0f60204b864"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return one const_iterator to the first appearance of the key x if exist <br/>
 and if don't exist return one iterator to the first element greather than x </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_iterator </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00620">620</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af8c6cabcae2730b9bac241acd75a8676"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#abcc525d440865165939b4a954441ce9e">size_type</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::max_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the maximun size of the container </p>
<dl class="section return"><dt>Returns</dt><dd>maximun size of the container </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00394">394</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acc1fcb055bc361b26e0f7a396604f331"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::modify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a>&#160;</td>
          <td class="paramname"><em>It</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const data_t &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>modify the element pointed by the iterator It </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">It</td><td>: iterator which point to the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: new value of the field second </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01452">1452</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4a4b683eb6f7bf673d39949570c8ca59"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::modify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a>&#160;</td>
          <td class="paramname"><em>It</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">data_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>modify the element pointed by the iterator It </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">It</td><td>: iterator which point to the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: new value of the field second </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01467">1467</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6170412390c4b357e1cbddc7798d287c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::modify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a>&#160;</td>
          <td class="paramname"><em>It</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>modify the element pointed by the iterator It </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">It</td><td>: iterator which point to the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function for to modify the element ( void M ( value_type &amp;) ) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01484">1484</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa10702d3adde4de014c2f2a3cc9a78ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::modify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const data_t &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>modify the element with the key x </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key to search in the map </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val,:</td><td>new value to modify the field second of the element with the key x </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true : modified false : not </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01500">1500</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a62b6d81999ff60b28f0c964f76869dae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::modify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">data_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>modify the element with the key x </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key to search in the map </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val,:</td><td>new value to modify the field second of the element with the key x </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true : modified false : not </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01518">1518</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af58aca5ffe83e81934092e25547137f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::modify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>modify the element with the key x with the function M </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key to search in the map </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function for to modify the field second of the element with the key x with the format (void M (value_type &amp;)) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true : modified false : not </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01536">1536</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2c904582361d94e1107472ae8a0c893e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::modify_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const data_t &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>modify the element of the position pos with the value val </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: position to modify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>: value to substitute the field second in the element of the position Pos </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01554">1554</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab26f22d78aff6c7d8c74769767b40b87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::modify_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">data_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>modify the element of the position pos with the value val </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: position to modify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>: value to substitute the field second in the element of the position Pos </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01570">1570</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a56529fd348c5c58b66b744f59293f1b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::modify_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>modify the element of the position pos with the function M </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: position to modify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function to modify with the format ( void M ( value_type &amp;) ) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01586">1586</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9bdb4dab16861062b01008339b82b12f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html">cntree_map</a>&amp; <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00015.html">cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asignation operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>: <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> after the copy </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00280">280</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae981c188dc4e0cf6b52069991994308a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html">cntree_map</a>&amp; <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00015.html">cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asignation operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>: <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> from where move the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> after the copy </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00294">294</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a75c812ce7e9077735e311f0b945800e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename alloc_t2 , bool cnc2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html">cntree_map</a>&amp; <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00015.html">cntree_map</a>&lt; key_t, data_t, cnc2, comp_key_t, alloc_t2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asignation operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>: <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> after the copy </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00310">310</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acf81297c37387042d017f14fe4751920"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;bool cnc2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html">cntree_map</a>&amp; <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00015.html">cntree_map</a>&lt; key_t, data_t, cnc2, comp_key_t, alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asignation operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>: <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> from where move the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> after the copy </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00326">326</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0aef29f2de1ce6401963d8e4cbd94371"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">data_t&amp; <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the Data with the key K, if don't exist , inserts a new pair (key, Data) with that key and returns a reference to this pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>key to find in the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the Data of the pair with key K </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00717">717</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8945acf3d01b2f02d36ca9ebd7cdce08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::pop_back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant) </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01086">1086</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afa3a78915e75ceb93d0763202fe4046e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::pop_back_if </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format ( bool M (value_t &amp;)) if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree 2 - Function returns false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant) </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01103">1103</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a01cfbb8e078cfe0bedde199c2f19e843"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::pop_copy_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the tree and return a copy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01122">1122</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a29de113db20337a2bde538425817262f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::pop_copy_back_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the tree and return a copy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M1</td><td>: function with the format ( bool M (value_t &amp;)) if return true the element is deleted , if false not </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree 2 - Function returns false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01146">1146</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a071fecb96c4f2e185b87ce0de3a0f280"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::pop_copy_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the tree and return a copy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant) </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00981">981</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a885c19f2d3b576dc0244f70bfc05f214"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::pop_copy_front_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the tree and return a copy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format ( bool M (value_t &amp;)) if return true the element is deleted , if false not </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree 2 - Function returns false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01005">1005</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0eec2682acfa06b346089c5b52b7dbd8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::pop_front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (constant) </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00944">944</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5eeef753d23113fd0c40b1928bfd3c24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::pop_front_if </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format ( bool M (value_t &amp;)) if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree 2 - Function returns false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (constant) </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00961">961</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa02776ab054982f8c134cc21d6123e8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::pop_move_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the tree and return a copy with rvalues </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01167">1167</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa01ea23fff8ac77e89accd66f91ad564"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::pop_move_back_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the tree and return a copy with rvalues </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M1</td><td>: function with the format ( bool M (value_t &amp;)) if return true the element is deleted , if false not </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01190">1190</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a629dae6c57f6ef4bdc692f0915c03af6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::pop_move_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the tree and return a copy with rvalues </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01026">1026</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad724526ff3eec6ef2a69694c721c8e77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::pop_move_front_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the tree and return a copy with rvalues </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format ( bool M (value_t &amp;)) if return true the element is deleted , if false not </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01049">1049</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac12baa13bb74657c45c2d3145598b674"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a>&amp; <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to an element by their position in the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in]</td><td>Pos : Position to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the object selected </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is an random access function of the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a>. This operation is log(N) <br/>
 I didn't use the operator [ ] because it is used in the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> class.<br/>
 The function at is used in std <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> in C++11<br/>
 It is very important to be uniform access method in the four classes ( <a class="el" href="a00018.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a>, <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a>, <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> and <a class="el" href="a00016.html" title="This class have the same interface and functions than the class cntree_multimap defined in the Standa...">cntree_multimap</a>) </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00438">438</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a34786bd25166b1b5487f0a08073ece"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a>&amp; <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos1</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to an element by their position in the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in]</td><td>Pos : Position to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the object selected </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is an random access function of the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a>. This operation is log(N) <br/>
 I didn't use the operator [ ] because it is used in the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> class.<br/>
 The function at is used in std <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> in C++11<br/>
 It is very important to be uniform access method in the four classes ( <a class="el" href="a00018.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_set</a>, <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a>, <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> and <a class="el" href="a00016.html" title="This class have the same interface and functions than the class cntree_multimap defined in the Standa...">cntree_multimap</a>) </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00454">454</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b788e5992dec406ca1616cf27b1f711"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#ad4da70f289c93e90698e4171dd14faa1">reverse_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01994">1994</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af07b3ecf79c6a3b781efd0bfd2e37c2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#ab17f9740bf5572d465ce68c782858eb2">const_reverse_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l02057">2057</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab2bc5630d9142ba60159186b31aaf317"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00015.html#a06c93eb0ba9c92dcb8256f4650f1e4bd">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an copy of the object in the tree. If exist return true. If don't exist return false <br/>
 This function supouse there is only one element with the key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>: object where copy the element of the tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Key</td><td>: key to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true- copy in V false didn't find in the tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00579">579</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a236ca22b974255464d8785b27ae47896"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#ad4da70f289c93e90698e4171dd14faa1">reverse_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l02010">2010</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a33166c96820309f250d72d4a17ce6eae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#ab17f9740bf5572d465ce68c782858eb2">const_reverse_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l02081">2081</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3360b8bf0fd2498d7b9e55cc5f151120"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#ad4da70f289c93e90698e4171dd14faa1">reverse_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::rit_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01970">1970</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6425364878204585187d983f0b47821"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#ad4da70f289c93e90698e4171dd14faa1">reverse_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::rit_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01978">1978</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a797f09dda93dd7db3146a03618328694"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#ad4da70f289c93e90698e4171dd14faa1">reverse_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::rit_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01986">1986</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aebdfdd0620656994caa15b3a4ee8e886"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#ad4da70f289c93e90698e4171dd14faa1">reverse_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::rit_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l02002">2002</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad9fdbf972c57464124c142ffa35fd5b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#abcc525d440865165939b4a954441ce9e">size_type</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the number of elements in the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> </p>
<dl class="section return"><dt>Returns</dt><dd>number of elements in the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00385">385</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a53dafa34186a341c7909b2e739671a29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00015.html">cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>swap the data of the <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> st with the actual <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mp</td><td>: <a class="el" href="a00015.html" title="This class have the same interface and functions than the class cntree_map defined in the Standard Te...">cntree_map</a> to swap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00342">342</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a54e46957435029cccf8de1e762f09976"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a757ce2104645777e2d4ca845296bbeca">iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return one iterator to the first element greather than x. If don't exist any element greather than x , return <a class="el" href="a00015.html#a964f1bdc3ea05d048e4f638eabc9064b">end()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00631">631</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af86dd570c71566782d70f6b4ac1b557c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#a93d18e6aa65e1edbac5f4e5fce606be3">const_iterator</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00015.html#afdb91887d36faf70731a2a84fb6d63a4">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return one const_iterator to the first element greather than x. If don't exist any element greather than x , return <a class="el" href="a00015.html#a964f1bdc3ea05d048e4f638eabc9064b">end()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_iterator </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l00642">642</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1946738c5b245dc68f1474bb1678ac7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#ae79a264ab6bdb7e0ef8f8ef6da2b0016">ValueCompare</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::value_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the object used to compare two values </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>object used to compare two values </dd></dl>

<p>Definition at line <a class="el" href="a00110_source.html#l01749">1749</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="afed9ed36b4aa427dbf94ec6e15d9aee9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class key_t2 , class data_t2 , bool cnc2, class comp_key_t2 , class alloc_t2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="a00015.html">cntree_map</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00099">99</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acdff38632eb4e67520c049544acad28b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class key_t2 , class data_t2 , bool cnc2, class comp_key_t2 , class alloc_t2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="a00016.html">cntree_multimap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00100">100</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aa95b6d569ee7930fca89273b514400c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename key_t, typename data_t, bool cnc = false, class comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00015.html#ad209b6cd561d7bae16e18dd036a6ebfe">mtx_data</a> <a class="el" href="a00015.html">countertree::cntree_map</a>&lt; key_t, data_t, cnc, comp_key_t, alloc_t &gt;::BD</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00110_source.html#l00110">110</a> of file <a class="el" href="a00110_source.html">cntree_map.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00110_source.html">cntree_map.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00147.html">countertree</a></li><li class="navelem"><a class="el" href="a00015.html">cntree_map</a></li>
    <li class="footer">Generated on Mon Oct 14 2013 22:46:59 for [ countertree + suballocator ] by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
