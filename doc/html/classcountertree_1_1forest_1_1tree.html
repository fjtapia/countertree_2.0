<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Countertree: countertree::forest::tree&lt; value_t, node_alloc_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Countertree
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">concurrent set , multiset map and multimap with random access iterators</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcountertree_1_1forest_1_1tree.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classcountertree_1_1forest_1_1tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">countertree::forest::tree&lt; value_t, node_alloc_t &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class have the same interface than the STL vector, but istead of be a vector is a tree. <br/>
 Due to this all the operations ( insert, delete, access) a O( logN). <br/>
.  
 <a href="classcountertree_1_1forest_1_1tree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tree_8hpp_source.html">tree.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af62e7d9749b95b2cfe4aa45a1ba09d3a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacecountertree_1_1common.html#aacea70d0e38fcfefebf3b6ad0a88ae6f">c_common::signed_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#af62e7d9749b95b2cfe4aa45a1ba09d3a">size_type</a></td></tr>
<tr class="separator:af62e7d9749b95b2cfe4aa45a1ba09d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4899fc42db7c3418d99a86118933342"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacecountertree_1_1common.html#aacea70d0e38fcfefebf3b6ad0a88ae6f">c_common::signed_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ac4899fc42db7c3418d99a86118933342">difference_type</a></td></tr>
<tr class="separator:ac4899fc42db7c3418d99a86118933342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c01705ce2fe0ffcba7a92043734f30"><td class="memItemLeft" align="right" valign="top">typedef value_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a></td></tr>
<tr class="separator:a59c01705ce2fe0ffcba7a92043734f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d55dcff9a6d6007b9cd7c626587a7fd"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a4d55dcff9a6d6007b9cd7c626587a7fd">pointer</a></td></tr>
<tr class="separator:a4d55dcff9a6d6007b9cd7c626587a7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae144854364603d19a93bb62772b7829f"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ae144854364603d19a93bb62772b7829f">const_pointer</a></td></tr>
<tr class="separator:ae144854364603d19a93bb62772b7829f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63560ea528d9b393acb0d2824a5e38d5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a63560ea528d9b393acb0d2824a5e38d5">reference</a></td></tr>
<tr class="separator:a63560ea528d9b393acb0d2824a5e38d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba22db65eff769cc801a7a5203af79e4"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aba22db65eff769cc801a7a5203af79e4">const_reference</a></td></tr>
<tr class="separator:aba22db65eff769cc801a7a5203af79e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3006fe9bd55b7ef169b250da47ba0116"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structcountertree_1_1forest_1_1node.html">c_forest::node</a>&lt; value_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a></td></tr>
<tr class="separator:a3006fe9bd55b7ef169b250da47ba0116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667a1e5473ccb2ba456f4a9799239321"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structcountertree_1_1forest_1_1base__node.html">c_forest::base_node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a></td></tr>
<tr class="separator:a667a1e5473ccb2ba456f4a9799239321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752155609649dc94fe17ae0239376f04"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1forest_1_1iterator.html">c_forest::iterator</a>&lt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a></td></tr>
<tr class="separator:a752155609649dc94fe17ae0239376f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf68addaf301fecce33fc7c2a82987d5"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classcountertree_1_1forest_1_1const__iterator.html">c_forest::const_iterator</a>&lt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a></td></tr>
<tr class="separator:aaf68addaf301fecce33fc7c2a82987d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc1af3e272082d169789594bdcd0114"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classcountertree_1_1forest_1_1reverse__iterator.html">c_forest::reverse_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a></td></tr>
<tr class="separator:a9cc1af3e272082d169789594bdcd0114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8570b4b8f3076f34067fa4ec34afca"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classcountertree_1_1forest_1_1const__reverse__iterator.html">c_forest::const_reverse_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a></td></tr>
<tr class="separator:afb8570b4b8f3076f34067fa4ec34afca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7fad36adf1980c5c105504b222648b"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="structcountertree_1_1forest_1_1base__iterator.html">c_forest::base_iterator</a>&lt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aab7fad36adf1980c5c105504b222648b">base_iterator</a></td></tr>
<tr class="separator:aab7fad36adf1980c5c105504b222648b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad23777e9919c8b49524662ebf1a1bf"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="structcountertree_1_1forest_1_1const__base__iterator.html">c_forest::const_base_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a0ad23777e9919c8b49524662ebf1a1bf">const_base_iterator</a></td></tr>
<tr class="separator:a0ad23777e9919c8b49524662ebf1a1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62e7d9749b95b2cfe4aa45a1ba09d3a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacecountertree_1_1common.html#aacea70d0e38fcfefebf3b6ad0a88ae6f">c_common::signed_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#af62e7d9749b95b2cfe4aa45a1ba09d3a">size_type</a></td></tr>
<tr class="separator:af62e7d9749b95b2cfe4aa45a1ba09d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4899fc42db7c3418d99a86118933342"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacecountertree_1_1common.html#aacea70d0e38fcfefebf3b6ad0a88ae6f">c_common::signed_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ac4899fc42db7c3418d99a86118933342">difference_type</a></td></tr>
<tr class="separator:ac4899fc42db7c3418d99a86118933342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c01705ce2fe0ffcba7a92043734f30"><td class="memItemLeft" align="right" valign="top">typedef value_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a></td></tr>
<tr class="separator:a59c01705ce2fe0ffcba7a92043734f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d55dcff9a6d6007b9cd7c626587a7fd"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a4d55dcff9a6d6007b9cd7c626587a7fd">pointer</a></td></tr>
<tr class="separator:a4d55dcff9a6d6007b9cd7c626587a7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae144854364603d19a93bb62772b7829f"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ae144854364603d19a93bb62772b7829f">const_pointer</a></td></tr>
<tr class="separator:ae144854364603d19a93bb62772b7829f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63560ea528d9b393acb0d2824a5e38d5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a63560ea528d9b393acb0d2824a5e38d5">reference</a></td></tr>
<tr class="separator:a63560ea528d9b393acb0d2824a5e38d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba22db65eff769cc801a7a5203af79e4"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aba22db65eff769cc801a7a5203af79e4">const_reference</a></td></tr>
<tr class="separator:aba22db65eff769cc801a7a5203af79e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3006fe9bd55b7ef169b250da47ba0116"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structcountertree_1_1forest_1_1node.html">c_forest::node</a>&lt; value_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a></td></tr>
<tr class="separator:a3006fe9bd55b7ef169b250da47ba0116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667a1e5473ccb2ba456f4a9799239321"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structcountertree_1_1forest_1_1base__node.html">c_forest::base_node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a></td></tr>
<tr class="separator:a667a1e5473ccb2ba456f4a9799239321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752155609649dc94fe17ae0239376f04"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1forest_1_1iterator.html">c_forest::iterator</a>&lt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a></td></tr>
<tr class="separator:a752155609649dc94fe17ae0239376f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf68addaf301fecce33fc7c2a82987d5"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classcountertree_1_1forest_1_1const__iterator.html">c_forest::const_iterator</a>&lt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a></td></tr>
<tr class="separator:aaf68addaf301fecce33fc7c2a82987d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc1af3e272082d169789594bdcd0114"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classcountertree_1_1forest_1_1reverse__iterator.html">c_forest::reverse_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a></td></tr>
<tr class="separator:a9cc1af3e272082d169789594bdcd0114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8570b4b8f3076f34067fa4ec34afca"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classcountertree_1_1forest_1_1const__reverse__iterator.html">c_forest::const_reverse_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a></td></tr>
<tr class="separator:afb8570b4b8f3076f34067fa4ec34afca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7fad36adf1980c5c105504b222648b"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="structcountertree_1_1forest_1_1base__iterator.html">c_forest::base_iterator</a>&lt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aab7fad36adf1980c5c105504b222648b">base_iterator</a></td></tr>
<tr class="separator:aab7fad36adf1980c5c105504b222648b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad23777e9919c8b49524662ebf1a1bf"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="structcountertree_1_1forest_1_1const__base__iterator.html">c_forest::const_base_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a0ad23777e9919c8b49524662ebf1a1bf">const_base_iterator</a></td></tr>
<tr class="separator:a0ad23777e9919c8b49524662ebf1a1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af41af4bbb3350157359fae9d436fbf15"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#af41af4bbb3350157359fae9d436fbf15">tree</a> (const node_alloc_t &amp;na=node_alloc_t()) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:af41af4bbb3350157359fae9d436fbf15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#af41af4bbb3350157359fae9d436fbf15">More...</a><br/></td></tr>
<tr class="separator:af41af4bbb3350157359fae9d436fbf15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6af85e6039f03999116f18cc339c88e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ad6af85e6039f03999116f18cc339c88e">tree</a> (const <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &amp;T)</td></tr>
<tr class="memdesc:ad6af85e6039f03999116f18cc339c88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="#ad6af85e6039f03999116f18cc339c88e">More...</a><br/></td></tr>
<tr class="separator:ad6af85e6039f03999116f18cc339c88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0496ac3428b1779641ff8f1e070e5544"><td class="memTemplParams" colspan="2">template&lt;typename node_alloc2_t &gt; </td></tr>
<tr class="memitem:a0496ac3428b1779641ff8f1e070e5544"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a0496ac3428b1779641ff8f1e070e5544">tree</a> (const <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc2_t &gt; &amp;T)</td></tr>
<tr class="memdesc:a0496ac3428b1779641ff8f1e070e5544"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="#a0496ac3428b1779641ff8f1e070e5544">More...</a><br/></td></tr>
<tr class="separator:a0496ac3428b1779641ff8f1e070e5544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7444654225a13f25d012082dbcc9f8c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a7444654225a13f25d012082dbcc9f8c4">tree</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &amp;&amp;B) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a7444654225a13f25d012082dbcc9f8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor from a rvalue  <a href="#a7444654225a13f25d012082dbcc9f8c4">More...</a><br/></td></tr>
<tr class="separator:a7444654225a13f25d012082dbcc9f8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041a21a93b897c3801df3e4eccdc4eee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a041a21a93b897c3801df3e4eccdc4eee">~tree</a> (void)</td></tr>
<tr class="memdesc:a041a21a93b897c3801df3e4eccdc4eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a041a21a93b897c3801df3e4eccdc4eee">More...</a><br/></td></tr>
<tr class="separator:a041a21a93b897c3801df3e4eccdc4eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b378740b11d56aef8048904223d948"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a59b378740b11d56aef8048904223d948">operator=</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &amp;&amp;B)</td></tr>
<tr class="memdesc:a59b378740b11d56aef8048904223d948"><td class="mdescLeft">&#160;</td><td class="mdescRight">asignation operator  <a href="#a59b378740b11d56aef8048904223d948">More...</a><br/></td></tr>
<tr class="separator:a59b378740b11d56aef8048904223d948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0655366212ee0c410f0c2d6d5b5f4636"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a0655366212ee0c410f0c2d6d5b5f4636">operator=</a> (const <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &amp;T)</td></tr>
<tr class="memdesc:a0655366212ee0c410f0c2d6d5b5f4636"><td class="mdescLeft">&#160;</td><td class="mdescRight">asignation operator  <a href="#a0655366212ee0c410f0c2d6d5b5f4636">More...</a><br/></td></tr>
<tr class="separator:a0655366212ee0c410f0c2d6d5b5f4636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31f5b80c9cc8c030ee5f2e65835ee60"><td class="memTemplParams" colspan="2">template&lt;typename node_alloc2_t &gt; </td></tr>
<tr class="memitem:ac31f5b80c9cc8c030ee5f2e65835ee60"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ac31f5b80c9cc8c030ee5f2e65835ee60">operator=</a> (const <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc2_t &gt; &amp;T)</td></tr>
<tr class="memdesc:ac31f5b80c9cc8c030ee5f2e65835ee60"><td class="mdescLeft">&#160;</td><td class="mdescRight">asignation operator  <a href="#ac31f5b80c9cc8c030ee5f2e65835ee60">More...</a><br/></td></tr>
<tr class="separator:ac31f5b80c9cc8c030ee5f2e65835ee60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52b102e4d25507f79e6b2fda89fb709"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:aa52b102e4d25507f79e6b2fda89fb709"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aa52b102e4d25507f79e6b2fda89fb709">assign</a> (InputIterator it_first, InputIterator it_last)</td></tr>
<tr class="memdesc:aa52b102e4d25507f79e6b2fda89fb709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a range of data, dropping all the elements of the container. It's like the assignation operator but with several parameters.  <a href="#aa52b102e4d25507f79e6b2fda89fb709">More...</a><br/></td></tr>
<tr class="separator:aa52b102e4d25507f79e6b2fda89fb709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa729073df47102d44b6b59794dba22ef"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:aa729073df47102d44b6b59794dba22ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aa729073df47102d44b6b59794dba22ef">assign_if</a> (InputIterator it_first, InputIterator it_last, std::function&lt; bool(const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a> &amp;)&gt; M)</td></tr>
<tr class="memdesc:aa729073df47102d44b6b59794dba22ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a range of data, dropping all the elements of the container It's like the assignation operator but with several parameters.  <a href="#aa729073df47102d44b6b59794dba22ef">More...</a><br/></td></tr>
<tr class="separator:aa729073df47102d44b6b59794dba22ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f0602c6bf41a2c6f117e7e71cb74b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a82f0602c6bf41a2c6f117e7e71cb74b2">assign</a> (signed_type n, const value_t &amp;u)</td></tr>
<tr class="memdesc:a82f0602c6bf41a2c6f117e7e71cb74b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a range of data, dropping all the elements of the container It's like the assignation operator but with several parameters.  <a href="#a82f0602c6bf41a2c6f117e7e71cb74b2">More...</a><br/></td></tr>
<tr class="separator:a82f0602c6bf41a2c6f117e7e71cb74b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0364e03d69ee50e529f48c251b4cb2"><td class="memTemplParams" colspan="2">template&lt;typename node_alloc_t2 &gt; </td></tr>
<tr class="memitem:aac0364e03d69ee50e529f48c251b4cb2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aac0364e03d69ee50e529f48c251b4cb2">copy</a> (const <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc_t2 &gt; &amp;T)</td></tr>
<tr class="memdesc:aac0364e03d69ee50e529f48c251b4cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asignation operator.  <a href="#aac0364e03d69ee50e529f48c251b4cb2">More...</a><br/></td></tr>
<tr class="separator:aac0364e03d69ee50e529f48c251b4cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcce84e57f78847c0ce82d594dd343ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#abcce84e57f78847c0ce82d594dd343ca">clear</a> (void)</td></tr>
<tr class="memdesc:abcce84e57f78847c0ce82d594dd343ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all the elements of the tree.  <a href="#abcce84e57f78847c0ce82d594dd343ca">More...</a><br/></td></tr>
<tr class="separator:abcce84e57f78847c0ce82d594dd343ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5c1b8c253c34b6b20e13bfdf13f1c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a7c5c1b8c253c34b6b20e13bfdf13f1c4">move</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &amp;&amp;B)</td></tr>
<tr class="memdesc:a7c5c1b8c253c34b6b20e13bfdf13f1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move all the elements of the tree.  <a href="#a7c5c1b8c253c34b6b20e13bfdf13f1c4">More...</a><br/></td></tr>
<tr class="separator:a7c5c1b8c253c34b6b20e13bfdf13f1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f136d59a898e0939dfefaab159c6770"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a1f136d59a898e0939dfefaab159c6770">resize</a> (signed_type sz, value_t c=value_t())</td></tr>
<tr class="memdesc:a1f136d59a898e0939dfefaab159c6770"><td class="mdescLeft">&#160;</td><td class="mdescRight">resize the current vector size and change to sz.<br/>
 If sz is smaller than the current size, delete elements to end<br/>
 If sz is greater than the current size, insert elements to the end with the value c  <a href="#a1f136d59a898e0939dfefaab159c6770">More...</a><br/></td></tr>
<tr class="separator:a1f136d59a898e0939dfefaab159c6770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47b86c89cfdef7ebf92f4ba7fdbb342"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ac47b86c89cfdef7ebf92f4ba7fdbb342">swap</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &amp;B)</td></tr>
<tr class="memdesc:ac47b86c89cfdef7ebf92f4ba7fdbb342"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap two trees  <a href="#ac47b86c89cfdef7ebf92f4ba7fdbb342">More...</a><br/></td></tr>
<tr class="separator:ac47b86c89cfdef7ebf92f4ba7fdbb342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22fde787e169da53de580084e807504"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ae22fde787e169da53de580084e807504">capacity</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ae22fde787e169da53de580084e807504"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the maximun size of the container  <a href="#ae22fde787e169da53de580084e807504">More...</a><br/></td></tr>
<tr class="separator:ae22fde787e169da53de580084e807504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd2aa4e71c2c1f0290e8c646733f095"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#abdd2aa4e71c2c1f0290e8c646733f095">empty</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:abdd2aa4e71c2c1f0290e8c646733f095"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicate if the map is empty  <a href="#abdd2aa4e71c2c1f0290e8c646733f095">More...</a><br/></td></tr>
<tr class="separator:abdd2aa4e71c2c1f0290e8c646733f095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d24357cdfa2bf62304d052d3219052b"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a8d24357cdfa2bf62304d052d3219052b">size</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a8d24357cdfa2bf62304d052d3219052b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of elements in the tree  <a href="#a8d24357cdfa2bf62304d052d3219052b">More...</a><br/></td></tr>
<tr class="separator:a8d24357cdfa2bf62304d052d3219052b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78c5519cee9daa25467e405245bc75d"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aa78c5519cee9daa25467e405245bc75d">levels</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:aa78c5519cee9daa25467e405245bc75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of levels in the tree  <a href="#aa78c5519cee9daa25467e405245bc75d">More...</a><br/></td></tr>
<tr class="separator:aa78c5519cee9daa25467e405245bc75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b5b7d9ef2aaf730eac5504b96a6b9b"><td class="memItemLeft" align="right" valign="top">value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a59b5b7d9ef2aaf730eac5504b96a6b9b">operator[]</a> (signed_type Pos) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a59b5b7d9ef2aaf730eac5504b96a6b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked access to an element by their position in the tree.  <a href="#a59b5b7d9ef2aaf730eac5504b96a6b9b">More...</a><br/></td></tr>
<tr class="separator:a59b5b7d9ef2aaf730eac5504b96a6b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8cf30165ce6d0f883b4a6371ae0020"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a6c8cf30165ce6d0f883b4a6371ae0020">operator[]</a> (signed_type Pos) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a6c8cf30165ce6d0f883b4a6371ae0020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked access to an element by their position in the tree.  <a href="#a6c8cf30165ce6d0f883b4a6371ae0020">More...</a><br/></td></tr>
<tr class="separator:a6c8cf30165ce6d0f883b4a6371ae0020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a2ecda1f0f645054f1623e09463d32"><td class="memItemLeft" align="right" valign="top">value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ac5a2ecda1f0f645054f1623e09463d32">front</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ac5a2ecda1f0f645054f1623e09463d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the first element in the tree.  <a href="#ac5a2ecda1f0f645054f1623e09463d32">More...</a><br/></td></tr>
<tr class="separator:ac5a2ecda1f0f645054f1623e09463d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f5d958d85b20a68550a081bd4888d0"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a08f5d958d85b20a68550a081bd4888d0">front</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a08f5d958d85b20a68550a081bd4888d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const_reference to the first element in the tree.  <a href="#a08f5d958d85b20a68550a081bd4888d0">More...</a><br/></td></tr>
<tr class="separator:a08f5d958d85b20a68550a081bd4888d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fa69d33c09fb437646bc4b3b95e9e9"><td class="memItemLeft" align="right" valign="top">value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a17fa69d33c09fb437646bc4b3b95e9e9">back</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a17fa69d33c09fb437646bc4b3b95e9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the last element in the tree.  <a href="#a17fa69d33c09fb437646bc4b3b95e9e9">More...</a><br/></td></tr>
<tr class="separator:a17fa69d33c09fb437646bc4b3b95e9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586cc0895021be77105d23b91ad12506"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a586cc0895021be77105d23b91ad12506">back</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a586cc0895021be77105d23b91ad12506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const_reference to the last element in the tree.  <a href="#a586cc0895021be77105d23b91ad12506">More...</a><br/></td></tr>
<tr class="separator:a586cc0895021be77105d23b91ad12506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9f7189cc4d851c60703d78db012aa9"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:add9f7189cc4d851c60703d78db012aa9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#add9f7189cc4d851c60703d78db012aa9">emplace_internal</a> (<a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a> C, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:add9f7189cc4d851c60703d78db012aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in a the position specified by the connector  <a href="#add9f7189cc4d851c60703d78db012aa9">More...</a><br/></td></tr>
<tr class="separator:add9f7189cc4d851c60703d78db012aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc67872c42d995e8ec7359a3b97a2d7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#acc67872c42d995e8ec7359a3b97a2d7b">push_front</a> (const value_t &amp;D)</td></tr>
<tr class="memdesc:acc67872c42d995e8ec7359a3b97a2d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in the front of the container  <a href="#acc67872c42d995e8ec7359a3b97a2d7b">More...</a><br/></td></tr>
<tr class="separator:acc67872c42d995e8ec7359a3b97a2d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c756e10c6733e2cf85068b8e8f72fcb"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a4c756e10c6733e2cf85068b8e8f72fcb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a4c756e10c6733e2cf85068b8e8f72fcb">emplace_front</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a4c756e10c6733e2cf85068b8e8f72fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in the front of the container  <a href="#a4c756e10c6733e2cf85068b8e8f72fcb">More...</a><br/></td></tr>
<tr class="separator:a4c756e10c6733e2cf85068b8e8f72fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894bae031f46f46cfeffcb763397bd10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a894bae031f46f46cfeffcb763397bd10">push_back</a> (const value_t &amp;D)</td></tr>
<tr class="memdesc:a894bae031f46f46cfeffcb763397bd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert one element in the back of the container.  <a href="#a894bae031f46f46cfeffcb763397bd10">More...</a><br/></td></tr>
<tr class="separator:a894bae031f46f46cfeffcb763397bd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace37599ccc53ed3d56834aec90802adf"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ace37599ccc53ed3d56834aec90802adf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ace37599ccc53ed3d56834aec90802adf">emplace_back</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ace37599ccc53ed3d56834aec90802adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert one element in the back of the container.  <a href="#ace37599ccc53ed3d56834aec90802adf">More...</a><br/></td></tr>
<tr class="separator:ace37599ccc53ed3d56834aec90802adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf18eef5461f0da8060e29bfffed8d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#abcf18eef5461f0da8060e29bfffed8d9">insert_pos</a> (signed_type Pos, const value_t &amp;D)</td></tr>
<tr class="memdesc:abcf18eef5461f0da8060e29bfffed8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in a specified position  <a href="#abcf18eef5461f0da8060e29bfffed8d9">More...</a><br/></td></tr>
<tr class="separator:abcf18eef5461f0da8060e29bfffed8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab89cb09b79d98f649dcdc2cf3b5a0c"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a9ab89cb09b79d98f649dcdc2cf3b5a0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9ab89cb09b79d98f649dcdc2cf3b5a0c">emplace_pos</a> (signed_type Pos, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a9ab89cb09b79d98f649dcdc2cf3b5a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in a specified position  <a href="#a9ab89cb09b79d98f649dcdc2cf3b5a0c">More...</a><br/></td></tr>
<tr class="separator:a9ab89cb09b79d98f649dcdc2cf3b5a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a36a8773e9f6b3986f20005e032f4b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a5a36a8773e9f6b3986f20005e032f4b6">insert</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> iter, const value_t &amp;D)</td></tr>
<tr class="memdesc:a5a36a8773e9f6b3986f20005e032f4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in the previous position to the pointed by the iterator  <a href="#a5a36a8773e9f6b3986f20005e032f4b6">More...</a><br/></td></tr>
<tr class="separator:a5a36a8773e9f6b3986f20005e032f4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e777d5abd68155813c760eb01618e6"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a00e777d5abd68155813c760eb01618e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a00e777d5abd68155813c760eb01618e6">emplace</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> iter, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a00e777d5abd68155813c760eb01618e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in the previous position to the pointed by the iterator  <a href="#a00e777d5abd68155813c760eb01618e6">More...</a><br/></td></tr>
<tr class="separator:a00e777d5abd68155813c760eb01618e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f84563d58fa2060ea2528331c5cf074"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a4f84563d58fa2060ea2528331c5cf074">connector_begin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a4f84563d58fa2060ea2528331c5cf074"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the connector for to insert an element in the first position of the tree  <a href="#a4f84563d58fa2060ea2528331c5cf074">More...</a><br/></td></tr>
<tr class="separator:a4f84563d58fa2060ea2528331c5cf074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968563a4fd4814dcad70c5dd8d2654fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a968563a4fd4814dcad70c5dd8d2654fc">connector_end</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a968563a4fd4814dcad70c5dd8d2654fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the connector for to insert an element in the first position of the tree  <a href="#a968563a4fd4814dcad70c5dd8d2654fc">More...</a><br/></td></tr>
<tr class="separator:a968563a4fd4814dcad70c5dd8d2654fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc73dbf477b69751305af1da1b22b630"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#adc73dbf477b69751305af1da1b22b630">connector_pos</a> (signed_type Pos) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:adc73dbf477b69751305af1da1b22b630"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the connector for to insert a new node in the position Pos  <a href="#adc73dbf477b69751305af1da1b22b630">More...</a><br/></td></tr>
<tr class="separator:adc73dbf477b69751305af1da1b22b630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b92b98afcfa18d52debf704c6080070"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a2b92b98afcfa18d52debf704c6080070">connector_pointer</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *Ptr) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a2b92b98afcfa18d52debf704c6080070"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the connector for to insert the new node in the position before the node pointed by Ptr  <a href="#a2b92b98afcfa18d52debf704c6080070">More...</a><br/></td></tr>
<tr class="separator:a2b92b98afcfa18d52debf704c6080070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72de3511684b1f945bd006e44d3af12d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a72de3511684b1f945bd006e44d3af12d">erase_internal</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *PAux)</td></tr>
<tr class="memdesc:a72de3511684b1f945bd006e44d3af12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the container  <a href="#a72de3511684b1f945bd006e44d3af12d">More...</a><br/></td></tr>
<tr class="separator:a72de3511684b1f945bd006e44d3af12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48a3512e1b80dcf671f8fdd3053f96c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aa48a3512e1b80dcf671f8fdd3053f96c">pop_front</a> (void)</td></tr>
<tr class="memdesc:aa48a3512e1b80dcf671f8fdd3053f96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the container  <a href="#aa48a3512e1b80dcf671f8fdd3053f96c">More...</a><br/></td></tr>
<tr class="separator:aa48a3512e1b80dcf671f8fdd3053f96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658b0b9f881138ce58d433ac00f2ffe3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a658b0b9f881138ce58d433ac00f2ffe3">pop_back</a> (void)</td></tr>
<tr class="memdesc:a658b0b9f881138ce58d433ac00f2ffe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the container  <a href="#a658b0b9f881138ce58d433ac00f2ffe3">More...</a><br/></td></tr>
<tr class="separator:a658b0b9f881138ce58d433ac00f2ffe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002118c0ab4d78234a1f7ef67e9edec7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a002118c0ab4d78234a1f7ef67e9edec7">erase</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> iter)</td></tr>
<tr class="memdesc:a002118c0ab4d78234a1f7ef67e9edec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element pointed by the iterator P1  <a href="#a002118c0ab4d78234a1f7ef67e9edec7">More...</a><br/></td></tr>
<tr class="separator:a002118c0ab4d78234a1f7ef67e9edec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42ac770e3ba0e65e372d8948ef789c6"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ad42ac770e3ba0e65e372d8948ef789c6">erase</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> first_it, <a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> last_it)</td></tr>
<tr class="memdesc:ad42ac770e3ba0e65e372d8948ef789c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase a range of elements between first_it and last_it  <a href="#ad42ac770e3ba0e65e372d8948ef789c6">More...</a><br/></td></tr>
<tr class="separator:ad42ac770e3ba0e65e372d8948ef789c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67bdfff679d2a63b605127a5c580b0cd"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a67bdfff679d2a63b605127a5c580b0cd">erase_if</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> first_it, <a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> last_it, std::function&lt; bool(const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a> &amp;)&gt; M1)</td></tr>
<tr class="memdesc:a67bdfff679d2a63b605127a5c580b0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase a range of elements between first_it and last_it  <a href="#a67bdfff679d2a63b605127a5c580b0cd">More...</a><br/></td></tr>
<tr class="separator:a67bdfff679d2a63b605127a5c580b0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab695f9b76bde4e0c186c6daea814db79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ab695f9b76bde4e0c186c6daea814db79">erase_pos</a> (signed_type Pos)</td></tr>
<tr class="memdesc:ab695f9b76bde4e0c186c6daea814db79"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element of the position pos  <a href="#ab695f9b76bde4e0c186c6daea814db79">More...</a><br/></td></tr>
<tr class="separator:ab695f9b76bde4e0c186c6daea814db79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6062e679e2dbe5b3b3c796425270eef5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a6062e679e2dbe5b3b3c796425270eef5">erase_pos</a> (signed_type First, signed_type NElem)</td></tr>
<tr class="memdesc:a6062e679e2dbe5b3b3c796425270eef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the NElem elements after the position First  <a href="#a6062e679e2dbe5b3b3c796425270eef5">More...</a><br/></td></tr>
<tr class="separator:a6062e679e2dbe5b3b3c796425270eef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8cdd46d92134eee99ad5b4bccc1e7f"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9a8cdd46d92134eee99ad5b4bccc1e7f">erase_pos_if</a> (signed_type First, signed_type NElem, std::function&lt; bool(const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a> &amp;)&gt; M)</td></tr>
<tr class="memdesc:a9a8cdd46d92134eee99ad5b4bccc1e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the NElem elements after the position First if the function M return true when receives the element as parameter  <a href="#a9a8cdd46d92134eee99ad5b4bccc1e7f">More...</a><br/></td></tr>
<tr class="separator:a9a8cdd46d92134eee99ad5b4bccc1e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77b98286518044aa308df251a92a002"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#af77b98286518044aa308df251a92a002">allocate</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#af62e7d9749b95b2cfe4aa45a1ba09d3a">size_type</a> cnt, <a class="el" href="classcountertree_1_1forest_1_1tree.html#ae144854364603d19a93bb62772b7829f">const_pointer</a>=NULL)</td></tr>
<tr class="memdesc:af77b98286518044aa308df251a92a002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of memory.  <a href="#af77b98286518044aa308df251a92a002">More...</a><br/></td></tr>
<tr class="separator:af77b98286518044aa308df251a92a002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40b57e86afe1afdfc0446453b9729c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ab40b57e86afe1afdfc0446453b9729c2">deallocate</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *p, <a class="el" href="classcountertree_1_1forest_1_1tree.html#af62e7d9749b95b2cfe4aa45a1ba09d3a">size_type</a> n=1)</td></tr>
<tr class="memdesc:ab40b57e86afe1afdfc0446453b9729c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">deallocate a block of memory  <a href="#ab40b57e86afe1afdfc0446453b9729c2">More...</a><br/></td></tr>
<tr class="separator:ab40b57e86afe1afdfc0446453b9729c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5473eaafaf2ed065f9ca81594df809a"><td class="memTemplParams" colspan="2">template&lt;typename P , typename... Args&gt; </td></tr>
<tr class="memitem:ac5473eaafaf2ed065f9ca81594df809a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ac5473eaafaf2ed065f9ca81594df809a">construct</a> (P *p, Args &amp;&amp;...args) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ac5473eaafaf2ed065f9ca81594df809a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new object in the memory pointed by p.  <a href="#ac5473eaafaf2ed065f9ca81594df809a">More...</a><br/></td></tr>
<tr class="separator:ac5473eaafaf2ed065f9ca81594df809a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53eda17aba0a507e068a19ee2d7d9a04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a53eda17aba0a507e068a19ee2d7d9a04">destroy</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *p) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a53eda17aba0a507e068a19ee2d7d9a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">destroy the object without freeing the memory  <a href="#a53eda17aba0a507e068a19ee2d7d9a04">More...</a><br/></td></tr>
<tr class="separator:a53eda17aba0a507e068a19ee2d7d9a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2c069799ce4d28d198e3c5a5650370"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a0c2c069799ce4d28d198e3c5a5650370">get_root</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a0c2c069799ce4d28d198e3c5a5650370"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a pointer to the root node of the tree  <a href="#a0c2c069799ce4d28d198e3c5a5650370">More...</a><br/></td></tr>
<tr class="separator:a0c2c069799ce4d28d198e3c5a5650370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4285ace1fd6d72b3f2292694260bbcc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a4285ace1fd6d72b3f2292694260bbcc6">upgrade</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *P) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a4285ace1fd6d72b3f2292694260bbcc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="structcountertree_1_1forest_1_1base__node.html" title="This class represent a node of the tree.">base_node</a> pointer in a node_t&lt;T&gt; pointer.  <a href="#a4285ace1fd6d72b3f2292694260bbcc6">More...</a><br/></td></tr>
<tr class="separator:a4285ace1fd6d72b3f2292694260bbcc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69fb7d316396c445b31884bfdf959ab"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ac69fb7d316396c445b31884bfdf959ab">upgrade</a> (const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *P) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ac69fb7d316396c445b31884bfdf959ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="structcountertree_1_1forest_1_1base__node.html" title="This class represent a node of the tree.">base_node</a> pointer in a node_t&lt;T&gt; pointer.  <a href="#ac69fb7d316396c445b31884bfdf959ab">More...</a><br/></td></tr>
<tr class="separator:ac69fb7d316396c445b31884bfdf959ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96554b66b6835fe489172288495c740c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a96554b66b6835fe489172288495c740c">ptr_pos</a> (signed_type Pos) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a96554b66b6835fe489172288495c740c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the node Pos.  <a href="#a96554b66b6835fe489172288495c740c">More...</a><br/></td></tr>
<tr class="separator:a96554b66b6835fe489172288495c740c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878b5522c9d73fdd45804a476ae97906"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a878b5522c9d73fdd45804a476ae97906">ptr_pos</a> (signed_type Pos) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a878b5522c9d73fdd45804a476ae97906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the node Pos.  <a href="#a878b5522c9d73fdd45804a476ae97906">More...</a><br/></td></tr>
<tr class="separator:a878b5522c9d73fdd45804a476ae97906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0525ab48d94e9a0882ca4fe1379e63b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ae0525ab48d94e9a0882ca4fe1379e63b">ptr_first</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ae0525ab48d94e9a0882ca4fe1379e63b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the first element of the tree.  <a href="#ae0525ab48d94e9a0882ca4fe1379e63b">More...</a><br/></td></tr>
<tr class="separator:ae0525ab48d94e9a0882ca4fe1379e63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079ef0b19dfc590a09e327327b6812ed"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a079ef0b19dfc590a09e327327b6812ed">ptr_first</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a079ef0b19dfc590a09e327327b6812ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the first element of the tree.  <a href="#a079ef0b19dfc590a09e327327b6812ed">More...</a><br/></td></tr>
<tr class="separator:a079ef0b19dfc590a09e327327b6812ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8b20da009c9fe4faabbe7b5e39ba2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afa8b20da009c9fe4faabbe7b5e39ba2d">ptr_last</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:afa8b20da009c9fe4faabbe7b5e39ba2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the last element of the tree.  <a href="#afa8b20da009c9fe4faabbe7b5e39ba2d">More...</a><br/></td></tr>
<tr class="separator:afa8b20da009c9fe4faabbe7b5e39ba2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7d996ec13c36822321ed783b7a55ee"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a0c7d996ec13c36822321ed783b7a55ee">ptr_last</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a0c7d996ec13c36822321ed783b7a55ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the first element of the tree.  <a href="#a0c7d996ec13c36822321ed783b7a55ee">More...</a><br/></td></tr>
<tr class="separator:a0c7d996ec13c36822321ed783b7a55ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6bf2459dcbe2b153c04b6b9ee3bc52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a8b6bf2459dcbe2b153c04b6b9ee3bc52">insert_first_pointer</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *PAux) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a8b6bf2459dcbe2b153c04b6b9ee3bc52"><td class="mdescLeft">&#160;</td><td class="mdescRight">insertion with the node_t constructed  <a href="#a8b6bf2459dcbe2b153c04b6b9ee3bc52">More...</a><br/></td></tr>
<tr class="separator:a8b6bf2459dcbe2b153c04b6b9ee3bc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821930cba3d045f10d492dbcb3bcd3bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a821930cba3d045f10d492dbcb3bcd3bd">disconnect</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *PAux) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a821930cba3d045f10d492dbcb3bcd3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">disconnect the node_t from the tree, and leave it balanced and with the nodes actualized  <a href="#a821930cba3d045f10d492dbcb3bcd3bd">More...</a><br/></td></tr>
<tr class="separator:a821930cba3d045f10d492dbcb3bcd3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bb57d7cb2d740a83b8faa11507df10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ac8bb57d7cb2d740a83b8faa11507df10">connect</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *PAux, <a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a> C) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ac8bb57d7cb2d740a83b8faa11507df10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a node_t in the tree and make a rebalanced if necessary.  <a href="#ac8bb57d7cb2d740a83b8faa11507df10">More...</a><br/></td></tr>
<tr class="separator:ac8bb57d7cb2d740a83b8faa11507df10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502ebddefca7d7eeae546dff1eed691b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a502ebddefca7d7eeae546dff1eed691b">is_mine</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> P1) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a502ebddefca7d7eeae546dff1eed691b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the iterator is pointing to this tree.  <a href="#a502ebddefca7d7eeae546dff1eed691b">More...</a><br/></td></tr>
<tr class="separator:a502ebddefca7d7eeae546dff1eed691b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad153d98fdb6bf14da4f5d26ad44525"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a2ad153d98fdb6bf14da4f5d26ad44525">is_mine</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a> P1) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a2ad153d98fdb6bf14da4f5d26ad44525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the iterator is pointing to this tree.  <a href="#a2ad153d98fdb6bf14da4f5d26ad44525">More...</a><br/></td></tr>
<tr class="separator:a2ad153d98fdb6bf14da4f5d26ad44525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd13bd08bcd67f24c6190d3b4df5da36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#abd13bd08bcd67f24c6190d3b4df5da36">iterator_pos</a> (signed_type Pos1) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:abd13bd08bcd67f24c6190d3b4df5da36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a position in the tree.  <a href="#abd13bd08bcd67f24c6190d3b4df5da36">More...</a><br/></td></tr>
<tr class="separator:abd13bd08bcd67f24c6190d3b4df5da36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cacdcc8835acbca0a56472b2cf91402"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a6cacdcc8835acbca0a56472b2cf91402">const_iterator_pos</a> (signed_type Pos1) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a6cacdcc8835acbca0a56472b2cf91402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a position in the tree.  <a href="#a6cacdcc8835acbca0a56472b2cf91402">More...</a><br/></td></tr>
<tr class="separator:a6cacdcc8835acbca0a56472b2cf91402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f15957ac496a2c60e10a7c9c2550809"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a4f15957ac496a2c60e10a7c9c2550809">get_it</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *P1)</td></tr>
<tr class="memdesc:a4f15957ac496a2c60e10a7c9c2550809"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an iterator from a node pointer  <a href="#a4f15957ac496a2c60e10a7c9c2550809">More...</a><br/></td></tr>
<tr class="separator:a4f15957ac496a2c60e10a7c9c2550809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73bbbdb50ec910fe6eeff0d6ac45de5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aa73bbbdb50ec910fe6eeff0d6ac45de5">get_cit</a> (const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *P1)</td></tr>
<tr class="memdesc:aa73bbbdb50ec910fe6eeff0d6ac45de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> from a node pointer  <a href="#aa73bbbdb50ec910fe6eeff0d6ac45de5">More...</a><br/></td></tr>
<tr class="separator:aa73bbbdb50ec910fe6eeff0d6ac45de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66d21f7d8f9b30430d6b0b804a22977"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ae66d21f7d8f9b30430d6b0b804a22977">get_rit</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *P1)</td></tr>
<tr class="memdesc:ae66d21f7d8f9b30430d6b0b804a22977"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an <a class="el" href="classcountertree_1_1forest_1_1reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">reverse_iterator</a> from a node pointer  <a href="#ae66d21f7d8f9b30430d6b0b804a22977">More...</a><br/></td></tr>
<tr class="separator:ae66d21f7d8f9b30430d6b0b804a22977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c66e015c1a9e928ed67a3c00879f15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a00c66e015c1a9e928ed67a3c00879f15">get_crit</a> (const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *P1)</td></tr>
<tr class="memdesc:a00c66e015c1a9e928ed67a3c00879f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an const_ireverse_terator from a node pointer  <a href="#a00c66e015c1a9e928ed67a3c00879f15">More...</a><br/></td></tr>
<tr class="separator:a00c66e015c1a9e928ed67a3c00879f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7623bbdeee1771ecbf32397d1612ed84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a7623bbdeee1771ecbf32397d1612ed84">upgrade</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> CT)</td></tr>
<tr class="memdesc:a7623bbdeee1771ecbf32397d1612ed84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to an iterator.  <a href="#a7623bbdeee1771ecbf32397d1612ed84">More...</a><br/></td></tr>
<tr class="separator:a7623bbdeee1771ecbf32397d1612ed84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e1400097be709a2cb9711f1184bd7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a75e1400097be709a2cb9711f1184bd7f">it_begin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a75e1400097be709a2cb9711f1184bd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ebc841308d56fdc08c58c0c2241d53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a07ebc841308d56fdc08c58c0c2241d53">begin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a07ebc841308d56fdc08c58c0c2241d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8831384e9598e3b3db862b525fe89997"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a8831384e9598e3b3db862b525fe89997">it_end</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a8831384e9598e3b3db862b525fe89997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2956e28620ef156ff265fe2e4663c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a4f2956e28620ef156ff265fe2e4663c2">end</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a4f2956e28620ef156ff265fe2e4663c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1420d4591feb5afdb255c2e2a20c2f74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a1420d4591feb5afdb255c2e2a20c2f74">it_rbegin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a1420d4591feb5afdb255c2e2a20c2f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e9a1ebd6bade9b0126ce4a8d2cf7bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ae9e9a1ebd6bade9b0126ce4a8d2cf7bf">it_rend</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ae9e9a1ebd6bade9b0126ce4a8d2cf7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585976fa9e6bc9e29a178080af99600a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a585976fa9e6bc9e29a178080af99600a">cit_begin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a585976fa9e6bc9e29a178080af99600a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de37fe37a9518b9d48f23e2c401e45c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a8de37fe37a9518b9d48f23e2c401e45c">begin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a8de37fe37a9518b9d48f23e2c401e45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64de10716c9eb71703d168307b107511"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a64de10716c9eb71703d168307b107511">cbegin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a64de10716c9eb71703d168307b107511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3343bbb836d48f0a35b1bc24e2e694"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#abc3343bbb836d48f0a35b1bc24e2e694">cit_end</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:abc3343bbb836d48f0a35b1bc24e2e694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29514d34e57ac6e224ea48ac77385888"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a29514d34e57ac6e224ea48ac77385888">end</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a29514d34e57ac6e224ea48ac77385888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d5d2081d731634553165ce6ab83a73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aa9d5d2081d731634553165ce6ab83a73">cend</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aa9d5d2081d731634553165ce6ab83a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b71d987c8ef2a21de10c9aa3ba9fd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ae5b71d987c8ef2a21de10c9aa3ba9fd8">cit_rbegin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ae5b71d987c8ef2a21de10c9aa3ba9fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afadf8db5ba400fb6789b0c7a2a916c3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afadf8db5ba400fb6789b0c7a2a916c3c">cit_rend</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:afadf8db5ba400fb6789b0c7a2a916c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2dd65f17137aa95b0e275a7a97f42da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ae2dd65f17137aa95b0e275a7a97f42da">rit_begin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ae2dd65f17137aa95b0e275a7a97f42da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7057dd5675969ab0a252f688d40648"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a4f7057dd5675969ab0a252f688d40648">rit_end</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a4f7057dd5675969ab0a252f688d40648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19e1a75340c3cf04a7cbd8b974bb49e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ab19e1a75340c3cf04a7cbd8b974bb49e">rit_rbegin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ab19e1a75340c3cf04a7cbd8b974bb49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2c944b0ea0db0259c5971cfd8705a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaa2c944b0ea0db0259c5971cfd8705a8">rbegin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aaa2c944b0ea0db0259c5971cfd8705a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae363d31e77fd362e04c332789a54e3d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ae363d31e77fd362e04c332789a54e3d7">rit_rend</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ae363d31e77fd362e04c332789a54e3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6acc1f3a4669a18c5a43c7adf8b4e606"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a6acc1f3a4669a18c5a43c7adf8b4e606">rend</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a6acc1f3a4669a18c5a43c7adf8b4e606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b010541a31187bff3bd7508555cd114"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a0b010541a31187bff3bd7508555cd114">crit_begin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a0b010541a31187bff3bd7508555cd114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095625170f5535e7c08a0d8b00ffe000"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a095625170f5535e7c08a0d8b00ffe000">crit_end</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a095625170f5535e7c08a0d8b00ffe000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51190279d6ee4c788e5d678bd8dc1f6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a51190279d6ee4c788e5d678bd8dc1f6c">crit_rbegin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a51190279d6ee4c788e5d678bd8dc1f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedc0445c58c5d96b967de39cc957b8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aeedc0445c58c5d96b967de39cc957b8a">rbegin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aeedc0445c58c5d96b967de39cc957b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293a514e0f71684097a968f7c38cb7c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a293a514e0f71684097a968f7c38cb7c5">crbegin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a293a514e0f71684097a968f7c38cb7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa377cbceaf27aab4e2d57354ffaa5564"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aa377cbceaf27aab4e2d57354ffaa5564">crit_rend</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aa377cbceaf27aab4e2d57354ffaa5564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6842f5c4dcb47a3bd3451077010f12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aed6842f5c4dcb47a3bd3451077010f12">rend</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aed6842f5c4dcb47a3bd3451077010f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35bc47414f84b4b3e2b71fe1f212655"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aa35bc47414f84b4b3e2b71fe1f212655">crend</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aa35bc47414f84b4b3e2b71fe1f212655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41af4bbb3350157359fae9d436fbf15"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#af41af4bbb3350157359fae9d436fbf15">tree</a> (const node_alloc_t &amp;na=node_alloc_t()) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:af41af4bbb3350157359fae9d436fbf15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#af41af4bbb3350157359fae9d436fbf15">More...</a><br/></td></tr>
<tr class="separator:af41af4bbb3350157359fae9d436fbf15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6af85e6039f03999116f18cc339c88e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ad6af85e6039f03999116f18cc339c88e">tree</a> (const <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &amp;T)</td></tr>
<tr class="memdesc:ad6af85e6039f03999116f18cc339c88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="#ad6af85e6039f03999116f18cc339c88e">More...</a><br/></td></tr>
<tr class="separator:ad6af85e6039f03999116f18cc339c88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0496ac3428b1779641ff8f1e070e5544"><td class="memTemplParams" colspan="2">template&lt;typename node_alloc2_t &gt; </td></tr>
<tr class="memitem:a0496ac3428b1779641ff8f1e070e5544"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a0496ac3428b1779641ff8f1e070e5544">tree</a> (const <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc2_t &gt; &amp;T)</td></tr>
<tr class="memdesc:a0496ac3428b1779641ff8f1e070e5544"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="#a0496ac3428b1779641ff8f1e070e5544">More...</a><br/></td></tr>
<tr class="separator:a0496ac3428b1779641ff8f1e070e5544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7444654225a13f25d012082dbcc9f8c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a7444654225a13f25d012082dbcc9f8c4">tree</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &amp;&amp;B) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a7444654225a13f25d012082dbcc9f8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor from a rvalue  <a href="#a7444654225a13f25d012082dbcc9f8c4">More...</a><br/></td></tr>
<tr class="separator:a7444654225a13f25d012082dbcc9f8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041a21a93b897c3801df3e4eccdc4eee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a041a21a93b897c3801df3e4eccdc4eee">~tree</a> (void)</td></tr>
<tr class="memdesc:a041a21a93b897c3801df3e4eccdc4eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a041a21a93b897c3801df3e4eccdc4eee">More...</a><br/></td></tr>
<tr class="separator:a041a21a93b897c3801df3e4eccdc4eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b378740b11d56aef8048904223d948"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a59b378740b11d56aef8048904223d948">operator=</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &amp;&amp;B)</td></tr>
<tr class="memdesc:a59b378740b11d56aef8048904223d948"><td class="mdescLeft">&#160;</td><td class="mdescRight">asignation operator  <a href="#a59b378740b11d56aef8048904223d948">More...</a><br/></td></tr>
<tr class="separator:a59b378740b11d56aef8048904223d948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0655366212ee0c410f0c2d6d5b5f4636"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a0655366212ee0c410f0c2d6d5b5f4636">operator=</a> (const <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &amp;T)</td></tr>
<tr class="memdesc:a0655366212ee0c410f0c2d6d5b5f4636"><td class="mdescLeft">&#160;</td><td class="mdescRight">asignation operator  <a href="#a0655366212ee0c410f0c2d6d5b5f4636">More...</a><br/></td></tr>
<tr class="separator:a0655366212ee0c410f0c2d6d5b5f4636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31f5b80c9cc8c030ee5f2e65835ee60"><td class="memTemplParams" colspan="2">template&lt;typename node_alloc2_t &gt; </td></tr>
<tr class="memitem:ac31f5b80c9cc8c030ee5f2e65835ee60"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ac31f5b80c9cc8c030ee5f2e65835ee60">operator=</a> (const <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc2_t &gt; &amp;T)</td></tr>
<tr class="memdesc:ac31f5b80c9cc8c030ee5f2e65835ee60"><td class="mdescLeft">&#160;</td><td class="mdescRight">asignation operator  <a href="#ac31f5b80c9cc8c030ee5f2e65835ee60">More...</a><br/></td></tr>
<tr class="separator:ac31f5b80c9cc8c030ee5f2e65835ee60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52b102e4d25507f79e6b2fda89fb709"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:aa52b102e4d25507f79e6b2fda89fb709"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aa52b102e4d25507f79e6b2fda89fb709">assign</a> (InputIterator it_first, InputIterator it_last)</td></tr>
<tr class="memdesc:aa52b102e4d25507f79e6b2fda89fb709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a range of data, dropping all the elements of the container. It's like the assignation operator but with several parameters.  <a href="#aa52b102e4d25507f79e6b2fda89fb709">More...</a><br/></td></tr>
<tr class="separator:aa52b102e4d25507f79e6b2fda89fb709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa729073df47102d44b6b59794dba22ef"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:aa729073df47102d44b6b59794dba22ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aa729073df47102d44b6b59794dba22ef">assign_if</a> (InputIterator it_first, InputIterator it_last, std::function&lt; bool(const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a> &amp;)&gt; M)</td></tr>
<tr class="memdesc:aa729073df47102d44b6b59794dba22ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a range of data, dropping all the elements of the container It's like the assignation operator but with several parameters.  <a href="#aa729073df47102d44b6b59794dba22ef">More...</a><br/></td></tr>
<tr class="separator:aa729073df47102d44b6b59794dba22ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91eea9e1c59f9e2fa1cb3be20a95e7d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a91eea9e1c59f9e2fa1cb3be20a95e7d0">assign</a> (unsigned_type n, const value_t &amp;u)</td></tr>
<tr class="memdesc:a91eea9e1c59f9e2fa1cb3be20a95e7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a range of data, dropping all the elements of the container It's like the assignation operator but with several parameters.  <a href="#a91eea9e1c59f9e2fa1cb3be20a95e7d0">More...</a><br/></td></tr>
<tr class="separator:a91eea9e1c59f9e2fa1cb3be20a95e7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0364e03d69ee50e529f48c251b4cb2"><td class="memTemplParams" colspan="2">template&lt;typename node_alloc_t2 &gt; </td></tr>
<tr class="memitem:aac0364e03d69ee50e529f48c251b4cb2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aac0364e03d69ee50e529f48c251b4cb2">copy</a> (const <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc_t2 &gt; &amp;T)</td></tr>
<tr class="memdesc:aac0364e03d69ee50e529f48c251b4cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asignation operator.  <a href="#aac0364e03d69ee50e529f48c251b4cb2">More...</a><br/></td></tr>
<tr class="separator:aac0364e03d69ee50e529f48c251b4cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcce84e57f78847c0ce82d594dd343ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#abcce84e57f78847c0ce82d594dd343ca">clear</a> (void)</td></tr>
<tr class="memdesc:abcce84e57f78847c0ce82d594dd343ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all the elements of the tree.  <a href="#abcce84e57f78847c0ce82d594dd343ca">More...</a><br/></td></tr>
<tr class="separator:abcce84e57f78847c0ce82d594dd343ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5c1b8c253c34b6b20e13bfdf13f1c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a7c5c1b8c253c34b6b20e13bfdf13f1c4">move</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &amp;&amp;B)</td></tr>
<tr class="memdesc:a7c5c1b8c253c34b6b20e13bfdf13f1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move all the elements of the tree.  <a href="#a7c5c1b8c253c34b6b20e13bfdf13f1c4">More...</a><br/></td></tr>
<tr class="separator:a7c5c1b8c253c34b6b20e13bfdf13f1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f136d59a898e0939dfefaab159c6770"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a1f136d59a898e0939dfefaab159c6770">resize</a> (signed_type sz, value_t c=value_t())</td></tr>
<tr class="memdesc:a1f136d59a898e0939dfefaab159c6770"><td class="mdescLeft">&#160;</td><td class="mdescRight">resize the current vector size and change to sz.<br/>
 If sz is smaller than the current size, delete elements to end<br/>
 If sz is greater than the current size, insert elements to the end with the value c  <a href="#a1f136d59a898e0939dfefaab159c6770">More...</a><br/></td></tr>
<tr class="separator:a1f136d59a898e0939dfefaab159c6770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47b86c89cfdef7ebf92f4ba7fdbb342"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ac47b86c89cfdef7ebf92f4ba7fdbb342">swap</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &amp;B)</td></tr>
<tr class="memdesc:ac47b86c89cfdef7ebf92f4ba7fdbb342"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap two trees  <a href="#ac47b86c89cfdef7ebf92f4ba7fdbb342">More...</a><br/></td></tr>
<tr class="separator:ac47b86c89cfdef7ebf92f4ba7fdbb342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77b98286518044aa308df251a92a002"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#af77b98286518044aa308df251a92a002">allocate</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#af62e7d9749b95b2cfe4aa45a1ba09d3a">size_type</a> cnt, <a class="el" href="classcountertree_1_1forest_1_1tree.html#ae144854364603d19a93bb62772b7829f">const_pointer</a>=NULL)</td></tr>
<tr class="memdesc:af77b98286518044aa308df251a92a002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of memory.  <a href="#af77b98286518044aa308df251a92a002">More...</a><br/></td></tr>
<tr class="separator:af77b98286518044aa308df251a92a002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40b57e86afe1afdfc0446453b9729c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ab40b57e86afe1afdfc0446453b9729c2">deallocate</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *p, <a class="el" href="classcountertree_1_1forest_1_1tree.html#af62e7d9749b95b2cfe4aa45a1ba09d3a">size_type</a> n=1)</td></tr>
<tr class="memdesc:ab40b57e86afe1afdfc0446453b9729c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">deallocate a block of memory  <a href="#ab40b57e86afe1afdfc0446453b9729c2">More...</a><br/></td></tr>
<tr class="separator:ab40b57e86afe1afdfc0446453b9729c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cede3f544c96075bd5158a26402944"><td class="memTemplParams" colspan="2">template&lt;typename U , typename... Args&gt; </td></tr>
<tr class="memitem:ae7cede3f544c96075bd5158a26402944"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ae7cede3f544c96075bd5158a26402944">construct</a> (U *p, Args &amp;&amp;...args) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ae7cede3f544c96075bd5158a26402944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new object in the memory pointed by p.  <a href="#ae7cede3f544c96075bd5158a26402944">More...</a><br/></td></tr>
<tr class="separator:ae7cede3f544c96075bd5158a26402944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ef46cebff0505517eeb668f730dfdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a76ef46cebff0505517eeb668f730dfdf">destroy</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#a4d55dcff9a6d6007b9cd7c626587a7fd">pointer</a> p) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a76ef46cebff0505517eeb668f730dfdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">destroy the object without freeing the memory  <a href="#a76ef46cebff0505517eeb668f730dfdf">More...</a><br/></td></tr>
<tr class="separator:a76ef46cebff0505517eeb668f730dfdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22fde787e169da53de580084e807504"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ae22fde787e169da53de580084e807504">capacity</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ae22fde787e169da53de580084e807504"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the maximun size of the container  <a href="#ae22fde787e169da53de580084e807504">More...</a><br/></td></tr>
<tr class="separator:ae22fde787e169da53de580084e807504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd2aa4e71c2c1f0290e8c646733f095"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#abdd2aa4e71c2c1f0290e8c646733f095">empty</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:abdd2aa4e71c2c1f0290e8c646733f095"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicate if the map is empty  <a href="#abdd2aa4e71c2c1f0290e8c646733f095">More...</a><br/></td></tr>
<tr class="separator:abdd2aa4e71c2c1f0290e8c646733f095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d24357cdfa2bf62304d052d3219052b"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a8d24357cdfa2bf62304d052d3219052b">size</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a8d24357cdfa2bf62304d052d3219052b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of elements in the tree  <a href="#a8d24357cdfa2bf62304d052d3219052b">More...</a><br/></td></tr>
<tr class="separator:a8d24357cdfa2bf62304d052d3219052b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78c5519cee9daa25467e405245bc75d"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aa78c5519cee9daa25467e405245bc75d">levels</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:aa78c5519cee9daa25467e405245bc75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of levels in the tree  <a href="#aa78c5519cee9daa25467e405245bc75d">More...</a><br/></td></tr>
<tr class="separator:aa78c5519cee9daa25467e405245bc75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab605ce8fdc6e488db4caaebbad5477b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ab605ce8fdc6e488db4caaebbad5477b4">get_root</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ab605ce8fdc6e488db4caaebbad5477b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the node pointer to the root of the tree  <a href="#ab605ce8fdc6e488db4caaebbad5477b4">More...</a><br/></td></tr>
<tr class="separator:ab605ce8fdc6e488db4caaebbad5477b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d4988256cd1729077f81cc417c384e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a34d4988256cd1729077f81cc417c384e">get_first</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a34d4988256cd1729077f81cc417c384e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the first pointer to the root of the tree  <a href="#a34d4988256cd1729077f81cc417c384e">More...</a><br/></td></tr>
<tr class="separator:a34d4988256cd1729077f81cc417c384e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa26eac4a30066522594ae421fcab3d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afa26eac4a30066522594ae421fcab3d7">get_last</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:afa26eac4a30066522594ae421fcab3d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the node pointer to the last of the tree  <a href="#afa26eac4a30066522594ae421fcab3d7">More...</a><br/></td></tr>
<tr class="separator:afa26eac4a30066522594ae421fcab3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502ebddefca7d7eeae546dff1eed691b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a502ebddefca7d7eeae546dff1eed691b">is_mine</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> P1) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a502ebddefca7d7eeae546dff1eed691b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the iterator is pointing to this tree.  <a href="#a502ebddefca7d7eeae546dff1eed691b">More...</a><br/></td></tr>
<tr class="separator:a502ebddefca7d7eeae546dff1eed691b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad153d98fdb6bf14da4f5d26ad44525"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a2ad153d98fdb6bf14da4f5d26ad44525">is_mine</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a> P1) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a2ad153d98fdb6bf14da4f5d26ad44525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the iterator is pointing to this tree.  <a href="#a2ad153d98fdb6bf14da4f5d26ad44525">More...</a><br/></td></tr>
<tr class="separator:a2ad153d98fdb6bf14da4f5d26ad44525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd13bd08bcd67f24c6190d3b4df5da36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#abd13bd08bcd67f24c6190d3b4df5da36">iterator_pos</a> (signed_type Pos1) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:abd13bd08bcd67f24c6190d3b4df5da36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a position in the tree.  <a href="#abd13bd08bcd67f24c6190d3b4df5da36">More...</a><br/></td></tr>
<tr class="separator:abd13bd08bcd67f24c6190d3b4df5da36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cacdcc8835acbca0a56472b2cf91402"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a6cacdcc8835acbca0a56472b2cf91402">const_iterator_pos</a> (signed_type Pos1) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a6cacdcc8835acbca0a56472b2cf91402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a position in the tree.  <a href="#a6cacdcc8835acbca0a56472b2cf91402">More...</a><br/></td></tr>
<tr class="separator:a6cacdcc8835acbca0a56472b2cf91402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b5b7d9ef2aaf730eac5504b96a6b9b"><td class="memItemLeft" align="right" valign="top">value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a59b5b7d9ef2aaf730eac5504b96a6b9b">operator[]</a> (signed_type Pos) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a59b5b7d9ef2aaf730eac5504b96a6b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked access to an element by their position in the tree.  <a href="#a59b5b7d9ef2aaf730eac5504b96a6b9b">More...</a><br/></td></tr>
<tr class="separator:a59b5b7d9ef2aaf730eac5504b96a6b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8cf30165ce6d0f883b4a6371ae0020"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a6c8cf30165ce6d0f883b4a6371ae0020">operator[]</a> (signed_type Pos) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a6c8cf30165ce6d0f883b4a6371ae0020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked access to an element by their position in the tree.  <a href="#a6c8cf30165ce6d0f883b4a6371ae0020">More...</a><br/></td></tr>
<tr class="separator:a6c8cf30165ce6d0f883b4a6371ae0020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a2ecda1f0f645054f1623e09463d32"><td class="memItemLeft" align="right" valign="top">value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ac5a2ecda1f0f645054f1623e09463d32">front</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ac5a2ecda1f0f645054f1623e09463d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the first element in the tree.  <a href="#ac5a2ecda1f0f645054f1623e09463d32">More...</a><br/></td></tr>
<tr class="separator:ac5a2ecda1f0f645054f1623e09463d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f5d958d85b20a68550a081bd4888d0"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a08f5d958d85b20a68550a081bd4888d0">front</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a08f5d958d85b20a68550a081bd4888d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const_reference to the first element in the tree.  <a href="#a08f5d958d85b20a68550a081bd4888d0">More...</a><br/></td></tr>
<tr class="separator:a08f5d958d85b20a68550a081bd4888d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fa69d33c09fb437646bc4b3b95e9e9"><td class="memItemLeft" align="right" valign="top">value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a17fa69d33c09fb437646bc4b3b95e9e9">back</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a17fa69d33c09fb437646bc4b3b95e9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the last element in the tree.  <a href="#a17fa69d33c09fb437646bc4b3b95e9e9">More...</a><br/></td></tr>
<tr class="separator:a17fa69d33c09fb437646bc4b3b95e9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586cc0895021be77105d23b91ad12506"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a586cc0895021be77105d23b91ad12506">back</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a586cc0895021be77105d23b91ad12506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const_reference to the last element in the tree.  <a href="#a586cc0895021be77105d23b91ad12506">More...</a><br/></td></tr>
<tr class="separator:a586cc0895021be77105d23b91ad12506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc67872c42d995e8ec7359a3b97a2d7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#acc67872c42d995e8ec7359a3b97a2d7b">push_front</a> (const value_t &amp;D)</td></tr>
<tr class="memdesc:acc67872c42d995e8ec7359a3b97a2d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in the front of the container  <a href="#acc67872c42d995e8ec7359a3b97a2d7b">More...</a><br/></td></tr>
<tr class="separator:acc67872c42d995e8ec7359a3b97a2d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c756e10c6733e2cf85068b8e8f72fcb"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a4c756e10c6733e2cf85068b8e8f72fcb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a4c756e10c6733e2cf85068b8e8f72fcb">emplace_front</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a4c756e10c6733e2cf85068b8e8f72fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in the front of the container  <a href="#a4c756e10c6733e2cf85068b8e8f72fcb">More...</a><br/></td></tr>
<tr class="separator:a4c756e10c6733e2cf85068b8e8f72fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894bae031f46f46cfeffcb763397bd10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a894bae031f46f46cfeffcb763397bd10">push_back</a> (const value_t &amp;D)</td></tr>
<tr class="memdesc:a894bae031f46f46cfeffcb763397bd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert one element in the back of the container.  <a href="#a894bae031f46f46cfeffcb763397bd10">More...</a><br/></td></tr>
<tr class="separator:a894bae031f46f46cfeffcb763397bd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace37599ccc53ed3d56834aec90802adf"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ace37599ccc53ed3d56834aec90802adf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ace37599ccc53ed3d56834aec90802adf">emplace_back</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ace37599ccc53ed3d56834aec90802adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert one element in the back of the container.  <a href="#ace37599ccc53ed3d56834aec90802adf">More...</a><br/></td></tr>
<tr class="separator:ace37599ccc53ed3d56834aec90802adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf18eef5461f0da8060e29bfffed8d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#abcf18eef5461f0da8060e29bfffed8d9">insert_pos</a> (signed_type Pos, const value_t &amp;D)</td></tr>
<tr class="memdesc:abcf18eef5461f0da8060e29bfffed8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in a specified position  <a href="#abcf18eef5461f0da8060e29bfffed8d9">More...</a><br/></td></tr>
<tr class="separator:abcf18eef5461f0da8060e29bfffed8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab89cb09b79d98f649dcdc2cf3b5a0c"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a9ab89cb09b79d98f649dcdc2cf3b5a0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9ab89cb09b79d98f649dcdc2cf3b5a0c">emplace_pos</a> (signed_type Pos, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a9ab89cb09b79d98f649dcdc2cf3b5a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in a specified position  <a href="#a9ab89cb09b79d98f649dcdc2cf3b5a0c">More...</a><br/></td></tr>
<tr class="separator:a9ab89cb09b79d98f649dcdc2cf3b5a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a36a8773e9f6b3986f20005e032f4b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a5a36a8773e9f6b3986f20005e032f4b6">insert</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> iter, const value_t &amp;D)</td></tr>
<tr class="memdesc:a5a36a8773e9f6b3986f20005e032f4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in the previous position to the pointed by the iterator  <a href="#a5a36a8773e9f6b3986f20005e032f4b6">More...</a><br/></td></tr>
<tr class="separator:a5a36a8773e9f6b3986f20005e032f4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e777d5abd68155813c760eb01618e6"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a00e777d5abd68155813c760eb01618e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a00e777d5abd68155813c760eb01618e6">emplace</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> iter, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a00e777d5abd68155813c760eb01618e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in the previous position to the pointed by the iterator  <a href="#a00e777d5abd68155813c760eb01618e6">More...</a><br/></td></tr>
<tr class="separator:a00e777d5abd68155813c760eb01618e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48a3512e1b80dcf671f8fdd3053f96c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aa48a3512e1b80dcf671f8fdd3053f96c">pop_front</a> (void)</td></tr>
<tr class="memdesc:aa48a3512e1b80dcf671f8fdd3053f96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the container  <a href="#aa48a3512e1b80dcf671f8fdd3053f96c">More...</a><br/></td></tr>
<tr class="separator:aa48a3512e1b80dcf671f8fdd3053f96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658b0b9f881138ce58d433ac00f2ffe3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a658b0b9f881138ce58d433ac00f2ffe3">pop_back</a> (void)</td></tr>
<tr class="memdesc:a658b0b9f881138ce58d433ac00f2ffe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the container  <a href="#a658b0b9f881138ce58d433ac00f2ffe3">More...</a><br/></td></tr>
<tr class="separator:a658b0b9f881138ce58d433ac00f2ffe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b988cdd28789caa420467c5f8ad5a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ae6b988cdd28789caa420467c5f8ad5a1">erase</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> iter)</td></tr>
<tr class="memdesc:ae6b988cdd28789caa420467c5f8ad5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element pointed by the iterator P1  <a href="#ae6b988cdd28789caa420467c5f8ad5a1">More...</a><br/></td></tr>
<tr class="separator:ae6b988cdd28789caa420467c5f8ad5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42ac770e3ba0e65e372d8948ef789c6"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ad42ac770e3ba0e65e372d8948ef789c6">erase</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> first_it, <a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> last_it)</td></tr>
<tr class="memdesc:ad42ac770e3ba0e65e372d8948ef789c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase a range of elements between first_it and last_it  <a href="#ad42ac770e3ba0e65e372d8948ef789c6">More...</a><br/></td></tr>
<tr class="separator:ad42ac770e3ba0e65e372d8948ef789c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67bdfff679d2a63b605127a5c580b0cd"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a67bdfff679d2a63b605127a5c580b0cd">erase_if</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> first_it, <a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> last_it, std::function&lt; bool(const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a> &amp;)&gt; M1)</td></tr>
<tr class="memdesc:a67bdfff679d2a63b605127a5c580b0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase a range of elements between first_it and last_it  <a href="#a67bdfff679d2a63b605127a5c580b0cd">More...</a><br/></td></tr>
<tr class="separator:a67bdfff679d2a63b605127a5c580b0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab695f9b76bde4e0c186c6daea814db79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ab695f9b76bde4e0c186c6daea814db79">erase_pos</a> (signed_type Pos)</td></tr>
<tr class="memdesc:ab695f9b76bde4e0c186c6daea814db79"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element of the position pos  <a href="#ab695f9b76bde4e0c186c6daea814db79">More...</a><br/></td></tr>
<tr class="separator:ab695f9b76bde4e0c186c6daea814db79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233cee698c917a67246a046acf139454"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a233cee698c917a67246a046acf139454">erase_pos_if</a> (signed_type Pos, std::function&lt; bool(const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a> &amp;)&gt; M)</td></tr>
<tr class="memdesc:a233cee698c917a67246a046acf139454"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element of the position pos  <a href="#a233cee698c917a67246a046acf139454">More...</a><br/></td></tr>
<tr class="separator:a233cee698c917a67246a046acf139454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6062e679e2dbe5b3b3c796425270eef5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a6062e679e2dbe5b3b3c796425270eef5">erase_pos</a> (signed_type First, signed_type NElem)</td></tr>
<tr class="memdesc:a6062e679e2dbe5b3b3c796425270eef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the NElem elements after the position First  <a href="#a6062e679e2dbe5b3b3c796425270eef5">More...</a><br/></td></tr>
<tr class="separator:a6062e679e2dbe5b3b3c796425270eef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8cdd46d92134eee99ad5b4bccc1e7f"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9a8cdd46d92134eee99ad5b4bccc1e7f">erase_pos_if</a> (signed_type First, signed_type NElem, std::function&lt; bool(const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a> &amp;)&gt; M)</td></tr>
<tr class="memdesc:a9a8cdd46d92134eee99ad5b4bccc1e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the NElem elements after the position First if the function M return true when receives the element as parameter  <a href="#a9a8cdd46d92134eee99ad5b4bccc1e7f">More...</a><br/></td></tr>
<tr class="separator:a9a8cdd46d92134eee99ad5b4bccc1e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e1400097be709a2cb9711f1184bd7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a75e1400097be709a2cb9711f1184bd7f">it_begin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a75e1400097be709a2cb9711f1184bd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ebc841308d56fdc08c58c0c2241d53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a07ebc841308d56fdc08c58c0c2241d53">begin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a07ebc841308d56fdc08c58c0c2241d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8831384e9598e3b3db862b525fe89997"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a8831384e9598e3b3db862b525fe89997">it_end</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a8831384e9598e3b3db862b525fe89997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2956e28620ef156ff265fe2e4663c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a4f2956e28620ef156ff265fe2e4663c2">end</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a4f2956e28620ef156ff265fe2e4663c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1420d4591feb5afdb255c2e2a20c2f74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a1420d4591feb5afdb255c2e2a20c2f74">it_rbegin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a1420d4591feb5afdb255c2e2a20c2f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e9a1ebd6bade9b0126ce4a8d2cf7bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ae9e9a1ebd6bade9b0126ce4a8d2cf7bf">it_rend</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ae9e9a1ebd6bade9b0126ce4a8d2cf7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585976fa9e6bc9e29a178080af99600a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a585976fa9e6bc9e29a178080af99600a">cit_begin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a585976fa9e6bc9e29a178080af99600a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de37fe37a9518b9d48f23e2c401e45c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a8de37fe37a9518b9d48f23e2c401e45c">begin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a8de37fe37a9518b9d48f23e2c401e45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64de10716c9eb71703d168307b107511"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a64de10716c9eb71703d168307b107511">cbegin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a64de10716c9eb71703d168307b107511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3343bbb836d48f0a35b1bc24e2e694"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#abc3343bbb836d48f0a35b1bc24e2e694">cit_end</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:abc3343bbb836d48f0a35b1bc24e2e694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29514d34e57ac6e224ea48ac77385888"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a29514d34e57ac6e224ea48ac77385888">end</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a29514d34e57ac6e224ea48ac77385888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d5d2081d731634553165ce6ab83a73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aa9d5d2081d731634553165ce6ab83a73">cend</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aa9d5d2081d731634553165ce6ab83a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b71d987c8ef2a21de10c9aa3ba9fd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ae5b71d987c8ef2a21de10c9aa3ba9fd8">cit_rbegin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ae5b71d987c8ef2a21de10c9aa3ba9fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afadf8db5ba400fb6789b0c7a2a916c3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afadf8db5ba400fb6789b0c7a2a916c3c">cit_rend</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:afadf8db5ba400fb6789b0c7a2a916c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2dd65f17137aa95b0e275a7a97f42da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ae2dd65f17137aa95b0e275a7a97f42da">rit_begin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ae2dd65f17137aa95b0e275a7a97f42da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7057dd5675969ab0a252f688d40648"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a4f7057dd5675969ab0a252f688d40648">rit_end</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a4f7057dd5675969ab0a252f688d40648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19e1a75340c3cf04a7cbd8b974bb49e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ab19e1a75340c3cf04a7cbd8b974bb49e">rit_rbegin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ab19e1a75340c3cf04a7cbd8b974bb49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2c944b0ea0db0259c5971cfd8705a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaa2c944b0ea0db0259c5971cfd8705a8">rbegin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aaa2c944b0ea0db0259c5971cfd8705a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae363d31e77fd362e04c332789a54e3d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ae363d31e77fd362e04c332789a54e3d7">rit_rend</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ae363d31e77fd362e04c332789a54e3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6acc1f3a4669a18c5a43c7adf8b4e606"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a6acc1f3a4669a18c5a43c7adf8b4e606">rend</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a6acc1f3a4669a18c5a43c7adf8b4e606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b010541a31187bff3bd7508555cd114"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a0b010541a31187bff3bd7508555cd114">crit_begin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a0b010541a31187bff3bd7508555cd114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095625170f5535e7c08a0d8b00ffe000"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a095625170f5535e7c08a0d8b00ffe000">crit_end</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a095625170f5535e7c08a0d8b00ffe000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51190279d6ee4c788e5d678bd8dc1f6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a51190279d6ee4c788e5d678bd8dc1f6c">crit_rbegin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a51190279d6ee4c788e5d678bd8dc1f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedc0445c58c5d96b967de39cc957b8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aeedc0445c58c5d96b967de39cc957b8a">rbegin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aeedc0445c58c5d96b967de39cc957b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293a514e0f71684097a968f7c38cb7c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a293a514e0f71684097a968f7c38cb7c5">crbegin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a293a514e0f71684097a968f7c38cb7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa377cbceaf27aab4e2d57354ffaa5564"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aa377cbceaf27aab4e2d57354ffaa5564">crit_rend</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aa377cbceaf27aab4e2d57354ffaa5564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6842f5c4dcb47a3bd3451077010f12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aed6842f5c4dcb47a3bd3451077010f12">rend</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aed6842f5c4dcb47a3bd3451077010f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35bc47414f84b4b3e2b71fe1f212655"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aa35bc47414f84b4b3e2b71fe1f212655">crend</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aa35bc47414f84b4b3e2b71fe1f212655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96554b66b6835fe489172288495c740c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a96554b66b6835fe489172288495c740c">ptr_pos</a> (signed_type Pos) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a96554b66b6835fe489172288495c740c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a position in the tree.  <a href="#a96554b66b6835fe489172288495c740c">More...</a><br/></td></tr>
<tr class="separator:a96554b66b6835fe489172288495c740c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878b5522c9d73fdd45804a476ae97906"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a878b5522c9d73fdd45804a476ae97906">ptr_pos</a> (signed_type Pos) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a878b5522c9d73fdd45804a476ae97906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a position in the tree.  <a href="#a878b5522c9d73fdd45804a476ae97906">More...</a><br/></td></tr>
<tr class="separator:a878b5522c9d73fdd45804a476ae97906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc73dbf477b69751305af1da1b22b630"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#adc73dbf477b69751305af1da1b22b630">connector_pos</a> (signed_type Pos) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:adc73dbf477b69751305af1da1b22b630"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the pointer and the side for to insert a new node_t in the position Pos  <a href="#adc73dbf477b69751305af1da1b22b630">More...</a><br/></td></tr>
<tr class="separator:adc73dbf477b69751305af1da1b22b630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b92b98afcfa18d52debf704c6080070"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a2b92b98afcfa18d52debf704c6080070">connector_pointer</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *Ptr) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a2b92b98afcfa18d52debf704c6080070"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the pointer and the side for to insert a new node_t before the node_t pointed by Ptr  <a href="#a2b92b98afcfa18d52debf704c6080070">More...</a><br/></td></tr>
<tr class="separator:a2b92b98afcfa18d52debf704c6080070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f84563d58fa2060ea2528331c5cf074"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a4f84563d58fa2060ea2528331c5cf074">connector_begin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a4f84563d58fa2060ea2528331c5cf074"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the connector for to insert an element in the first position of the tree  <a href="#a4f84563d58fa2060ea2528331c5cf074">More...</a><br/></td></tr>
<tr class="separator:a4f84563d58fa2060ea2528331c5cf074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6bf2459dcbe2b153c04b6b9ee3bc52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a8b6bf2459dcbe2b153c04b6b9ee3bc52">insert_first_pointer</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *PAux) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a8b6bf2459dcbe2b153c04b6b9ee3bc52"><td class="mdescLeft">&#160;</td><td class="mdescRight">insertion with the node_t constructed  <a href="#a8b6bf2459dcbe2b153c04b6b9ee3bc52">More...</a><br/></td></tr>
<tr class="separator:a8b6bf2459dcbe2b153c04b6b9ee3bc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821930cba3d045f10d492dbcb3bcd3bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a821930cba3d045f10d492dbcb3bcd3bd">disconnect</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *PAux) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a821930cba3d045f10d492dbcb3bcd3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">disconnect the node_t from the tree, and leave it balanced and with the nodes actualized  <a href="#a821930cba3d045f10d492dbcb3bcd3bd">More...</a><br/></td></tr>
<tr class="separator:a821930cba3d045f10d492dbcb3bcd3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bb57d7cb2d740a83b8faa11507df10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ac8bb57d7cb2d740a83b8faa11507df10">connect</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *PAux, <a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a> C) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ac8bb57d7cb2d740a83b8faa11507df10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a node_t in the tree and make a rebalanced if necessary.  <a href="#ac8bb57d7cb2d740a83b8faa11507df10">More...</a><br/></td></tr>
<tr class="separator:ac8bb57d7cb2d740a83b8faa11507df10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fe6b43df90524e11068cc0a8310b62"><td class="memTemplParams" colspan="2">template&lt;typename node_alloc2_t &gt; </td></tr>
<tr class="memitem:af4fe6b43df90524e11068cc0a8310b62"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#af4fe6b43df90524e11068cc0a8310b62">copy</a> (const <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc2_t &gt; &amp;T)</td></tr>
<tr class="memdesc:af4fe6b43df90524e11068cc0a8310b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy one tree in other.  <a href="#af4fe6b43df90524e11068cc0a8310b62">More...</a><br/></td></tr>
<tr class="separator:af4fe6b43df90524e11068cc0a8310b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a48c4a161d01bdae4dd757e196fac69b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a48c4a161d01bdae4dd757e196fac69b1">pointer_father</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *P) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a48c4a161d01bdae4dd757e196fac69b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a pointer to pointer to the node_t black of the branch  <a href="#a48c4a161d01bdae4dd757e196fac69b1">More...</a><br/></td></tr>
<tr class="separator:a48c4a161d01bdae4dd757e196fac69b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94acf70ed61eab5627d7646795d16860"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a94acf70ed61eab5627d7646795d16860">upper_branch</a> (<a class="el" href="classcountertree_1_1forest_1_1branch.html">branch</a> &amp;R, uint32_t &amp;Cod) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a94acf70ed61eab5627d7646795d16860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the address of the pointer to the upper branch.<br/>
 It provides too, the code of the pointer in the upper branch wich connect the two branch.  <a href="#a94acf70ed61eab5627d7646795d16860">More...</a><br/></td></tr>
<tr class="separator:a94acf70ed61eab5627d7646795d16860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c4a161d01bdae4dd757e196fac69b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a48c4a161d01bdae4dd757e196fac69b1">pointer_father</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *P) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a48c4a161d01bdae4dd757e196fac69b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a pointer to pointer to the node_t black of the branch  <a href="#a48c4a161d01bdae4dd757e196fac69b1">More...</a><br/></td></tr>
<tr class="separator:a48c4a161d01bdae4dd757e196fac69b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94acf70ed61eab5627d7646795d16860"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a94acf70ed61eab5627d7646795d16860">upper_branch</a> (<a class="el" href="classcountertree_1_1forest_1_1branch.html">branch</a> &amp;R, uint32_t &amp;Cod) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a94acf70ed61eab5627d7646795d16860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the address of the pointer to the upper branch.<br/>
 It provides too, the code of the pointer in the upper branch wich connect the two branch.  <a href="#a94acf70ed61eab5627d7646795d16860">More...</a><br/></td></tr>
<tr class="separator:a94acf70ed61eab5627d7646795d16860"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a27b2e89faf8ea0ebe0c07d6a3e601089"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a27b2e89faf8ea0ebe0c07d6a3e601089">upgrade</a> (<a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *P) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a27b2e89faf8ea0ebe0c07d6a3e601089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4c9a3798f6f11c4549e73bd43c3399"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#acd4c9a3798f6f11c4549e73bd43c3399">upgrade</a> (const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *P) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:acd4c9a3798f6f11c4549e73bd43c3399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="structcountertree_1_1forest_1_1base__node.html" title="This class represent a node of the tree.">base_node</a> pointer in a node_t&lt;T&gt; pointer.  <a href="#acd4c9a3798f6f11c4549e73bd43c3399">More...</a><br/></td></tr>
<tr class="separator:acd4c9a3798f6f11c4549e73bd43c3399"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a08bbaf6247974fced78cb9bc88fad7e8"><td class="memItemLeft" align="right" valign="top">node_alloc_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a08bbaf6247974fced78cb9bc88fad7e8">node_alloc</a></td></tr>
<tr class="separator:a08bbaf6247974fced78cb9bc88fad7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5cb7200824bb5d53aaf60ea0a265bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a1a5cb7200824bb5d53aaf60ea0a265bd">root</a></td></tr>
<tr class="separator:a1a5cb7200824bb5d53aaf60ea0a265bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b341b47ed1864117bd27c221647f111"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a5b341b47ed1864117bd27c221647f111">first</a></td></tr>
<tr class="separator:a5b341b47ed1864117bd27c221647f111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1deb00dd008479fc6029bc0873043e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aec1deb00dd008479fc6029bc0873043e">last</a></td></tr>
<tr class="separator:aec1deb00dd008479fc6029bc0873043e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8780ee647a04c40c77bf7f1f50fa5855"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a8780ee647a04c40c77bf7f1f50fa5855">n_level</a></td></tr>
<tr class="separator:a8780ee647a04c40c77bf7f1f50fa5855"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0dafd67e1623c82a057f8f65225d3373"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a0dafd67e1623c82a057f8f65225d3373">c_forest::const_base_iterator&lt; tree &gt;</a></td></tr>
<tr class="separator:a0dafd67e1623c82a057f8f65225d3373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbf07000006d6e3fed52fc710927685"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#abdbf07000006d6e3fed52fc710927685">c_forest::base_iterator&lt; tree &gt;</a></td></tr>
<tr class="separator:abdbf07000006d6e3fed52fc710927685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d183515988c5e36d20affb411cb6d65"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9d183515988c5e36d20affb411cb6d65">c_forest::iterator&lt; tree &gt;</a></td></tr>
<tr class="separator:a9d183515988c5e36d20affb411cb6d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2fa23e9b8493d6dd4ce9e0599cde98"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ade2fa23e9b8493d6dd4ce9e0599cde98">c_forest::const_iterator&lt; tree &gt;</a></td></tr>
<tr class="separator:ade2fa23e9b8493d6dd4ce9e0599cde98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5cfd7f081d16994cd443b6934e4d222"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ad5cfd7f081d16994cd443b6934e4d222">c_forest::reverse_iterator&lt; tree &gt;</a></td></tr>
<tr class="separator:ad5cfd7f081d16994cd443b6934e4d222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b7de52881d52db41535996741c733a"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a63b7de52881d52db41535996741c733a">c_forest::const_reverse_iterator&lt; tree &gt;</a></td></tr>
<tr class="separator:a63b7de52881d52db41535996741c733a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15129a1184039b34ce2291520a7b7dac"><td class="memTemplParams" colspan="2">template&lt;typename value1_t , typename node_alloc_t2 &gt; </td></tr>
<tr class="memitem:a15129a1184039b34ce2291520a7b7dac"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a15129a1184039b34ce2291520a7b7dac">tree</a></td></tr>
<tr class="separator:a15129a1184039b34ce2291520a7b7dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0d12f2ff540a128b08d13bf818efb2"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aad0d12f2ff540a128b08d13bf818efb2">c_forest::const_base_iterator&lt; tree &gt;</a></td></tr>
<tr class="separator:aad0d12f2ff540a128b08d13bf818efb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add356c550f7acf7b88ba56a1b17171b0"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#add356c550f7acf7b88ba56a1b17171b0">c_forest::base_iterator&lt; tree &gt;</a></td></tr>
<tr class="separator:add356c550f7acf7b88ba56a1b17171b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34b6d10bf443f61cca524fc2a117dc4"><td class="memTemplParams" colspan="2">template&lt;typename value1_t , typename node_alloc_t2&gt; </td></tr>
<tr class="memitem:ad34b6d10bf443f61cca524fc2a117dc4"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ad34b6d10bf443f61cca524fc2a117dc4">tree</a></td></tr>
<tr class="separator:ad34b6d10bf443f61cca524fc2a117dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt;<br/>
class countertree::forest::tree&lt; value_t, node_alloc_t &gt;</h3>

<p>This class have the same interface than the STL vector, but istead of be a vector is a tree. <br/>
 Due to this all the operations ( insert, delete, access) a O( logN). <br/>
. </p>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00077">77</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="aab7fad36adf1980c5c105504b222648b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcountertree_1_1forest_1_1base__iterator.html">c_forest::base_iterator</a>&lt;<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&gt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#aab7fad36adf1980c5c105504b222648b">base_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00104">104</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aab7fad36adf1980c5c105504b222648b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcountertree_1_1forest_1_1base__iterator.html">c_forest::base_iterator</a>&lt;<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&gt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#aab7fad36adf1980c5c105504b222648b">base_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00104">104</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a667a1e5473ccb2ba456f4a9799239321"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcountertree_1_1forest_1_1base__node.html">c_forest::base_node</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00097">97</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a667a1e5473ccb2ba456f4a9799239321"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcountertree_1_1forest_1_1base__node.html">c_forest::base_node</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00097">97</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0ad23777e9919c8b49524662ebf1a1bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcountertree_1_1forest_1_1const__base__iterator.html">c_forest::const_base_iterator</a>&lt;<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&gt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#a0ad23777e9919c8b49524662ebf1a1bf">const_base_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00105">105</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0ad23777e9919c8b49524662ebf1a1bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcountertree_1_1forest_1_1const__base__iterator.html">c_forest::const_base_iterator</a>&lt;<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&gt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#a0ad23777e9919c8b49524662ebf1a1bf">const_base_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00105">105</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaf68addaf301fecce33fc7c2a82987d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html">c_forest::const_iterator</a>&lt;<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&gt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00101">101</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaf68addaf301fecce33fc7c2a82987d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html">c_forest::const_iterator</a>&lt;<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&gt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00101">101</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae144854364603d19a93bb62772b7829f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a>* <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#ae144854364603d19a93bb62772b7829f">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00093">93</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae144854364603d19a93bb62772b7829f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a>* <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#ae144854364603d19a93bb62772b7829f">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00093">93</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aba22db65eff769cc801a7a5203af79e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a>&amp; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#aba22db65eff769cc801a7a5203af79e4">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00095">95</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aba22db65eff769cc801a7a5203af79e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a>&amp; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#aba22db65eff769cc801a7a5203af79e4">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00095">95</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afb8570b4b8f3076f34067fa4ec34afca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1const__reverse__iterator.html">c_forest::const_reverse_iterator</a>&lt;<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&gt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00103">103</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afb8570b4b8f3076f34067fa4ec34afca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1const__reverse__iterator.html">c_forest::const_reverse_iterator</a>&lt;<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&gt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00103">103</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac4899fc42db7c3418d99a86118933342"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacecountertree_1_1common.html#aacea70d0e38fcfefebf3b6ad0a88ae6f">c_common::signed_type</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#ac4899fc42db7c3418d99a86118933342">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00090">90</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac4899fc42db7c3418d99a86118933342"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacecountertree_1_1common.html#aacea70d0e38fcfefebf3b6ad0a88ae6f">c_common::signed_type</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#ac4899fc42db7c3418d99a86118933342">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00090">90</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a752155609649dc94fe17ae0239376f04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1iterator.html">c_forest::iterator</a>&lt;<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&gt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00100">100</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a752155609649dc94fe17ae0239376f04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1iterator.html">c_forest::iterator</a>&lt;<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&gt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00100">100</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3006fe9bd55b7ef169b250da47ba0116"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcountertree_1_1forest_1_1node.html">c_forest::node</a>&lt;value_t&gt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00096">96</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3006fe9bd55b7ef169b250da47ba0116"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcountertree_1_1forest_1_1node.html">c_forest::node</a>&lt;value_t&gt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00096">96</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d55dcff9a6d6007b9cd7c626587a7fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a>* <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#a4d55dcff9a6d6007b9cd7c626587a7fd">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00092">92</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d55dcff9a6d6007b9cd7c626587a7fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a>* <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#a4d55dcff9a6d6007b9cd7c626587a7fd">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00092">92</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a63560ea528d9b393acb0d2824a5e38d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a>&amp; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#a63560ea528d9b393acb0d2824a5e38d5">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00094">94</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a63560ea528d9b393acb0d2824a5e38d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a>&amp; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#a63560ea528d9b393acb0d2824a5e38d5">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00094">94</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9cc1af3e272082d169789594bdcd0114"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1reverse__iterator.html">c_forest::reverse_iterator</a>&lt;<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&gt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00102">102</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9cc1af3e272082d169789594bdcd0114"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1reverse__iterator.html">c_forest::reverse_iterator</a>&lt;<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&gt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00102">102</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af62e7d9749b95b2cfe4aa45a1ba09d3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacecountertree_1_1common.html#aacea70d0e38fcfefebf3b6ad0a88ae6f">c_common::signed_type</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#af62e7d9749b95b2cfe4aa45a1ba09d3a">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00084">84</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af62e7d9749b95b2cfe4aa45a1ba09d3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacecountertree_1_1common.html#aacea70d0e38fcfefebf3b6ad0a88ae6f">c_common::signed_type</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#af62e7d9749b95b2cfe4aa45a1ba09d3a">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00084">84</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a59c01705ce2fe0ffcba7a92043734f30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef value_t <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00091">91</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a59c01705ce2fe0ffcba7a92043734f30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef value_t <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00091">91</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af41af4bbb3350157359fae9d436fbf15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> </td>
          <td>(</td>
          <td class="paramtype">const node_alloc_t &amp;&#160;</td>
          <td class="paramname"><em>na</em> = <code>node_alloc_t()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">na</td><td>: node allocator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00156">156</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad6af85e6039f03999116f18cc339c88e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>: tree to copy </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00164">164</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0496ac3428b1779641ff8f1e070e5544"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename node_alloc2_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc2_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>: tree to copy </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00175">175</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7444654225a13f25d012082dbcc9f8c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor from a rvalue </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>: tree to move </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00185">185</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a041a21a93b897c3801df3e4eccdc4eee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::~<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00196">196</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af41af4bbb3350157359fae9d436fbf15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> </td>
          <td>(</td>
          <td class="paramtype">const node_alloc_t &amp;&#160;</td>
          <td class="paramname"><em>na</em> = <code>node_alloc_t()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">na</td><td>: node allocator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00149">149</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad6af85e6039f03999116f18cc339c88e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>: tree to copy </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00156">156</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0496ac3428b1779641ff8f1e070e5544"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename node_alloc2_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc2_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>: tree to copy </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00167">167</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7444654225a13f25d012082dbcc9f8c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor from a rvalue </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>: tree to move </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00177">177</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a041a21a93b897c3801df3e4eccdc4eee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::~<a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00187">187</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af77b98286518044aa308df251a92a002"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a>* <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#af62e7d9749b95b2cfe4aa45a1ba09d3a">size_type</a>&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ae144854364603d19a93bb62772b7829f">const_pointer</a>&#160;</td>
          <td class="paramname"> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a block of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cnt</td><td>: number of objects to allocate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>unused </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the object allocated </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00422">422</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af77b98286518044aa308df251a92a002"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a>* <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#af62e7d9749b95b2cfe4aa45a1ba09d3a">size_type</a>&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#ae144854364603d19a93bb62772b7829f">const_pointer</a>&#160;</td>
          <td class="paramname"> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a block of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cnt</td><td>: number of objects to allocate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>unused </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the object allocated </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01010">1010</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa52b102e4d25507f79e6b2fda89fb709"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a range of data, dropping all the elements of the container. It's like the assignation operator but with several parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">it_first</td><td>: iterator to the first element to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">it_last</td><td>: Iterator to the end of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00262">262</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa52b102e4d25507f79e6b2fda89fb709"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a range of data, dropping all the elements of the container. It's like the assignation operator but with several parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">it_first</td><td>: iterator to the first element to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">it_last</td><td>: Iterator to the end of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00270">270</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a91eea9e1c59f9e2fa1cb3be20a95e7d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">unsigned_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a range of data, dropping all the elements of the container It's like the assignation operator but with several parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: number of elements to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00304">304</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a82f0602c6bf41a2c6f117e7e71cb74b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a range of data, dropping all the elements of the container It's like the assignation operator but with several parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: number of elements to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00312">312</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa729073df47102d44b6b59794dba22ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::assign_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a range of data, dropping all the elements of the container It's like the assignation operator but with several parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">it_first</td><td>: iterator to the first element to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">it_last</td><td>: Iterator to the end of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function which receives an element and when return true the lement is inserted and when false , not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00283">283</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa729073df47102d44b6b59794dba22ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::assign_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a range of data, dropping all the elements of the container It's like the assignation operator but with several parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">it_first</td><td>: iterator to the first element to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">it_last</td><td>: Iterator to the end of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function which receives an element and when return true the lement is inserted and when false , not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00291">291</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a17fa69d33c09fb437646bc4b3b95e9e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_t&amp; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the last element in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the last element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00531">531</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a586cc0895021be77105d23b91ad12506"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t&amp; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const_reference to the last element in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the last element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00542">542</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a17fa69d33c09fb437646bc4b3b95e9e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_t&amp; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the last element in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the last element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00656">656</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a586cc0895021be77105d23b91ad12506"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t&amp; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const_reference to the last element in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the last element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00667">667</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a07ebc841308d56fdc08c58c0c2241d53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01051">1051</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8de37fe37a9518b9d48f23e2c401e45c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the first element </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01108">1108</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a07ebc841308d56fdc08c58c0c2241d53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01325">1325</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8de37fe37a9518b9d48f23e2c401e45c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the first element </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01382">1382</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae22fde787e169da53de580084e807504"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::capacity </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the maximun size of the container </p>
<dl class="section return"><dt>Returns</dt><dd>maximun size of the container </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00427">427</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae22fde787e169da53de580084e807504"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::capacity </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the maximun size of the container </p>
<dl class="section return"><dt>Returns</dt><dd>maximun size of the container </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00477">477</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a64de10716c9eb71703d168307b107511"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the first element </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01115">1115</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a64de10716c9eb71703d168307b107511"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the first element </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01389">1389</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa9d5d2081d731634553165ce6ab83a73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::cend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01136">1136</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa9d5d2081d731634553165ce6ab83a73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::cend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01410">1410</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a585976fa9e6bc9e29a178080af99600a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::cit_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the first element </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01101">1101</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a585976fa9e6bc9e29a178080af99600a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::cit_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the first element </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01375">1375</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc3343bbb836d48f0a35b1bc24e2e694"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::cit_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01122">1122</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc3343bbb836d48f0a35b1bc24e2e694"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::cit_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01396">1396</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae5b71d987c8ef2a21de10c9aa3ba9fd8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::cit_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the last element </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01143">1143</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae5b71d987c8ef2a21de10c9aa3ba9fd8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::cit_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the last element </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01417">1417</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afadf8db5ba400fb6789b0c7a2a916c3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::cit_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01150">1150</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afadf8db5ba400fb6789b0c7a2a916c3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::cit_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01424">1424</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abcce84e57f78847c0ce82d594dd343ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete all the elements of the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="abcce84e57f78847c0ce82d594dd343ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t , typename node_alloc_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete all the elements of the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01741">1741</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac8bb57d7cb2d740a83b8faa11507df10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t , typename node_alloc_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *&#160;</td>
          <td class="paramname"><em>PAux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a>&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a node_t in the tree and make a rebalanced if necessary. </p>
<p>connect a node_t in the tree and make a rebalanced if necessary</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PAux</td><td>: pointer to the node_t for to be inserted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: pointer to the node_t where insert PAux </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Left</td><td>: indicates which node_t of P1 link to PAux </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the tree is empty P1 and Left are not checked<br/>
 This function works well when the tree is empty<br/>
 All the counters of the nodes from the insertion point to the root must be previously incremented </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01858">1858</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac8bb57d7cb2d740a83b8faa11507df10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *&#160;</td>
          <td class="paramname"><em>PAux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a>&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a node_t in the tree and make a rebalanced if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PAux</td><td>: pointer to the node_t for to be inserted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: pointer to the node_t where insert PAux </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Left</td><td>: indicates which node_t of P1 link to PAux </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the tree is empty P1 and Left are not checked<br/>
 This function works well when the tree is empty<br/>
 All the counters of the nodes from the insertion point to the root must be previously incremented </dd></dl>

</div>
</div>
<a class="anchor" id="a4f84563d58fa2060ea2528331c5cf074"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::connector_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the connector for to insert an element in the first position of the tree </p>
<dl class="section return"><dt>Returns</dt><dd>connector filled </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is Kte </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00720">720</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f84563d58fa2060ea2528331c5cf074"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::connector_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the connector for to insert an element in the first position of the tree </p>
<dl class="section return"><dt>Returns</dt><dd>connector filled </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is Kte </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01362">1362</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a968563a4fd4814dcad70c5dd8d2654fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::connector_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the connector for to insert an element in the first position of the tree </p>
<dl class="section return"><dt>Returns</dt><dd>connector filled </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is Kte </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00731">731</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2b92b98afcfa18d52debf704c6080070"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t , typename node_alloc_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::connector_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *&#160;</td>
          <td class="paramname"><em>Ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the connector for to insert the new node in the position before the node pointed by Ptr </p>
<p>return the pointer and the side for to insert a new node_t in the position Pos</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Ptr</td><td>: Pointer to the node_t, before which we want insert a new node_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>connector for to insert </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) )</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to insert the value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P2</td><td>: Pointer to the node_t where insert the node_t </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">left_side</td><td>: Indicate which side of P2 in the insertion pointer true: left pointer , false: right pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00772">772</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2b92b98afcfa18d52debf704c6080070"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::connector_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *&#160;</td>
          <td class="paramname"><em>Ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the pointer and the side for to insert a new node_t before the node_t pointed by Ptr </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Ptr</td><td>: Pointer to the node_t, before which we want insert a new node_t </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">left_side</td><td>: Indicate which side of P2 in the insertion pointer true: left pointer , false: right pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the node_t to insert the new node_t </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

</div>
</div>
<a class="anchor" id="adc73dbf477b69751305af1da1b22b630"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t , typename node_alloc_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::connector_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the connector for to insert a new node in the position Pos </p>
<p>return the pointer and the side for to insert a new node_t in the position Pos</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to insert the value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>connector for the insertion </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) )</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to insert the value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P2</td><td>: Pointer to the node_t where insert the node_t </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">left_side</td><td>: Indicate which side of P2 in the insertion pointer true: left pointer , false: right pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00742">742</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adc73dbf477b69751305af1da1b22b630"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::connector_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the pointer and the side for to insert a new node_t in the position Pos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to insert the value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P2</td><td>: Pointer to the node_t where insert the node_t </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">left_side</td><td>: Indicate which side of P2 in the insertion pointer true: left pointer , false: right pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

</div>
</div>
<a class="anchor" id="a6cacdcc8835acbca0a56472b2cf91402"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::const_iterator_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos1</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a position in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the position. If don't exists return <a class="el" href="classcountertree_1_1forest_1_1tree.html#a4f2956e28620ef156ff265fe2e4663c2">end()</a> an exception </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log N) </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00585">585</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6cacdcc8835acbca0a56472b2cf91402"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::const_iterator_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos1</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a position in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the position. If don't exists return <a class="el" href="classcountertree_1_1forest_1_1tree.html#a4f2956e28620ef156ff265fe2e4663c2">end()</a> an exception </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log N) </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01257">1257</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae7cede3f544c96075bd5158a26402944"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new object in the memory pointed by p. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>: pointer to the memory for to construct the object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>: list of parameters used in the copy constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00445">445</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac5473eaafaf2ed065f9ca81594df809a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename P , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">P *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new object in the memory pointed by p. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>: pointer to the memory for to construct the object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>: list of parameters used in the copy constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01032">1032</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aac0364e03d69ee50e529f48c251b4cb2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename node_alloc_t2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc_t2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asignation operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>: tree from where copy the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the tree after the copy </dd></dl>

</div>
</div>
<a class="anchor" id="aac0364e03d69ee50e529f48c251b4cb2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename node_alloc_t2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc_t2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asignation operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>: tree from where copy the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the tree after the copy </dd></dl>

</div>
</div>
<a class="anchor" id="af4fe6b43df90524e11068cc0a8310b62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t &gt; </div>
<div class="memtemplate">
template&lt;typename node_alloc2_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc2_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy one tree in other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>: tree from where copy the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the tree after the copy </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01676">1676</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a293a514e0f71684097a968f7c38cb7c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::crbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_reverse_iterator</a> to the last element </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01255">1255</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a293a514e0f71684097a968f7c38cb7c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::crbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_reverse_iterator</a> to the last element </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01529">1529</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa35bc47414f84b4b3e2b71fe1f212655"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::crend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_reverse_iterator</a> to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01276">1276</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa35bc47414f84b4b3e2b71fe1f212655"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::crend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_reverse_iterator</a> to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01550">1550</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b010541a31187bff3bd7508555cd114"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::crit_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_reverse_iterator</a> to the first element </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01227">1227</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b010541a31187bff3bd7508555cd114"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::crit_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_reverse_iterator</a> to the first element </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01501">1501</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a095625170f5535e7c08a0d8b00ffe000"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::crit_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_reverse_iterator</a> to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01234">1234</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a095625170f5535e7c08a0d8b00ffe000"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::crit_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_reverse_iterator</a> to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01508">1508</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a51190279d6ee4c788e5d678bd8dc1f6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::crit_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_reverse_iterator</a> to the last element </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01241">1241</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a51190279d6ee4c788e5d678bd8dc1f6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::crit_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_reverse_iterator</a> to the last element </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01515">1515</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa377cbceaf27aab4e2d57354ffaa5564"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::crit_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_reverse_iterator</a> to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01262">1262</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa377cbceaf27aab4e2d57354ffaa5564"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::crit_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_reverse_iterator</a> to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01536">1536</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab40b57e86afe1afdfc0446453b9729c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::deallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#af62e7d9749b95b2cfe4aa45a1ba09d3a">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deallocate a block of memory </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>: pointer to deallocate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: number of objects to deallocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">:</td><td>bad_alloc </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00433">433</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab40b57e86afe1afdfc0446453b9729c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::deallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#af62e7d9749b95b2cfe4aa45a1ba09d3a">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deallocate a block of memory </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>: pointer to deallocate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: number of objects to deallocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">:</td><td>bad_alloc </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01021">1021</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a76ef46cebff0505517eeb668f730dfdf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a4d55dcff9a6d6007b9cd7c626587a7fd">pointer</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destroy the object without freeing the memory </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>: pointer p to the object to destroy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00454">454</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a53eda17aba0a507e068a19ee2d7d9a04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destroy the object without freeing the memory </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>: pointer p to the object to destroy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01041">1041</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a821930cba3d045f10d492dbcb3bcd3bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t , typename node_alloc_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *&#160;</td>
          <td class="paramname"><em>PAux</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>disconnect the node_t from the tree, and leave it balanced and with the nodes actualized </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PAux</td><td>: pointer to the node_t to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01776">1776</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a821930cba3d045f10d492dbcb3bcd3bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *&#160;</td>
          <td class="paramname"><em>PAux</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>disconnect the node_t from the tree, and leave it balanced and with the nodes actualized </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PAux</td><td>: pointer to the node_t to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="a00e777d5abd68155813c760eb01618e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in the previous position to the pointed by the iterator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: Itera which indicates the position to insert the value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the iterator is <a class="el" href="classcountertree_1_1forest_1_1tree.html#a6acc1f3a4669a18c5a43c7adf8b4e606">rend()</a> there is an error because we can't insert before it </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00696">696</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a00e777d5abd68155813c760eb01618e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in the previous position to the pointed by the iterator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: Itera which indicates the position to insert the value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the iterator is <a class="el" href="classcountertree_1_1forest_1_1tree.html#a6acc1f3a4669a18c5a43c7adf8b4e606">rend()</a> there is an error because we can't insert before it </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00809">809</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ace37599ccc53ed3d56834aec90802adf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert one element in the back of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>: arguments for to build the node to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00644">644</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ace37599ccc53ed3d56834aec90802adf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert one element in the back of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>: arguments for to build the node to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00747">747</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4c756e10c6733e2cf85068b8e8f72fcb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::emplace_front </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in the front of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>: arguments for to build the node to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00623">623</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4c756e10c6733e2cf85068b8e8f72fcb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::emplace_front </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in the front of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>: arguments for to build the node to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00720">720</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="add9f7189cc4d851c60703d78db012aa9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::emplace_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a>&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in a the position specified by the connector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>: connector which indicate where must insert the node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>: arguments to build the node to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00598">598</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9ab89cb09b79d98f649dcdc2cf3b5a0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::emplace_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in a specified position </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>: arguments to build the node to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to insert the value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00667">667</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9ab89cb09b79d98f649dcdc2cf3b5a0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::emplace_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in a specified position </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>: arguments to build the node to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to insert the value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00775">775</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abdd2aa4e71c2c1f0290e8c646733f095"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>indicate if the map is empty </p>
<dl class="section return"><dt>Returns</dt><dd>true if the map is empty, false in any other case </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00435">435</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abdd2aa4e71c2c1f0290e8c646733f095"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>indicate if the map is empty </p>
<dl class="section return"><dt>Returns</dt><dd>true if the map is empty, false in any other case </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00485">485</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f2956e28620ef156ff265fe2e4663c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01065">1065</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a29514d34e57ac6e224ea48ac77385888"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01129">1129</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f2956e28620ef156ff265fe2e4663c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01339">1339</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a29514d34e57ac6e224ea48ac77385888"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01403">1403</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a002118c0ab4d78234a1f7ef67e9edec7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element pointed by the iterator P1 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: iterator to the element to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the next element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( constant) </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00861">861</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae6b988cdd28789caa420467c5f8ad5a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element pointed by the iterator P1 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: iterator to the element to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( constant) </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00877">877</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad42ac770e3ba0e65e372d8948ef789c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase a range of elements between first_it and last_it </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first_it</td><td>: iterator to the first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last_it</td><td>: iterator to the final element of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements erased </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00878">878</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad42ac770e3ba0e65e372d8948ef789c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase a range of elements between first_it and last_it </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first_it</td><td>: iterator to the first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last_it</td><td>: iterator to the final element of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements erased </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00895">895</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a67bdfff679d2a63b605127a5c580b0cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase a range of elements between first_it and last_it </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first_it</td><td>: iterator to the first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last_it</td><td>: iterator to the final element of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements erased </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00901">901</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a67bdfff679d2a63b605127a5c580b0cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase a range of elements between first_it and last_it </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first_it</td><td>: iterator to the first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last_it</td><td>: iterator to the final element of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements erased </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00920">920</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a72de3511684b1f945bd006e44d3af12d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::erase_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *&#160;</td>
          <td class="paramname"><em>PAux</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (constant) </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00824">824</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab695f9b76bde4e0c186c6daea814db79"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::erase_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element of the position pos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>: position to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00928">928</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6062e679e2dbe5b3b3c796425270eef5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::erase_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>First</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>NElem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the NElem elements after the position First </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">First</td><td>: position to the first element to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NElem</td><td>: number of elements to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00940">940</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab695f9b76bde4e0c186c6daea814db79"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::erase_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element of the position pos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>: position to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00949">949</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6062e679e2dbe5b3b3c796425270eef5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::erase_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>First</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>NElem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the NElem elements after the position First </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">First</td><td>: position to the first element to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NElem</td><td>: number of elements to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00985">985</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9a8cdd46d92134eee99ad5b4bccc1e7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::erase_pos_if </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>First</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>NElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the NElem elements after the position First if the function M return true when receives the element as parameter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">First</td><td>: position to the first element to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NElem</td><td>: number of elements to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function for to evaluate the element to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements erased </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00961">961</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a233cee698c917a67246a046acf139454"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::erase_pos_if </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element of the position pos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>: position to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true deleted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00964">964</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9a8cdd46d92134eee99ad5b4bccc1e7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::erase_pos_if </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>First</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>NElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a59c01705ce2fe0ffcba7a92043734f30">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the NElem elements after the position First if the function M return true when receives the element as parameter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">First</td><td>: position to the first element to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NElem</td><td>: number of elements to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function for to evaluate the element to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements erased </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01008">1008</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac5a2ecda1f0f645054f1623e09463d32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_t&amp; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the first element in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the first element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00509">509</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a08f5d958d85b20a68550a081bd4888d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t&amp; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const_reference to the first element in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the first element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00520">520</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac5a2ecda1f0f645054f1623e09463d32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_t&amp; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the first element in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the first element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00634">634</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a08f5d958d85b20a68550a081bd4888d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t&amp; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const_reference to the first element in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the first element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00645">645</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa73bbbdb50ec910fe6eeff0d6ac45de5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::get_cit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *&#160;</td>
          <td class="paramname"><em>P1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create an <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> from a node pointer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator which point this node </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01275">1275</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a00c66e015c1a9e928ed67a3c00879f15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::get_crit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *&#160;</td>
          <td class="paramname"><em>P1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create an const_ireverse_terator from a node pointer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator which point this node </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01289">1289</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34d4988256cd1729077f81cc417c384e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a>* const <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::get_first </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the first pointer to the root of the tree </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first node of the tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is for internal use </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00521">521</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f15957ac496a2c60e10a7c9c2550809"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::get_it </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *&#160;</td>
          <td class="paramname"><em>P1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create an iterator from a node pointer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator which point this node </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01268">1268</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afa26eac4a30066522594ae421fcab3d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a>* const <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::get_last </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the node pointer to the last of the tree </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the last node of the tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is for internal use </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00530">530</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae66d21f7d8f9b30430d6b0b804a22977"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::get_rit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a> *&#160;</td>
          <td class="paramname"><em>P1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create an <a class="el" href="classcountertree_1_1forest_1_1reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">reverse_iterator</a> from a node pointer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator which point this node </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01282">1282</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab605ce8fdc6e488db4caaebbad5477b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a>* const <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::get_root </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the node pointer to the root of the tree </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the root of the tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is for internal use </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00512">512</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0c2c069799ce4d28d198e3c5a5650370"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a>* <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::get_root </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a pointer to the root node of the tree </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">///@return</td><td>Pointer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01067">1067</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a36a8773e9f6b3986f20005e032f4b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in the previous position to the pointed by the iterator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: Itera which indicates the position to insert the value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the iterator is <a class="el" href="classcountertree_1_1forest_1_1tree.html#a6acc1f3a4669a18c5a43c7adf8b4e606">rend()</a> there is an error because we can't insert before it </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00682">682</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a36a8773e9f6b3986f20005e032f4b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in the previous position to the pointed by the iterator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: Itera which indicates the position to insert the value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the iterator is <a class="el" href="classcountertree_1_1forest_1_1tree.html#a6acc1f3a4669a18c5a43c7adf8b4e606">rend()</a> there is an error because we can't insert before it </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00794">794</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8b6bf2459dcbe2b153c04b6b9ee3bc52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::insert_first_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *&#160;</td>
          <td class="paramname"><em>PAux</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insertion with the node_t constructed </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PAux</td><td>: pointer to the new node_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01158">1158</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8b6bf2459dcbe2b153c04b6b9ee3bc52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::insert_first_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *&#160;</td>
          <td class="paramname"><em>PAux</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insertion with the node_t constructed </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PAux</td><td>: pointer to the new node_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01373">1373</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abcf18eef5461f0da8060e29bfffed8d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::insert_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in a specified position </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to insert the value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00655">655</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abcf18eef5461f0da8060e29bfffed8d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::insert_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in a specified position </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to insert the value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00762">762</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a502ebddefca7d7eeae546dff1eed691b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::is_mine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td>
          <td class="paramname"><em>P1</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the iterator is pointing to this tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: iterator to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(true/false ) Indicate if it is pointing to this tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00552">552</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2ad153d98fdb6bf14da4f5d26ad44525"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::is_mine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a>&#160;</td>
          <td class="paramname"><em>P1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the iterator is pointing to this tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: iterator to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(true/false ) Indicate if it is pointing to this tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00562">562</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a502ebddefca7d7eeae546dff1eed691b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::is_mine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td>
          <td class="paramname"><em>P1</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the iterator is pointing to this tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: iterator to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(true/false ) Indicate if it is pointing to this tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01224">1224</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2ad153d98fdb6bf14da4f5d26ad44525"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::is_mine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a>&#160;</td>
          <td class="paramname"><em>P1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the iterator is pointing to this tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: iterator to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(true/false ) Indicate if it is pointing to this tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01234">1234</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a75e1400097be709a2cb9711f1184bd7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::it_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01044">1044</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a75e1400097be709a2cb9711f1184bd7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::it_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01318">1318</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8831384e9598e3b3db862b525fe89997"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::it_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01058">1058</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8831384e9598e3b3db862b525fe89997"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::it_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01332">1332</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1420d4591feb5afdb255c2e2a20c2f74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::it_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01072">1072</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1420d4591feb5afdb255c2e2a20c2f74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::it_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01346">1346</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae9e9a1ebd6bade9b0126ce4a8d2cf7bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::it_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01079">1079</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae9e9a1ebd6bade9b0126ce4a8d2cf7bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::it_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01353">1353</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abd13bd08bcd67f24c6190d3b4df5da36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::iterator_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a position in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the position. If don't exists return <a class="el" href="classcountertree_1_1forest_1_1tree.html#a4f2956e28620ef156ff265fe2e4663c2">end()</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log N) </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00572">572</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abd13bd08bcd67f24c6190d3b4df5da36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::iterator_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a position in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the position. If don't exists return <a class="el" href="classcountertree_1_1forest_1_1tree.html#a4f2956e28620ef156ff265fe2e4663c2">end()</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log N) </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01244">1244</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa78c5519cee9daa25467e405245bc75d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::levels </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the number of levels in the tree </p>
<dl class="section return"><dt>Returns</dt><dd>number of levels in the tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is for debug only </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00452">452</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa78c5519cee9daa25467e405245bc75d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::levels </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the number of levels in the tree </p>
<dl class="section return"><dt>Returns</dt><dd>number of levels in the tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is for debug only </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00502">502</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7c5c1b8c253c34b6b20e13bfdf13f1c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move all the elements of the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>: this function don't clear the elements in the actual object </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00349">349</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7c5c1b8c253c34b6b20e13bfdf13f1c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move all the elements of the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>: this function don't clear the elements in the actual object </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00360">360</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a59b378740b11d56aef8048904223d948"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&amp; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asignation operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>: tree to move </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the actual object </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00219">219</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a59b378740b11d56aef8048904223d948"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&amp; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asignation operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>: tree to move </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the actual object </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00228">228</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0655366212ee0c410f0c2d6d5b5f4636"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&amp; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asignation operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>: tree to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the actual object </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00232">232</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0655366212ee0c410f0c2d6d5b5f4636"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&amp; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asignation operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>: tree to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the actual object </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00240">240</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac31f5b80c9cc8c030ee5f2e65835ee60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename node_alloc2_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&amp; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc2_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asignation operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>: tree to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the actual object </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00246">246</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac31f5b80c9cc8c030ee5f2e65835ee60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename node_alloc2_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&amp; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc2_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>asignation operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>: tree to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the actual object </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00253">253</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a59b5b7d9ef2aaf730eac5504b96a6b9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_t&amp; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checked access to an element by their position in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the object selected </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (log(N)) </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00487">487</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6c8cf30165ce6d0f883b4a6371ae0020"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t&amp; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checked access to an element by their position in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the object selected </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(log(N)) </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00498">498</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a59b5b7d9ef2aaf730eac5504b96a6b9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_t&amp; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checked access to an element by their position in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the object selected </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (log(N)) </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00612">612</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6c8cf30165ce6d0f883b4a6371ae0020"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t&amp; <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checked access to an element by their position in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the object selected </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(log(N)) </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00623">623</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a48c4a161d01bdae4dd757e196fac69b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a>** <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::pointer_father </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a pointer to pointer to the node_t black of the branch </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>: pointer to a node_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to pointer to the black node_t of the branch </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01433">1433</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a48c4a161d01bdae4dd757e196fac69b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a>** <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::pointer_father </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a pointer to pointer to the node_t black of the branch </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>: pointer to a node_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to pointer to the black node_t of the branch </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01577">1577</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a658b0b9f881138ce58d433ac00f2ffe3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::pop_back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant) </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00848">848</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a658b0b9f881138ce58d433ac00f2ffe3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::pop_back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant) </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00861">861</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa48a3512e1b80dcf671f8fdd3053f96c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::pop_front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (constant) </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00837">837</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa48a3512e1b80dcf671f8fdd3053f96c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::pop_front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (constant) </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00846">846</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae0525ab48d94e9a0882ca4fe1379e63b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a>* <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::ptr_first </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the first element of the tree. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the position. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (1). </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01129">1129</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a079ef0b19dfc590a09e327327b6812ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a>* <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::ptr_first </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the first element of the tree. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the position. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (1). </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01136">1136</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afa8b20da009c9fe4faabbe7b5e39ba2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a>* <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::ptr_last </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the last element of the tree. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the position. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (1). </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01143">1143</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0c7d996ec13c36822321ed783b7a55ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a>* <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::ptr_last </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the first element of the tree. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the position. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (1). </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01150">1150</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a96554b66b6835fe489172288495c740c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a>* <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::ptr_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the node Pos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the position. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log N). This function is called by others functions with the position controlled </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01096">1096</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a878b5522c9d73fdd45804a476ae97906"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a>* <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::ptr_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the node Pos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the position. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log N). This function is called by others functions with the position controlled </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01120">1120</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a96554b66b6835fe489172288495c740c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a>* <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::ptr_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a position in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the position. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log N). This function is called by others functions with the position controlled </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01305">1305</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a878b5522c9d73fdd45804a476ae97906"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a>* <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::ptr_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a position in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the position. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log N). This function is called by others functions with the position controlled </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01329">1329</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a894bae031f46f46cfeffcb763397bd10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert one element in the back of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00633">633</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a894bae031f46f46cfeffcb763397bd10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert one element in the back of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00735">735</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acc67872c42d995e8ec7359a3b97a2d7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in the front of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00612">612</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acc67872c42d995e8ec7359a3b97a2d7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in the front of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00708">708</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaa2c944b0ea0db0259c5971cfd8705a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">reverse_iterator</a> to the last element </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01191">1191</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeedc0445c58c5d96b967de39cc957b8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_reverse_iterator</a> to the last element </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01248">1248</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaa2c944b0ea0db0259c5971cfd8705a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">reverse_iterator</a> to the last element </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01465">1465</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeedc0445c58c5d96b967de39cc957b8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_reverse_iterator</a> to the last element </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01522">1522</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6acc1f3a4669a18c5a43c7adf8b4e606"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01205">1205</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed6842f5c4dcb47a3bd3451077010f12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_reverse_iterator</a> to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01269">1269</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6acc1f3a4669a18c5a43c7adf8b4e606"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01479">1479</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed6842f5c4dcb47a3bd3451077010f12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_reverse_iterator</a> to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01543">1543</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f136d59a898e0939dfefaab159c6770"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_t&#160;</td>
          <td class="paramname"><em>c</em> = <code>value_t()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>resize the current vector size and change to sz.<br/>
 If sz is smaller than the current size, delete elements to end<br/>
 If sz is greater than the current size, insert elements to the end with the value c </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>: new size of the tree after the resize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>: Value to insert if sz is greather than the current size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00370">370</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f136d59a898e0939dfefaab159c6770"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_t&#160;</td>
          <td class="paramname"><em>c</em> = <code>value_t()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>resize the current vector size and change to sz.<br/>
 If sz is smaller than the current size, delete elements to end<br/>
 If sz is greater than the current size, insert elements to the end with the value c </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>: new size of the tree after the resize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>: Value to insert if sz is greather than the current size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00381">381</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae2dd65f17137aa95b0e275a7a97f42da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::rit_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">reverse_iterator</a> to the first element </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01170">1170</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae2dd65f17137aa95b0e275a7a97f42da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::rit_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">reverse_iterator</a> to the first element </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01444">1444</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f7057dd5675969ab0a252f688d40648"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::rit_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">reverse_iterator</a> to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01177">1177</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f7057dd5675969ab0a252f688d40648"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::rit_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">reverse_iterator</a> to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01451">1451</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab19e1a75340c3cf04a7cbd8b974bb49e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::rit_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">reverse_iterator</a> to the last element </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01184">1184</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab19e1a75340c3cf04a7cbd8b974bb49e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::rit_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">reverse_iterator</a> to the last element </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01458">1458</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae363d31e77fd362e04c332789a54e3d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::rit_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">reverse_iterator</a> to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01198">1198</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae363d31e77fd362e04c332789a54e3d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::rit_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">reverse_iterator</a> to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01472">1472</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8d24357cdfa2bf62304d052d3219052b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the number of elements in the tree </p>
<dl class="section return"><dt>Returns</dt><dd>number of elements in the tree </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00443">443</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8d24357cdfa2bf62304d052d3219052b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the number of elements in the tree </p>
<dl class="section return"><dt>Returns</dt><dd>number of elements in the tree </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00493">493</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac47b86c89cfdef7ebf92f4ba7fdbb342"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>swap two trees </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>: tree to swap </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00393">393</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac47b86c89cfdef7ebf92f4ba7fdbb342"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a>&lt; value_t, node_alloc_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>swap two trees </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>: tree to swap </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00404">404</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4285ace1fd6d72b3f2292694260bbcc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a>* <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::upgrade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="structcountertree_1_1forest_1_1base__node.html" title="This class represent a node of the tree.">base_node</a> pointer in a node_t&lt;T&gt; pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td><a class="el" href="structcountertree_1_1forest_1_1base__node.html" title="This class represent a node of the tree.">base_node</a> pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01076">1076</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac69fb7d316396c445b31884bfdf959ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a>* <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::upgrade </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="structcountertree_1_1forest_1_1base__node.html" title="This class represent a node of the tree.">base_node</a> pointer in a node_t&lt;T&gt; pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td><a class="el" href="structcountertree_1_1forest_1_1base__node.html" title="This class represent a node of the tree.">base_node</a> pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01085">1085</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7623bbdeee1771ecbf32397d1612ed84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::upgrade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">const_iterator</a>&#160;</td>
          <td class="paramname"><em>CT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to an iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td><a class="el" href="structcountertree_1_1forest_1_1base__node.html" title="This class represent a node of the tree.">base_node</a> pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01298">1298</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a27b2e89faf8ea0ebe0c07d6a3e601089"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a>* <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::upgrade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01415">1415</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acd4c9a3798f6f11c4549e73bd43c3399"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a3006fe9bd55b7ef169b250da47ba0116">node_t</a>* <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::upgrade </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> *&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="structcountertree_1_1forest_1_1base__node.html" title="This class represent a node of the tree.">base_node</a> pointer in a node_t&lt;T&gt; pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td><a class="el" href="structcountertree_1_1forest_1_1base__node.html" title="This class represent a node of the tree.">base_node</a> pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01424">1424</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a94acf70ed61eab5627d7646795d16860"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a>** <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::upper_branch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1branch.html">branch</a> &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>Cod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take the address of the pointer to the upper branch.<br/>
 It provides too, the code of the pointer in the upper branch wich connect the two branch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>: lower branch </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Cod</td><td>: code of the pointer which connect the two branchs<br/>
 The description of this code is<br/>
 000 : pointer left black node_t<br/>
 001 : pointer right black node_t<br/>
 010 : pointer left of left node_t<br/>
 011 : pointer right of left node_t<br/>
 100 : pointer left of right node_t<br/>
 101 : pointer right of right node_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the pointer to the upper branch </dd></dl>

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l01458">1458</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a94acf70ed61eab5627d7646795d16860"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a>** <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::upper_branch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1branch.html">branch</a> &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>Cod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take the address of the pointer to the upper branch.<br/>
 It provides too, the code of the pointer in the upper branch wich connect the two branch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>: lower branch </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Cod</td><td>: code of the pointer which connect the two branchs<br/>
 The description of this code is<br/>
 000 : pointer left black node_t<br/>
 001 : pointer right black node_t<br/>
 010 : pointer left of left node_t<br/>
 011 : pointer right of left node_t<br/>
 100 : pointer left of right node_t<br/>
 101 : pointer right of right node_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the pointer to the upper branch </dd></dl>

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l01602">1602</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="abdbf07000006d6e3fed52fc710927685"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structcountertree_1_1forest_1_1base__iterator.html">c_forest::base_iterator</a>&lt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00108">108</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="add356c550f7acf7b88ba56a1b17171b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="structcountertree_1_1forest_1_1base__iterator.html">c_forest::base_iterator</a>&lt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00108">108</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0dafd67e1623c82a057f8f65225d3373"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structcountertree_1_1forest_1_1const__base__iterator.html">c_forest::const_base_iterator</a>&lt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00107">107</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aad0d12f2ff540a128b08d13bf818efb2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="structcountertree_1_1forest_1_1const__base__iterator.html">c_forest::const_base_iterator</a>&lt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00107">107</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ade2fa23e9b8493d6dd4ce9e0599cde98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html">c_forest::const_iterator</a>&lt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00110">110</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a63b7de52881d52db41535996741c733a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classcountertree_1_1forest_1_1const__reverse__iterator.html">c_forest::const_reverse_iterator</a>&lt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00112">112</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9d183515988c5e36d20affb411cb6d65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classcountertree_1_1forest_1_1iterator.html">c_forest::iterator</a>&lt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00109">109</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad5cfd7f081d16994cd443b6934e4d222"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classcountertree_1_1forest_1_1reverse__iterator.html">c_forest::reverse_iterator</a>&lt; <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00111">111</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a15129a1184039b34ce2291520a7b7dac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename value1_t , typename node_alloc_t2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00114">114</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad34b6d10bf443f61cca524fc2a117dc4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename value1_t , typename node_alloc_t2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree__old_8hpp_source.html#l00114">114</a> of file <a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a5b341b47ed1864117bd27c221647f111"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> * <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::first</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00122">122</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aec1deb00dd008479fc6029bc0873043e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> * <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::last</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00122">122</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8780ee647a04c40c77bf7f1f50fa5855"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::n_level</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00123">123</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a08bbaf6247974fced78cb9bc88fad7e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_alloc_t <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::node_alloc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00121">121</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1a5cb7200824bb5d53aaf60ea0a265bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename node_alloc_t = std::allocator &lt; node&lt;value_t&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1tree.html#a667a1e5473ccb2ba456f4a9799239321">base_node</a> * <a class="el" href="classcountertree_1_1forest_1_1tree.html">countertree::forest::tree</a>&lt; value_t, node_alloc_t &gt;::root</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tree_8hpp_source.html#l00122">122</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="tree_8hpp_source.html">tree.hpp</a></li>
<li><a class="el" href="tree__old_8hpp_source.html">tree_old.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecountertree.html">countertree</a></li><li class="navelem"><a class="el" href="namespacecountertree_1_1forest.html">forest</a></li><li class="navelem"><a class="el" href="classcountertree_1_1forest_1_1tree.html">tree</a></li>
    <li class="footer">Generated on Tue Jul 30 2013 18:10:28 for Countertree by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
