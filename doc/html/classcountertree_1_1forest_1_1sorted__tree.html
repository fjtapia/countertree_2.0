<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Countertree: countertree::forest::sorted_tree&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Countertree
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">concurrent set , multiset map and multimap with random access iterators</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcountertree_1_1forest_1_1sorted__tree.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classcountertree_1_1forest_1_1sorted__tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">countertree::forest::sorted_tree&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class is a countertree sorted, with all the functions needed for manage the ordered information. <br/>
 It has access by position and random access iterators Due to this all the operations ( insert, delete, access) a O( logN). <br/>
.  
 <a href="classcountertree_1_1forest_1_1sorted__tree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4d796f7eda7fcabc120664f917121dc6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacecountertree_1_1common.html#aacea70d0e38fcfefebf3b6ad0a88ae6f">c_common::signed_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a4d796f7eda7fcabc120664f917121dc6">size_type</a></td></tr>
<tr class="separator:a4d796f7eda7fcabc120664f917121dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326fc76dfea8f0343a1e92da0e5a3c5d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacecountertree_1_1common.html#aacea70d0e38fcfefebf3b6ad0a88ae6f">c_common::signed_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a326fc76dfea8f0343a1e92da0e5a3c5d">difference_type</a></td></tr>
<tr class="separator:a326fc76dfea8f0343a1e92da0e5a3c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f99777c67918d5cb846d69a6d640c4"><td class="memItemLeft" align="right" valign="top">typedef value_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a79f99777c67918d5cb846d69a6d640c4">value_type</a></td></tr>
<tr class="separator:a79f99777c67918d5cb846d69a6d640c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2743936ab86778974ee7182d48c901"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a79f99777c67918d5cb846d69a6d640c4">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0d2743936ab86778974ee7182d48c901">pointer</a></td></tr>
<tr class="separator:a0d2743936ab86778974ee7182d48c901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6abc9531f2c12dc05a29afbed039a6"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a79f99777c67918d5cb846d69a6d640c4">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a4c6abc9531f2c12dc05a29afbed039a6">const_pointer</a></td></tr>
<tr class="separator:a4c6abc9531f2c12dc05a29afbed039a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481ca6fcc8465e51f98a432abee85832"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a79f99777c67918d5cb846d69a6d640c4">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a481ca6fcc8465e51f98a432abee85832">reference</a></td></tr>
<tr class="separator:a481ca6fcc8465e51f98a432abee85832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc9f4d8eb2d47eb0d64bd822a53b1af"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a79f99777c67918d5cb846d69a6d640c4">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0cc9f4d8eb2d47eb0d64bd822a53b1af">const_reference</a></td></tr>
<tr class="separator:a0cc9f4d8eb2d47eb0d64bd822a53b1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efecf2ea1f3b221a5382f2a0ef9e746"><td class="memItemLeft" align="right" valign="top">typedef alloc_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a9efecf2ea1f3b221a5382f2a0ef9e746">allocator_type</a></td></tr>
<tr class="separator:a9efecf2ea1f3b221a5382f2a0ef9e746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2502bd7010efa55a0f7f7e0906a8aeb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structcountertree_1_1forest_1_1node.html">c_forest::node</a>&lt; value_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">node_t</a></td></tr>
<tr class="separator:ae2502bd7010efa55a0f7f7e0906a8aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa91092ed36b3144a31906b9ba78054"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structcountertree_1_1forest_1_1base__node.html">c_forest::base_node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0aa91092ed36b3144a31906b9ba78054">base_node_t</a></td></tr>
<tr class="separator:a0aa91092ed36b3144a31906b9ba78054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a86f27200857c04dd1f46e11973e2a1"><td class="memItemLeft" align="right" valign="top">typedef alloc_t::template <br class="typebreak"/>
rebind&lt; <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">node_t</a> &gt;::other&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a2a86f27200857c04dd1f46e11973e2a1">node_alloc_t</a></td></tr>
<tr class="separator:a2a86f27200857c04dd1f46e11973e2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435616fae6b22fcb60996905ea17aef1"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html">c_forest::tree</a><br class="typebreak"/>
&lt; value_t, <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a2a86f27200857c04dd1f46e11973e2a1">node_alloc_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a435616fae6b22fcb60996905ea17aef1">tree</a></td></tr>
<tr class="separator:a435616fae6b22fcb60996905ea17aef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c7473d19fefb5f0c5208211a62093a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">tree::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a></td></tr>
<tr class="separator:a59c7473d19fefb5f0c5208211a62093a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b5bd26451460adb2ec43a8ed1815bb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">tree::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a></td></tr>
<tr class="separator:a25b5bd26451460adb2ec43a8ed1815bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf6219c86ddf7632a671098d3c02b22"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">tree::reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0cf6219c86ddf7632a671098d3c02b22">reverse_iterator</a></td></tr>
<tr class="separator:a0cf6219c86ddf7632a671098d3c02b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d2d1888631c7aa84f1740348557a8e"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">tree::const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">const_reverse_iterator</a></td></tr>
<tr class="separator:a80d2d1888631c7aa84f1740348557a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeb5c36945969ea582e18bfc8b92f4a47"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#aeb5c36945969ea582e18bfc8b92f4a47">sorted_tree</a> (const comp_key_t &amp;comp=comp_key_t(), const alloc_t &amp;alloc=alloc_t()) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:aeb5c36945969ea582e18bfc8b92f4a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is the construct of the class.  <a href="#aeb5c36945969ea582e18bfc8b92f4a47">More...</a><br/></td></tr>
<tr class="separator:aeb5c36945969ea582e18bfc8b92f4a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7c53c03cc1b71e51616330ecbe498d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a1f7c53c03cc1b71e51616330ecbe498d">sorted_tree</a> (const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a> &amp;VT)</td></tr>
<tr class="memdesc:a1f7c53c03cc1b71e51616330ecbe498d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a1f7c53c03cc1b71e51616330ecbe498d">More...</a><br/></td></tr>
<tr class="separator:a1f7c53c03cc1b71e51616330ecbe498d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23d17df9bc976fd40a1a907e654a65b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ac23d17df9bc976fd40a1a907e654a65b">sorted_tree</a> (<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a> &amp;&amp;VT) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ac23d17df9bc976fd40a1a907e654a65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#ac23d17df9bc976fd40a1a907e654a65b">More...</a><br/></td></tr>
<tr class="separator:ac23d17df9bc976fd40a1a907e654a65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6848a8c166f26ce8776fb34e537f03e4"><td class="memTemplParams" colspan="2">template&lt;typename alloc_t2 &gt; </td></tr>
<tr class="memitem:a6848a8c166f26ce8776fb34e537f03e4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a6848a8c166f26ce8776fb34e537f03e4">sorted_tree</a> (const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t2 &gt; &amp;VT)</td></tr>
<tr class="memdesc:a6848a8c166f26ce8776fb34e537f03e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="#a6848a8c166f26ce8776fb34e537f03e4">More...</a><br/></td></tr>
<tr class="separator:a6848a8c166f26ce8776fb34e537f03e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edbca9bc566d7abb087d3849f5c6ff7"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a4edbca9bc566d7abb087d3849f5c6ff7">~sorted_tree</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a4edbca9bc566d7abb087d3849f5c6ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor of the class  <a href="#a4edbca9bc566d7abb087d3849f5c6ff7">More...</a><br/></td></tr>
<tr class="separator:a4edbca9bc566d7abb087d3849f5c6ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92204dff437bb218e501ef42806a0ace"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a92204dff437bb218e501ef42806a0ace">operator=</a> (const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a> &amp;VT)</td></tr>
<tr class="memdesc:a92204dff437bb218e501ef42806a0ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asignation operator.  <a href="#a92204dff437bb218e501ef42806a0ace">More...</a><br/></td></tr>
<tr class="separator:a92204dff437bb218e501ef42806a0ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6999cf4af9d3b15926ab69f9d5b818"><td class="memTemplParams" colspan="2">template&lt;typename alloc_t2 &gt; </td></tr>
<tr class="memitem:acf6999cf4af9d3b15926ab69f9d5b818"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#acf6999cf4af9d3b15926ab69f9d5b818">operator=</a> (const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t2 &gt; &amp;VT)</td></tr>
<tr class="memdesc:acf6999cf4af9d3b15926ab69f9d5b818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asignation operator.  <a href="#acf6999cf4af9d3b15926ab69f9d5b818">More...</a><br/></td></tr>
<tr class="separator:acf6999cf4af9d3b15926ab69f9d5b818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dcb5992fa8389894923db1eb5167ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a52dcb5992fa8389894923db1eb5167ad">operator=</a> (<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a> &amp;&amp;S)</td></tr>
<tr class="memdesc:a52dcb5992fa8389894923db1eb5167ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asignation operator.  <a href="#a52dcb5992fa8389894923db1eb5167ad">More...</a><br/></td></tr>
<tr class="separator:a52dcb5992fa8389894923db1eb5167ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5295f09d50c307874060fc62a6801a77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a5295f09d50c307874060fc62a6801a77">clear</a> (void)</td></tr>
<tr class="memdesc:a5295f09d50c307874060fc62a6801a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all the elements of the <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a>.  <a href="#a5295f09d50c307874060fc62a6801a77">More...</a><br/></td></tr>
<tr class="separator:a5295f09d50c307874060fc62a6801a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b8abacc30729de63e25aaa23a8708c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a77b8abacc30729de63e25aaa23a8708c">swap</a> (<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a> &amp;A) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a77b8abacc30729de63e25aaa23a8708c"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap the data between the two <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a>  <a href="#a77b8abacc30729de63e25aaa23a8708c">More...</a><br/></td></tr>
<tr class="separator:a77b8abacc30729de63e25aaa23a8708c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66971ffe3ede965768e902a1b31f3727"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a66971ffe3ede965768e902a1b31f3727">size</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a66971ffe3ede965768e902a1b31f3727"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of elements in the <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a>  <a href="#a66971ffe3ede965768e902a1b31f3727">More...</a><br/></td></tr>
<tr class="separator:a66971ffe3ede965768e902a1b31f3727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04a22a766c81f9f2c91384f6b839bc6"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#af04a22a766c81f9f2c91384f6b839bc6">max_size</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:af04a22a766c81f9f2c91384f6b839bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the maximun size of the container  <a href="#af04a22a766c81f9f2c91384f6b839bc6">More...</a><br/></td></tr>
<tr class="separator:af04a22a766c81f9f2c91384f6b839bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239d424adb2aa3aa0d93d523367baf7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a239d424adb2aa3aa0d93d523367baf7f">empty</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a239d424adb2aa3aa0d93d523367baf7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicate if the map is empty  <a href="#a239d424adb2aa3aa0d93d523367baf7f">More...</a><br/></td></tr>
<tr class="separator:a239d424adb2aa3aa0d93d523367baf7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab012bdc51bc0656e056bf20b81b464b9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a435616fae6b22fcb60996905ea17aef1">tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ab012bdc51bc0656e056bf20b81b464b9">get_tree</a> (void) const </td></tr>
<tr class="memdesc:ab012bdc51bc0656e056bf20b81b464b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a const reference to the internal tree  <a href="#ab012bdc51bc0656e056bf20b81b464b9">More...</a><br/></td></tr>
<tr class="separator:ab012bdc51bc0656e056bf20b81b464b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be8202a9674587a826a21bda55d2dfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a1be8202a9674587a826a21bda55d2dfc">find_rep</a> (const key_t &amp;K)</td></tr>
<tr class="memdesc:a1be8202a9674587a826a21bda55d2dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the first element with this Key if don't exist return <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a35bed5373328cc8f91a74d9f0a2e7502">end()</a>  <a href="#a1be8202a9674587a826a21bda55d2dfc">More...</a><br/></td></tr>
<tr class="separator:a1be8202a9674587a826a21bda55d2dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9eebaac17fc5de6762138d149b18432"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ad9eebaac17fc5de6762138d149b18432">find_rep</a> (const key_t &amp;K) const </td></tr>
<tr class="memdesc:ad9eebaac17fc5de6762138d149b18432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the first element with this Key if don't exist return <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a35bed5373328cc8f91a74d9f0a2e7502">end()</a>  <a href="#ad9eebaac17fc5de6762138d149b18432">More...</a><br/></td></tr>
<tr class="separator:ad9eebaac17fc5de6762138d149b18432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ee0be7c7498a204d46d5bd5eedbdf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59ee0be7c7498a204d46d5bd5eedbdf3">find_norep</a> (const key_t &amp;K)</td></tr>
<tr class="memdesc:a59ee0be7c7498a204d46d5bd5eedbdf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the element with this Key. If don't exist return <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a35bed5373328cc8f91a74d9f0a2e7502">end()</a> <br/>
 This function supouse there is only one element with the key.  <a href="#a59ee0be7c7498a204d46d5bd5eedbdf3">More...</a><br/></td></tr>
<tr class="separator:a59ee0be7c7498a204d46d5bd5eedbdf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd60fdfaa8258cf317efbd823e7de668"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#abd60fdfaa8258cf317efbd823e7de668">find_norep</a> (const key_t &amp;K) const </td></tr>
<tr class="memdesc:abd60fdfaa8258cf317efbd823e7de668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the element with this Key. If don't exist return <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a35bed5373328cc8f91a74d9f0a2e7502">end()</a> <br/>
 This function supouse there is only one element with the key.  <a href="#abd60fdfaa8258cf317efbd823e7de668">More...</a><br/></td></tr>
<tr class="separator:abd60fdfaa8258cf317efbd823e7de668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105e2686329bdc16a6ef8b7532180fe0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a105e2686329bdc16a6ef8b7532180fe0">read_norep</a> (value_t &amp;V, const key_t &amp;K) const </td></tr>
<tr class="memdesc:a105e2686329bdc16a6ef8b7532180fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an copy of the object in the tree. If exist return true. If don't exist return false <br/>
 This function supouse there is only one element with the key.  <a href="#a105e2686329bdc16a6ef8b7532180fe0">More...</a><br/></td></tr>
<tr class="separator:a105e2686329bdc16a6ef8b7532180fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9856f4a48ca48983cfc15e90f3fca951"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a9856f4a48ca48983cfc15e90f3fca951">read_rep</a> (value_t &amp;V, const key_t &amp;K, signed_type shift) const </td></tr>
<tr class="memdesc:a9856f4a48ca48983cfc15e90f3fca951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an copy of the object in the tree. If exist return true. If don't exist return false <br/>
.  <a href="#a9856f4a48ca48983cfc15e90f3fca951">More...</a><br/></td></tr>
<tr class="separator:a9856f4a48ca48983cfc15e90f3fca951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63443f36a70f6a62ae7c40ffae78226"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae63443f36a70f6a62ae7c40ffae78226">lower_bound</a> (const key_t &amp;K) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ae63443f36a70f6a62ae7c40ffae78226"><td class="mdescLeft">&#160;</td><td class="mdescRight">find a key in the tree. If there are repeated elements, return an <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the first of them. If the key don't exist return an iterator to the first element greater than the key  <a href="#ae63443f36a70f6a62ae7c40ffae78226">More...</a><br/></td></tr>
<tr class="separator:ae63443f36a70f6a62ae7c40ffae78226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64804ac994c5028a12ce268f60bdbed7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a64804ac994c5028a12ce268f60bdbed7">lower_bound</a> (const key_t &amp;K) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a64804ac994c5028a12ce268f60bdbed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">find a key in the tree. If there are repeated elements, return an <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the first of them. If the key don't exist return an iterator to the first element greater than the key  <a href="#a64804ac994c5028a12ce268f60bdbed7">More...</a><br/></td></tr>
<tr class="separator:a64804ac994c5028a12ce268f60bdbed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8481530fc062c87024604b6cacab38e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a8481530fc062c87024604b6cacab38e4">upper_bound</a> (const key_t &amp;K) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a8481530fc062c87024604b6cacab38e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">return an <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the first element greater than K. If don't exist return <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a35bed5373328cc8f91a74d9f0a2e7502">end()</a>  <a href="#a8481530fc062c87024604b6cacab38e4">More...</a><br/></td></tr>
<tr class="separator:a8481530fc062c87024604b6cacab38e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521cc180c6c439d79185b9f6e31eb31b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a521cc180c6c439d79185b9f6e31eb31b">upper_bound</a> (const key_t &amp;K) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a521cc180c6c439d79185b9f6e31eb31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return an <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the first element greater than K. If don't exist return <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a35bed5373328cc8f91a74d9f0a2e7502">end()</a>  <a href="#a521cc180c6c439d79185b9f6e31eb31b">More...</a><br/></td></tr>
<tr class="separator:a521cc180c6c439d79185b9f6e31eb31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a95f50c7f3805560ee8719ad30a0ab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a3a95f50c7f3805560ee8719ad30a0ab7">iterator_pos</a> (signed_type Pos1) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a3a95f50c7f3805560ee8719ad30a0ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a position in the tree.  <a href="#a3a95f50c7f3805560ee8719ad30a0ab7">More...</a><br/></td></tr>
<tr class="separator:a3a95f50c7f3805560ee8719ad30a0ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238ba7cda3c2934e42f3d6219a1765d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a238ba7cda3c2934e42f3d6219a1765d7">const_iterator_pos</a> (signed_type Pos1) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a238ba7cda3c2934e42f3d6219a1765d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a position in the tree.  <a href="#a238ba7cda3c2934e42f3d6219a1765d7">More...</a><br/></td></tr>
<tr class="separator:a238ba7cda3c2934e42f3d6219a1765d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adced7c12d9782761c6a4280e4b7b869c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a>, <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#adced7c12d9782761c6a4280e4b7b869c">equal_range</a> (const key_t &amp;K) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:adced7c12d9782761c6a4280e4b7b869c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a pair of const_iterators, lower_bound and upper bound of a key K  <a href="#adced7c12d9782761c6a4280e4b7b869c">More...</a><br/></td></tr>
<tr class="separator:adced7c12d9782761c6a4280e4b7b869c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedbc911e7bd5462246e28c35251e2a6"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a>, <br class="typebreak"/>
<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#aaedbc911e7bd5462246e28c35251e2a6">equal_range</a> (const key_t &amp;K) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:aaedbc911e7bd5462246e28c35251e2a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a pair of const_iterators, lower_bound and upper bound of a key K  <a href="#aaedbc911e7bd5462246e28c35251e2a6">More...</a><br/></td></tr>
<tr class="separator:aaedbc911e7bd5462246e28c35251e2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e9b98ab1b4ea4a1bcc1a9cb83588e0"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a56e9b98ab1b4ea4a1bcc1a9cb83588e0">count</a> (const key_t &amp;K) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a56e9b98ab1b4ea4a1bcc1a9cb83588e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of elements with the key K.  <a href="#a56e9b98ab1b4ea4a1bcc1a9cb83588e0">More...</a><br/></td></tr>
<tr class="separator:a56e9b98ab1b4ea4a1bcc1a9cb83588e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78c7d5841c23cf9f08463373066e69a"><td class="memItemLeft" align="right" valign="top">comp_key_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#aa78c7d5841c23cf9f08463373066e69a">key_comp</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:aa78c7d5841c23cf9f08463373066e69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the object used to compare two keys  <a href="#aa78c7d5841c23cf9f08463373066e69a">More...</a><br/></td></tr>
<tr class="separator:aa78c7d5841c23cf9f08463373066e69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a45c13724219d6608d514f5fb4d1b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a2a86f27200857c04dd1f46e11973e2a1">node_alloc_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#aa7a45c13724219d6608d514f5fb4d1b3">node_alloc</a> (void)</td></tr>
<tr class="memdesc:aa7a45c13724219d6608d514f5fb4d1b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides a reference to the node_t allocator of the internal tree object.  <a href="#aa7a45c13724219d6608d514f5fb4d1b3">More...</a><br/></td></tr>
<tr class="separator:aa7a45c13724219d6608d514f5fb4d1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34739458d94cd4702c535a66e723dc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a9efecf2ea1f3b221a5382f2a0ef9e746">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ad34739458d94cd4702c535a66e723dc8">get_allocator</a> () const </td></tr>
<tr class="memdesc:ad34739458d94cd4702c535a66e723dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the object allocator of the set  <a href="#ad34739458d94cd4702c535a66e723dc8">More...</a><br/></td></tr>
<tr class="separator:ad34739458d94cd4702c535a66e723dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7802aa8d674180088bd0819188097dac"><td class="memItemLeft" align="right" valign="top">value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a7802aa8d674180088bd0819188097dac">pos</a> (signed_type Pos1) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a7802aa8d674180088bd0819188097dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a position in the <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a>.  <a href="#a7802aa8d674180088bd0819188097dac">More...</a><br/></td></tr>
<tr class="separator:a7802aa8d674180088bd0819188097dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa887cdd5913adb214a61d5e059cc47e2"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#aa887cdd5913adb214a61d5e059cc47e2">pos</a> (signed_type Pos1) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:aa887cdd5913adb214a61d5e059cc47e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a position in the <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a>.  <a href="#aa887cdd5913adb214a61d5e059cc47e2">More...</a><br/></td></tr>
<tr class="separator:aa887cdd5913adb214a61d5e059cc47e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc403226460c7db6818564b179b81a5"><td class="memItemLeft" align="right" valign="top">value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a6dc403226460c7db6818564b179b81a5">front</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a6dc403226460c7db6818564b179b81a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const_reference to the first element in the <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a>.  <a href="#a6dc403226460c7db6818564b179b81a5">More...</a><br/></td></tr>
<tr class="separator:a6dc403226460c7db6818564b179b81a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7b6fa8bf27938735988281238828d4"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#adb7b6fa8bf27938735988281238828d4">front</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:adb7b6fa8bf27938735988281238828d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const_reference to the first element in the <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a>.  <a href="#adb7b6fa8bf27938735988281238828d4">More...</a><br/></td></tr>
<tr class="separator:adb7b6fa8bf27938735988281238828d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeac6f9a589cd19a6f354277470bb7ad"><td class="memItemLeft" align="right" valign="top">value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#abeac6f9a589cd19a6f354277470bb7ad">back</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:abeac6f9a589cd19a6f354277470bb7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const_reference to the last element in the <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a>.  <a href="#abeac6f9a589cd19a6f354277470bb7ad">More...</a><br/></td></tr>
<tr class="separator:abeac6f9a589cd19a6f354277470bb7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb719a9e8cd7656ad32d26a2ae1d37db"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#adb719a9e8cd7656ad32d26a2ae1d37db">back</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:adb719a9e8cd7656ad32d26a2ae1d37db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const_reference to the last element in the <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a>.  <a href="#adb719a9e8cd7656ad32d26a2ae1d37db">More...</a><br/></td></tr>
<tr class="separator:adb719a9e8cd7656ad32d26a2ae1d37db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66450394bb25e35602ff933e3ae17967"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a66450394bb25e35602ff933e3ae17967"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a66450394bb25e35602ff933e3ae17967">emplace_internal</a> (<a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a> C, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a66450394bb25e35602ff933e3ae17967"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in a the position specified by the connector  <a href="#a66450394bb25e35602ff933e3ae17967">More...</a><br/></td></tr>
<tr class="separator:a66450394bb25e35602ff933e3ae17967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c1f7e08ea7f94423c89905d648974f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae0c1f7e08ea7f94423c89905d648974f">insert_value_rep</a> (const value_t &amp;Val)</td></tr>
<tr class="memdesc:ae0c1f7e08ea7f94423c89905d648974f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a value Val in the sorted tree.  <a href="#ae0c1f7e08ea7f94423c89905d648974f">More...</a><br/></td></tr>
<tr class="separator:ae0c1f7e08ea7f94423c89905d648974f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b07268d13c3f8c89b231cefc4fc804f"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a1b07268d13c3f8c89b231cefc4fc804f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a1b07268d13c3f8c89b231cefc4fc804f">emplace_value_rep</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a1b07268d13c3f8c89b231cefc4fc804f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a value Val in the sorted tree.  <a href="#a1b07268d13c3f8c89b231cefc4fc804f">More...</a><br/></td></tr>
<tr class="separator:a1b07268d13c3f8c89b231cefc4fc804f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cb6dc1bc528c1b5cd75bd4f3b62a95"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a06cb6dc1bc528c1b5cd75bd4f3b62a95">insert_value_norep</a> (const value_t &amp;Val)</td></tr>
<tr class="memdesc:a06cb6dc1bc528c1b5cd75bd4f3b62a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a value in the tree. If the value exist, it is not inserted  <a href="#a06cb6dc1bc528c1b5cd75bd4f3b62a95">More...</a><br/></td></tr>
<tr class="separator:a06cb6dc1bc528c1b5cd75bd4f3b62a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28eef8af614d4199b56d2fca1c99fe23"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a28eef8af614d4199b56d2fca1c99fe23"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a28eef8af614d4199b56d2fca1c99fe23">emplace_value_norep</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a28eef8af614d4199b56d2fca1c99fe23"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a value in the tree. If the value exist, it is not inserted  <a href="#a28eef8af614d4199b56d2fca1c99fe23">More...</a><br/></td></tr>
<tr class="separator:a28eef8af614d4199b56d2fca1c99fe23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377d5b078a4bec3d9f1250834a52413e"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a377d5b078a4bec3d9f1250834a52413e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a377d5b078a4bec3d9f1250834a52413e">insert_norep</a> (InputIterator it_first, InputIterator it_last)</td></tr>
<tr class="memdesc:a377d5b078a4bec3d9f1250834a52413e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a range of data, dropping all the elements of the container.  <a href="#a377d5b078a4bec3d9f1250834a52413e">More...</a><br/></td></tr>
<tr class="separator:a377d5b078a4bec3d9f1250834a52413e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7daae8b7ad7bf0f4359a46adb0856e2"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:af7daae8b7ad7bf0f4359a46adb0856e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#af7daae8b7ad7bf0f4359a46adb0856e2">insert_norep_if</a> (InputIterator it_first, InputIterator it_last, std::function&lt; bool(const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a79f99777c67918d5cb846d69a6d640c4">value_type</a> &amp;)&gt; M)</td></tr>
<tr class="memdesc:af7daae8b7ad7bf0f4359a46adb0856e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a range of data, dropping all the elements of the container.  <a href="#af7daae8b7ad7bf0f4359a46adb0856e2">More...</a><br/></td></tr>
<tr class="separator:af7daae8b7ad7bf0f4359a46adb0856e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab196d44b28788bee9f9e4efa40871219"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:ab196d44b28788bee9f9e4efa40871219"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ab196d44b28788bee9f9e4efa40871219">insert_rep</a> (InputIterator it_first, InputIterator it_last)</td></tr>
<tr class="memdesc:ab196d44b28788bee9f9e4efa40871219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a range of data, dropping all the elements of the container.  <a href="#ab196d44b28788bee9f9e4efa40871219">More...</a><br/></td></tr>
<tr class="separator:ab196d44b28788bee9f9e4efa40871219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a00c3373270990438c8600befce71e"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a86a00c3373270990438c8600befce71e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a86a00c3373270990438c8600befce71e">insert_rep_if</a> (InputIterator it_first, InputIterator it_last, std::function&lt; bool(const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a79f99777c67918d5cb846d69a6d640c4">value_type</a> &amp;)&gt; M)</td></tr>
<tr class="memdesc:a86a00c3373270990438c8600befce71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a range of data, dropping all the elements of the container.  <a href="#a86a00c3373270990438c8600befce71e">More...</a><br/></td></tr>
<tr class="separator:a86a00c3373270990438c8600befce71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f820aeda677e7958c50edd2e1bcec0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a70f820aeda677e7958c50edd2e1bcec0">connector_pos</a> (signed_type Pos) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a70f820aeda677e7958c50edd2e1bcec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the connector for to insert a new node in the position Pos  <a href="#a70f820aeda677e7958c50edd2e1bcec0">More...</a><br/></td></tr>
<tr class="separator:a70f820aeda677e7958c50edd2e1bcec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0608b732c9ef2e6afeff3bce758046"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#abc0608b732c9ef2e6afeff3bce758046">connector_pointer</a> (<a class="el" href="structcountertree_1_1forest_1_1base__node.html">base_node</a> *Ptr) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:abc0608b732c9ef2e6afeff3bce758046"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the connector for to insert the new node in the position before the node pointed by Ptr  <a href="#abc0608b732c9ef2e6afeff3bce758046">More...</a><br/></td></tr>
<tr class="separator:abc0608b732c9ef2e6afeff3bce758046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18d37002802e5f12201b56e657dccf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#af18d37002802e5f12201b56e657dccf5">connector_rep</a> (const key_t &amp;Val) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:af18d37002802e5f12201b56e657dccf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the pointer and the side in order to insert a node_t in the sorted tree.  <a href="#af18d37002802e5f12201b56e657dccf5">More...</a><br/></td></tr>
<tr class="separator:af18d37002802e5f12201b56e657dccf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33ffc959631711ac11f5046aa67f062"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ad33ffc959631711ac11f5046aa67f062">connector_norep</a> (const key_t &amp;Val, <a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a> &amp;C) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ad33ffc959631711ac11f5046aa67f062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the pointer and the side in order to insert a node_t in the sorted tree.  <a href="#ad33ffc959631711ac11f5046aa67f062">More...</a><br/></td></tr>
<tr class="separator:ad33ffc959631711ac11f5046aa67f062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07e5cca31f51535ac1ca99526cdc975"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#aa07e5cca31f51535ac1ca99526cdc975">pop_front</a> (void)</td></tr>
<tr class="memdesc:aa07e5cca31f51535ac1ca99526cdc975"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the container  <a href="#aa07e5cca31f51535ac1ca99526cdc975">More...</a><br/></td></tr>
<tr class="separator:aa07e5cca31f51535ac1ca99526cdc975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fae1fd979ccb4c2318fb97f7914c2d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a3fae1fd979ccb4c2318fb97f7914c2d9">pop_back</a> (void)</td></tr>
<tr class="memdesc:a3fae1fd979ccb4c2318fb97f7914c2d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the container  <a href="#a3fae1fd979ccb4c2318fb97f7914c2d9">More...</a><br/></td></tr>
<tr class="separator:a3fae1fd979ccb4c2318fb97f7914c2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b39bd1d31fb93e6fef7aa98e3bb0b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#aa0b39bd1d31fb93e6fef7aa98e3bb0b4">erase</a> (<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a> iter)</td></tr>
<tr class="memdesc:aa0b39bd1d31fb93e6fef7aa98e3bb0b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element pointed by the <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> P1  <a href="#aa0b39bd1d31fb93e6fef7aa98e3bb0b4">More...</a><br/></td></tr>
<tr class="separator:aa0b39bd1d31fb93e6fef7aa98e3bb0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f1334b09d0f30628c0eea3cb1bf2f8"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a94f1334b09d0f30628c0eea3cb1bf2f8">erase</a> (<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a> first_it, <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a> last_it)</td></tr>
<tr class="memdesc:a94f1334b09d0f30628c0eea3cb1bf2f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase a range of elements between first_it and last_it  <a href="#a94f1334b09d0f30628c0eea3cb1bf2f8">More...</a><br/></td></tr>
<tr class="separator:a94f1334b09d0f30628c0eea3cb1bf2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4c98cbcb10d0c2cd75dc96332157df"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a2a4c98cbcb10d0c2cd75dc96332157df">erase_if</a> (<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a> first_it, <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a> last_it, std::function&lt; bool(const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a79f99777c67918d5cb846d69a6d640c4">value_type</a> &amp;)&gt; M)</td></tr>
<tr class="memdesc:a2a4c98cbcb10d0c2cd75dc96332157df"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase a range of elements between first_it and last_it  <a href="#a2a4c98cbcb10d0c2cd75dc96332157df">More...</a><br/></td></tr>
<tr class="separator:a2a4c98cbcb10d0c2cd75dc96332157df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17957279e7a1251493fab149470206e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a17957279e7a1251493fab149470206e8">erase_pos</a> (signed_type Pos)</td></tr>
<tr class="memdesc:a17957279e7a1251493fab149470206e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element of the position pos  <a href="#a17957279e7a1251493fab149470206e8">More...</a><br/></td></tr>
<tr class="separator:a17957279e7a1251493fab149470206e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccf3616138b32a1c8c3a6347207b536"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a2ccf3616138b32a1c8c3a6347207b536">erase_pos</a> (signed_type Prim, signed_type NElem)</td></tr>
<tr class="memdesc:a2ccf3616138b32a1c8c3a6347207b536"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the elements between the position Prim and the position Ult. The position Ult is deleted  <a href="#a2ccf3616138b32a1c8c3a6347207b536">More...</a><br/></td></tr>
<tr class="separator:a2ccf3616138b32a1c8c3a6347207b536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246cfbf95e3a2d1c495eb20c7589e786"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a246cfbf95e3a2d1c495eb20c7589e786">erase_pos_if</a> (signed_type Prim, signed_type NElem, std::function&lt; bool(const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a79f99777c67918d5cb846d69a6d640c4">value_type</a> &amp;)&gt; M)</td></tr>
<tr class="memdesc:a246cfbf95e3a2d1c495eb20c7589e786"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the lements between the position Prim and the position Ult. The position Ult is deleted  <a href="#a246cfbf95e3a2d1c495eb20c7589e786">More...</a><br/></td></tr>
<tr class="separator:a246cfbf95e3a2d1c495eb20c7589e786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a54917ad34b3be21be99a6da1cfddb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a3a54917ad34b3be21be99a6da1cfddb7">allocate</a> (<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a4d796f7eda7fcabc120664f917121dc6">size_type</a> cnt, <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a4c6abc9531f2c12dc05a29afbed039a6">const_pointer</a>=NULL)</td></tr>
<tr class="memdesc:a3a54917ad34b3be21be99a6da1cfddb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of memory.  <a href="#a3a54917ad34b3be21be99a6da1cfddb7">More...</a><br/></td></tr>
<tr class="separator:a3a54917ad34b3be21be99a6da1cfddb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567fe9dadd8c8239daa6b845fdcad6d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a567fe9dadd8c8239daa6b845fdcad6d6">deallocate</a> (<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">node_t</a> *p, <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a4d796f7eda7fcabc120664f917121dc6">size_type</a> n=1)</td></tr>
<tr class="memdesc:a567fe9dadd8c8239daa6b845fdcad6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">deallocate a block of memory  <a href="#a567fe9dadd8c8239daa6b845fdcad6d6">More...</a><br/></td></tr>
<tr class="separator:a567fe9dadd8c8239daa6b845fdcad6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158650d46d53adaf99a01c4d875f621d"><td class="memTemplParams" colspan="2">template&lt;typename P , typename... Args&gt; </td></tr>
<tr class="memitem:a158650d46d53adaf99a01c4d875f621d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a158650d46d53adaf99a01c4d875f621d">construct</a> (P *p, Args &amp;&amp;...args) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a158650d46d53adaf99a01c4d875f621d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new object in the memory pointed by p.  <a href="#a158650d46d53adaf99a01c4d875f621d">More...</a><br/></td></tr>
<tr class="separator:a158650d46d53adaf99a01c4d875f621d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d14062b9c8a85a32bc2fd3b45f95ad4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a9d14062b9c8a85a32bc2fd3b45f95ad4">destroy</a> (<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">node_t</a> *p) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a9d14062b9c8a85a32bc2fd3b45f95ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">destroy the object without freeing the memory  <a href="#a9d14062b9c8a85a32bc2fd3b45f95ad4">More...</a><br/></td></tr>
<tr class="separator:a9d14062b9c8a85a32bc2fd3b45f95ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c08b6cc1670e68abcfbb5ae5213670"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcountertree_1_1forest_1_1base__node.html">base_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ab9c08b6cc1670e68abcfbb5ae5213670">ptr_pos</a> (signed_type Pos) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ab9c08b6cc1670e68abcfbb5ae5213670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a position in the tree.  <a href="#ab9c08b6cc1670e68abcfbb5ae5213670">More...</a><br/></td></tr>
<tr class="separator:ab9c08b6cc1670e68abcfbb5ae5213670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf970691af22d66061763de84d8d3875"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structcountertree_1_1forest_1_1base__node.html">base_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#acf970691af22d66061763de84d8d3875">ptr_pos</a> (signed_type Pos) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:acf970691af22d66061763de84d8d3875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a position in the tree.  <a href="#acf970691af22d66061763de84d8d3875">More...</a><br/></td></tr>
<tr class="separator:acf970691af22d66061763de84d8d3875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71ca7f9b8f29b71823dfff8413d5203"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ac71ca7f9b8f29b71823dfff8413d5203">disconnect</a> (<a class="el" href="structcountertree_1_1forest_1_1base__node.html">base_node</a> *PAux) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ac71ca7f9b8f29b71823dfff8413d5203"><td class="mdescLeft">&#160;</td><td class="mdescRight">disconnect the node_t from the tree, and leave it balanced and with the nodes actualized  <a href="#ac71ca7f9b8f29b71823dfff8413d5203">More...</a><br/></td></tr>
<tr class="separator:ac71ca7f9b8f29b71823dfff8413d5203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa117a31b54f5b4c16348279d50bfb181"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#aa117a31b54f5b4c16348279d50bfb181">connect</a> (<a class="el" href="structcountertree_1_1forest_1_1base__node.html">base_node</a> *PAux, <a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a> C) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:aa117a31b54f5b4c16348279d50bfb181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a node_t in the tree and make a rebalanced if necessary.  <a href="#aa117a31b54f5b4c16348279d50bfb181">More...</a><br/></td></tr>
<tr class="separator:aa117a31b54f5b4c16348279d50bfb181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ff340620efde7bcb93c6978b19c67c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ad2ff340620efde7bcb93c6978b19c67c">is_mine</a> (<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a> P1) const </td></tr>
<tr class="memdesc:ad2ff340620efde7bcb93c6978b19c67c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the iterator is pointing to this <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a>.  <a href="#ad2ff340620efde7bcb93c6978b19c67c">More...</a><br/></td></tr>
<tr class="separator:ad2ff340620efde7bcb93c6978b19c67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b229f419ccea87cc6f566faaecd6c6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a5b229f419ccea87cc6f566faaecd6c6b">is_mine</a> (<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">const_reverse_iterator</a> P1) const </td></tr>
<tr class="memdesc:a5b229f419ccea87cc6f566faaecd6c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the iterator is pointing to this <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a>.  <a href="#a5b229f419ccea87cc6f566faaecd6c6b">More...</a><br/></td></tr>
<tr class="separator:a5b229f419ccea87cc6f566faaecd6c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ab9a699cd531e5ff4fea2834a5336c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a92ab9a699cd531e5ff4fea2834a5336c">get_it</a> (<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">node_t</a> *P1)</td></tr>
<tr class="memdesc:a92ab9a699cd531e5ff4fea2834a5336c"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an iterator from a node pointer  <a href="#a92ab9a699cd531e5ff4fea2834a5336c">More...</a><br/></td></tr>
<tr class="separator:a92ab9a699cd531e5ff4fea2834a5336c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e433d9cbcaed0199d61d5f8269c39c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a55e433d9cbcaed0199d61d5f8269c39c">get_cit</a> (const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">node_t</a> *P1)</td></tr>
<tr class="memdesc:a55e433d9cbcaed0199d61d5f8269c39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> from a node pointer  <a href="#a55e433d9cbcaed0199d61d5f8269c39c">More...</a><br/></td></tr>
<tr class="separator:a55e433d9cbcaed0199d61d5f8269c39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec182bb28dbbf031995f1120e86e3536"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0cf6219c86ddf7632a671098d3c02b22">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#aec182bb28dbbf031995f1120e86e3536">get_rit</a> (<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">node_t</a> *P1)</td></tr>
<tr class="memdesc:aec182bb28dbbf031995f1120e86e3536"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an <a class="el" href="classcountertree_1_1forest_1_1reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">reverse_iterator</a> from a node pointer  <a href="#aec182bb28dbbf031995f1120e86e3536">More...</a><br/></td></tr>
<tr class="separator:aec182bb28dbbf031995f1120e86e3536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b3fae2f5a130f0ca42fa85a7041eeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a15b3fae2f5a130f0ca42fa85a7041eeb">get_crit</a> (const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">node_t</a> *P1)</td></tr>
<tr class="memdesc:a15b3fae2f5a130f0ca42fa85a7041eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an const_ireverse_terator from a node pointer  <a href="#a15b3fae2f5a130f0ca42fa85a7041eeb">More...</a><br/></td></tr>
<tr class="separator:a15b3fae2f5a130f0ca42fa85a7041eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405f368735323d6cac4a56c25e618030"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a405f368735323d6cac4a56c25e618030">upgrade</a> (<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a> CT)</td></tr>
<tr class="memdesc:a405f368735323d6cac4a56c25e618030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to an iterator.  <a href="#a405f368735323d6cac4a56c25e618030">More...</a><br/></td></tr>
<tr class="separator:a405f368735323d6cac4a56c25e618030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500134b78c8754c17a31f110b02ae050"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a500134b78c8754c17a31f110b02ae050">it_begin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a500134b78c8754c17a31f110b02ae050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56774ce59fb453391b5a53bd929a95bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a56774ce59fb453391b5a53bd929a95bc">begin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a56774ce59fb453391b5a53bd929a95bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23206879d1f981d258a65a053e91fac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#af23206879d1f981d258a65a053e91fac">it_end</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:af23206879d1f981d258a65a053e91fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bed5373328cc8f91a74d9f0a2e7502"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a35bed5373328cc8f91a74d9f0a2e7502">end</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a35bed5373328cc8f91a74d9f0a2e7502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756aca92af630558ebdcbf7325bb7195"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a756aca92af630558ebdcbf7325bb7195">it_rbegin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a756aca92af630558ebdcbf7325bb7195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae407b7606da28d08f5c4bf9ac52cdf0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae407b7606da28d08f5c4bf9ac52cdf0a">it_rend</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ae407b7606da28d08f5c4bf9ac52cdf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0beb9ef66b1c990e5474d86641892a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0f0beb9ef66b1c990e5474d86641892a">cit_begin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a0f0beb9ef66b1c990e5474d86641892a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb02e710a10a819438c6710b9d9b1ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#acbb02e710a10a819438c6710b9d9b1ff">begin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:acbb02e710a10a819438c6710b9d9b1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4714b49d0e4f4128c6d94264cb1d7fdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a4714b49d0e4f4128c6d94264cb1d7fdf">cbegin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a4714b49d0e4f4128c6d94264cb1d7fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d2ecb97c3ebc8cf69aa827422c6b9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a09d2ecb97c3ebc8cf69aa827422c6b9a">cit_end</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a09d2ecb97c3ebc8cf69aa827422c6b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2bf379bf679011383294ed2e3fb3c10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ad2bf379bf679011383294ed2e3fb3c10">end</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ad2bf379bf679011383294ed2e3fb3c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4f62af2bda544ebde07064b101a4c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#afb4f62af2bda544ebde07064b101a4c0">cend</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:afb4f62af2bda544ebde07064b101a4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bc5b1d3d855dc7f9fa5959b47b5936"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#aa7bc5b1d3d855dc7f9fa5959b47b5936">cit_rbegin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aa7bc5b1d3d855dc7f9fa5959b47b5936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67abb52fffc4ec0e676c888d0af117dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a67abb52fffc4ec0e676c888d0af117dc">cit_rend</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a67abb52fffc4ec0e676c888d0af117dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a7897cb854c8855bfee57dee0109bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0cf6219c86ddf7632a671098d3c02b22">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a17a7897cb854c8855bfee57dee0109bf">rit_begin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a17a7897cb854c8855bfee57dee0109bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ad090cdd51d09f4a67ff7fe60b08d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0cf6219c86ddf7632a671098d3c02b22">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a64ad090cdd51d09f4a67ff7fe60b08d4">rit_end</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a64ad090cdd51d09f4a67ff7fe60b08d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a92add1c175fcc5796ffc9551a11d15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0cf6219c86ddf7632a671098d3c02b22">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a5a92add1c175fcc5796ffc9551a11d15">rit_rbegin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a5a92add1c175fcc5796ffc9551a11d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80810a262fce766a8a6adb93e587b8d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0cf6219c86ddf7632a671098d3c02b22">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80810a262fce766a8a6adb93e587b8d8">rbegin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a80810a262fce766a8a6adb93e587b8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7285fea1a0a6dbc2a73a029fabefad25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0cf6219c86ddf7632a671098d3c02b22">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a7285fea1a0a6dbc2a73a029fabefad25">rit_rend</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a7285fea1a0a6dbc2a73a029fabefad25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad81ab405aa3cdf6d5ea9d1ce808e21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0cf6219c86ddf7632a671098d3c02b22">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a3ad81ab405aa3cdf6d5ea9d1ce808e21">rend</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a3ad81ab405aa3cdf6d5ea9d1ce808e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98577405d09600feac371c8bc31338e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a98577405d09600feac371c8bc31338e4">crit_begin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a98577405d09600feac371c8bc31338e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06aed774706b13a610e5dfb8310fe100"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a06aed774706b13a610e5dfb8310fe100">crit_end</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a06aed774706b13a610e5dfb8310fe100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5211f007f6e7b4a07af3376c617c564d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a5211f007f6e7b4a07af3376c617c564d">crit_rbegin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a5211f007f6e7b4a07af3376c617c564d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1da6e65e637f60a89f6abd3fa3c4ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#abc1da6e65e637f60a89f6abd3fa3c4ae">rbegin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:abc1da6e65e637f60a89f6abd3fa3c4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54cdc8f863a938d61456a5cf631703d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a54cdc8f863a938d61456a5cf631703d5">crbegin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a54cdc8f863a938d61456a5cf631703d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce57af0d9201436a46de70e8fedd882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a4ce57af0d9201436a46de70e8fedd882">crit_rend</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a4ce57af0d9201436a46de70e8fedd882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c093b941ddceda9ecf6f6b89387bf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a35c093b941ddceda9ecf6f6b89387bf0">rend</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a35c093b941ddceda9ecf6f6b89387bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480f59426e2585b31bf29ae2d8daf3b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a480f59426e2585b31bf29ae2d8daf3b4">crend</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a480f59426e2585b31bf29ae2d8daf3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9fea0dbf44929cef68da4106f8a420d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ac9fea0dbf44929cef68da4106f8a420d">remove_const</a> (void) const </td></tr>
<tr class="memdesc:ac9fea0dbf44929cef68da4106f8a420d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for to obtain <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a> pointer from a const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a>.  <a href="#ac9fea0dbf44929cef68da4106f8a420d">More...</a><br/></td></tr>
<tr class="separator:ac9fea0dbf44929cef68da4106f8a420d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2bf9f602ca8ec14b0b3a3c38d287b7b7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a2bf9f602ca8ec14b0b3a3c38d287b7b7">upgrade</a> (<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0aa91092ed36b3144a31906b9ba78054">base_node_t</a> *P) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a2bf9f602ca8ec14b0b3a3c38d287b7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a base_node_t pointer in a node_t&lt;T&gt; pointer.  <a href="#a2bf9f602ca8ec14b0b3a3c38d287b7b7">More...</a><br/></td></tr>
<tr class="separator:a2bf9f602ca8ec14b0b3a3c38d287b7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368d066a25ea3c98113587d8763c0fc4"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a368d066a25ea3c98113587d8763c0fc4">upgrade</a> (const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0aa91092ed36b3144a31906b9ba78054">base_node_t</a> *P) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a368d066a25ea3c98113587d8763c0fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a base_node_t pointer in a node_t&lt;T&gt; pointer.  <a href="#a368d066a25ea3c98113587d8763c0fc4">More...</a><br/></td></tr>
<tr class="separator:a368d066a25ea3c98113587d8763c0fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a43de951fa4f29aaac65edd211d79fa14"><td class="memItemLeft" align="right" valign="top">filter_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a43de951fa4f29aaac65edd211d79fa14">fltr</a></td></tr>
<tr class="separator:a43de951fa4f29aaac65edd211d79fa14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abef94b89eb2c79b3ca6ac525e6cbbb"><td class="memItemLeft" align="right" valign="top">comp_key_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a6abef94b89eb2c79b3ca6ac525e6cbbb">cmpr</a></td></tr>
<tr class="separator:a6abef94b89eb2c79b3ca6ac525e6cbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a374ddaeb42fdcf8c3527820c98357998"><td class="memItemLeft" align="right" valign="top">alloc_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a374ddaeb42fdcf8c3527820c98357998">value_alloc</a></td></tr>
<tr class="separator:a374ddaeb42fdcf8c3527820c98357998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7bb69ee5b43461a27c1773f0bdd5d70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a435616fae6b22fcb60996905ea17aef1">tree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ab7bb69ee5b43461a27c1773f0bdd5d70">T</a></td></tr>
<tr class="separator:ab7bb69ee5b43461a27c1773f0bdd5d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt;<br/>
class countertree::forest::sorted_tree&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;</h3>

<p>This class is a countertree sorted, with all the functions needed for manage the ordered information. <br/>
 It has access by position and random access iterators Due to this all the operations ( insert, delete, access) a O( logN). <br/>
. </p>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value_t</td><td>: value to store </td></tr>
    <tr><td class="paramname">key_t</td><td>: value used to compare </td></tr>
    <tr><td class="paramname">filter_t</td><td>Object used to obtain a key_t from a value_t </td></tr>
    <tr><td class="paramname">comp_key_t</td><td>: object used to compare two keys </td></tr>
    <tr><td class="paramname">alloc_t</td><td>: object used to allocate the nodes in the memory </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00061">61</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a9efecf2ea1f3b221a5382f2a0ef9e746"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef alloc_t <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a9efecf2ea1f3b221a5382f2a0ef9e746">allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00074">74</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0aa91092ed36b3144a31906b9ba78054"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcountertree_1_1forest_1_1base__node.html">c_forest::base_node</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0aa91092ed36b3144a31906b9ba78054">base_node_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00076">76</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a25b5bd26451460adb2ec43a8ed1815bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">tree::const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00080">80</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4c6abc9531f2c12dc05a29afbed039a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a79f99777c67918d5cb846d69a6d640c4">value_type</a>* <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a4c6abc9531f2c12dc05a29afbed039a6">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00071">71</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0cc9f4d8eb2d47eb0d64bd822a53b1af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a79f99777c67918d5cb846d69a6d640c4">value_type</a>&amp; <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0cc9f4d8eb2d47eb0d64bd822a53b1af">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00073">73</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80d2d1888631c7aa84f1740348557a8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">tree::const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00082">82</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a326fc76dfea8f0343a1e92da0e5a3c5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacecountertree_1_1common.html#aacea70d0e38fcfefebf3b6ad0a88ae6f">c_common::signed_type</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a326fc76dfea8f0343a1e92da0e5a3c5d">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00068">68</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a59c7473d19fefb5f0c5208211a62093a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">tree::iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00079">79</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2a86f27200857c04dd1f46e11973e2a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef alloc_t::template rebind&lt;<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">node_t</a>&gt;::other <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a2a86f27200857c04dd1f46e11973e2a1">node_alloc_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00077">77</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae2502bd7010efa55a0f7f7e0906a8aeb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcountertree_1_1forest_1_1node.html">c_forest::node</a>&lt;value_t&gt; <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">node_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00075">75</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0d2743936ab86778974ee7182d48c901"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a79f99777c67918d5cb846d69a6d640c4">value_type</a>* <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0d2743936ab86778974ee7182d48c901">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00070">70</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a481ca6fcc8465e51f98a432abee85832"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a79f99777c67918d5cb846d69a6d640c4">value_type</a>&amp; <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a481ca6fcc8465e51f98a432abee85832">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00072">72</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0cf6219c86ddf7632a671098d3c02b22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">tree::reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0cf6219c86ddf7632a671098d3c02b22">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00081">81</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d796f7eda7fcabc120664f917121dc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacecountertree_1_1common.html#aacea70d0e38fcfefebf3b6ad0a88ae6f">c_common::signed_type</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a4d796f7eda7fcabc120664f917121dc6">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00067">67</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a435616fae6b22fcb60996905ea17aef1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html">c_forest::tree</a>&lt;value_t,<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a2a86f27200857c04dd1f46e11973e2a1">node_alloc_t</a>&gt; <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a435616fae6b22fcb60996905ea17aef1">tree</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00078">78</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a79f99777c67918d5cb846d69a6d640c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef value_t <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a79f99777c67918d5cb846d69a6d640c4">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00069">69</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aeb5c36945969ea582e18bfc8b92f4a47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a> </td>
          <td>(</td>
          <td class="paramtype">const comp_key_t &amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>comp_key_t&#160;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const alloc_t &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>alloc_t&#160;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is the construct of the class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F1</td><td>: object filter_t </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C1</td><td>: object comp_key_t </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>: object alloc_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00129">129</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f7c53c03cc1b71e51616330ecbe498d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>VT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VT</td><td>: <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00138">138</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac23d17df9bc976fd40a1a907e654a65b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>VT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VT</td><td>: <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00146">146</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6848a8c166f26ce8776fb34e537f03e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename alloc_t2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>VT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>: <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a> after the copy </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00157">157</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4edbca9bc566d7abb087d3849f5c6ff7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::~<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destructor of the class </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is virtual </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00166">166</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3a54917ad34b3be21be99a6da1cfddb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">node_t</a>* <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a4d796f7eda7fcabc120664f917121dc6">size_type</a>&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a4c6abc9531f2c12dc05a29afbed039a6">const_pointer</a>&#160;</td>
          <td class="paramname"> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a block of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cnt</td><td>: number of objects to allocate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>unused </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the object allocated </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01114">1114</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abeac6f9a589cd19a6f354277470bb7ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_t&amp; <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const_reference to the last element in the <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the last element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00681">681</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb719a9e8cd7656ad32d26a2ae1d37db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t&amp; <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const_reference to the last element in the <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the last element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00691">691</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a56774ce59fb453391b5a53bd929a95bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01312">1312</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acbb02e710a10a819438c6710b9d9b1ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01333">1333</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4714b49d0e4f4128c6d94264cb1d7fdf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01334">1334</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afb4f62af2bda544ebde07064b101a4c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::cend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01337">1337</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0f0beb9ef66b1c990e5474d86641892a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::cit_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01332">1332</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a09d2ecb97c3ebc8cf69aa827422c6b9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::cit_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01335">1335</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa7bc5b1d3d855dc7f9fa5959b47b5936"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::cit_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01338">1338</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a67abb52fffc4ec0e676c888d0af117dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::cit_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01339">1339</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5295f09d50c307874060fc62a6801a77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete all the elements of the <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00225">225</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa117a31b54f5b4c16348279d50bfb181"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcountertree_1_1forest_1_1base__node.html">base_node</a> *&#160;</td>
          <td class="paramname"><em>PAux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a>&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a node_t in the tree and make a rebalanced if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PAux</td><td>: pointer to the node_t for to be inserted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: pointer to the node_t where insert PAux </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Left</td><td>: indicates which node_t of P1 link to PAux </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the tree is empty P1 and Left are not checked<br/>
 This function works well when the tree is empty<br/>
 All the counters of the nodes from the insertion point to the root must be previously incremented </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01209">1209</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad33ffc959631711ac11f5046aa67f062"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">node_t</a>* <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::connector_norep </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>Val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the pointer and the side in order to insert a node_t in the sorted tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Val</td><td>: value to insert </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P1</td><td>: Pointer to the node_t where insert </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">left_side</td><td>: Indicate which side of P1 in the insertion pointer true: left pointer , false: right pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if don't exist return NULL. If exist return the pointer to the node with the key equal to Val </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00928">928</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc0608b732c9ef2e6afeff3bce758046"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::connector_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcountertree_1_1forest_1_1base__node.html">base_node</a> *&#160;</td>
          <td class="paramname"><em>Ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the connector for to insert the new node in the position before the node pointed by Ptr </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Ptr</td><td>: Pointer to the node_t, before which we want insert a new node_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>connector for to insert </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00890">890</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a70f820aeda677e7958c50edd2e1bcec0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::connector_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the connector for to insert a new node in the position Pos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to insert the value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>connector for the insertion </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00879">879</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af18d37002802e5f12201b56e657dccf5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::connector_rep </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the pointer and the side in order to insert a node_t in the sorted tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Val</td><td>: value to insert </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P1</td><td>: Pointer to the node_t where insert </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">left_side</td><td>: Indicate which side of P1 in the insertion pointer true: left pointer , false: right pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>his function permit the insertion of repeated elements </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00904">904</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a238ba7cda3c2934e42f3d6219a1765d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::const_iterator_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos1</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a position in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the position. If don't exists return <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a35bed5373328cc8f91a74d9f0a2e7502">end()</a> an exception </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log N) </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00524">524</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a158650d46d53adaf99a01c4d875f621d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename P , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">P *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new object in the memory pointed by p. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>: pointer to the memory for to construct the object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>: list of parameters used in the copy constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01137">1137</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a56e9b98ab1b4ea4a1bcc1a9cb83588e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>K</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of elements with the key K. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>: key ti find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of repetitions of the key K </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00579">579</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a54cdc8f863a938d61456a5cf631703d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::crbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01378">1378</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a480f59426e2585b31bf29ae2d8daf3b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::crend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01381">1381</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a98577405d09600feac371c8bc31338e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::crit_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01374">1374</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a06aed774706b13a610e5dfb8310fe100"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::crit_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01375">1375</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5211f007f6e7b4a07af3376c617c564d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::crit_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01376">1376</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4ce57af0d9201436a46de70e8fedd882"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::crit_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01379">1379</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a567fe9dadd8c8239daa6b845fdcad6d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::deallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">node_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a4d796f7eda7fcabc120664f917121dc6">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deallocate a block of memory </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>: pointer to deallocate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: number of objects to deallocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">:</td><td>bad_alloc </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01125">1125</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9d14062b9c8a85a32bc2fd3b45f95ad4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">node_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destroy the object without freeing the memory </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>: pointer p to the object to destroy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01146">1146</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac71ca7f9b8f29b71823dfff8413d5203"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcountertree_1_1forest_1_1base__node.html">base_node</a> *&#160;</td>
          <td class="paramname"><em>PAux</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>disconnect the node_t from the tree, and leave it balanced and with the nodes actualized </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PAux</td><td>: pointer to the node_t to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01194">1194</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a66450394bb25e35602ff933e3ae17967"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::emplace_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcountertree_1_1forest_1_1connector.html">connector</a>&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in a the position specified by the connector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>: connector which indicate where must insert the node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>: arguments to build the node to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00723">723</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a28eef8af614d4199b56d2fca1c99fe23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a>,bool&gt; <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::emplace_value_norep </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a value in the tree. If the value exist, it is not inserted </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args,:</td><td>arguments for to build the node to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair &lt;iterator,bool&gt; with the iterator to the element inserted or or to the element that prevented the insertion, and a bool indication if the insertion is done </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00778">778</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1b07268d13c3f8c89b231cefc4fc804f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::emplace_value_rep </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a value Val in the sorted tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args,:</td><td>arguments for to build the node to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the node_t inserted. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>his function permit the insertion of repeated elements </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00744">744</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a239d424adb2aa3aa0d93d523367baf7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>indicate if the map is empty </p>
<dl class="section return"><dt>Returns</dt><dd>true if the map is empty, false in any other case </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00272">272</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a35bed5373328cc8f91a74d9f0a2e7502"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01314">1314</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad2bf379bf679011383294ed2e3fb3c10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01336">1336</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adced7c12d9782761c6a4280e4b7b869c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a>, <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a>&gt; <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>K</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a pair of const_iterators, lower_bound and upper bound of a key K </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>: key to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of const_iterators, the first is le lower_bound and the second </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00554">554</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaedbc911e7bd5462246e28c35251e2a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a>,<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a>&gt; <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>K</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a pair of const_iterators, lower_bound and upper bound of a key K </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>: key to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of const_iterators, the first is le lower_bound and the second </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00567">567</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa0b39bd1d31fb93e6fef7aa98e3bb0b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element pointed by the <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> P1 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the element to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( constant) </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01020">1020</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a94f1334b09d0f30628c0eea3cb1bf2f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase a range of elements between first_it and last_it </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first_it</td><td>: <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last_it</td><td>: <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the final element of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements erased </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01031">1031</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2a4c98cbcb10d0c2cd75dc96332157df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a79f99777c67918d5cb846d69a6d640c4">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase a range of elements between first_it and last_it </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first_it</td><td>: <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last_it</td><td>: <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the final element of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements erased </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01042">1042</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a17957279e7a1251493fab149470206e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::erase_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element of the position pos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>: position to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01053">1053</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2ccf3616138b32a1c8c3a6347207b536"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::erase_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Prim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>NElem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the elements between the position Prim and the position Ult. The position Ult is deleted </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Prim</td><td>: position to the first element to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NElem</td><td>: number of elements to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01065">1065</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a246cfbf95e3a2d1c495eb20c7589e786"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::erase_pos_if </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Prim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>NElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a79f99777c67918d5cb846d69a6d640c4">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the lements between the position Prim and the position Ult. The position Ult is deleted </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Prim</td><td>: position to the first element to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NElem</td><td>: Number of elements to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01077">1077</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a59ee0be7c7498a204d46d5bd5eedbdf3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::find_norep </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>K</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the element with this Key. If don't exist return <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a35bed5373328cc8f91a74d9f0a2e7502">end()</a> <br/>
 This function supouse there is only one element with the key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Key</td><td>: key to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element if exist, or <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a35bed5373328cc8f91a74d9f0a2e7502">end()</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00356">356</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abd60fdfaa8258cf317efbd823e7de668"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::find_norep </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>K</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the element with this Key. If don't exist return <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a35bed5373328cc8f91a74d9f0a2e7502">end()</a> <br/>
 This function supouse there is only one element with the key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Key</td><td>: key to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element if exist, or <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a35bed5373328cc8f91a74d9f0a2e7502">end()</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00381">381</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1be8202a9674587a826a21bda55d2dfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::find_rep </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>K</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the first element with this Key if don't exist return <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a35bed5373328cc8f91a74d9f0a2e7502">end()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Key</td><td>: key to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the element if exist, or <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a35bed5373328cc8f91a74d9f0a2e7502">end()</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00319">319</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad9eebaac17fc5de6762138d149b18432"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::find_rep </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>K</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the first element with this Key if don't exist return <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a35bed5373328cc8f91a74d9f0a2e7502">end()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Key</td><td>: key to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the element if exist, or <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a35bed5373328cc8f91a74d9f0a2e7502">end()</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00343">343</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6dc403226460c7db6818564b179b81a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_t&amp; <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const_reference to the first element in the <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the first element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00661">661</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb7b6fa8bf27938735988281238828d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t&amp; <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const_reference to the first element in the <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the first element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00671">671</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad34739458d94cd4702c535a66e723dc8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a9efecf2ea1f3b221a5382f2a0ef9e746">allocator_type</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the object allocator of the set </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>object allocator </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00611">611</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a55e433d9cbcaed0199d61d5f8269c39c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::get_cit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">node_t</a> *&#160;</td>
          <td class="paramname"><em>P1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create an <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> from a node pointer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator which point this node </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01274">1274</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a15b3fae2f5a130f0ca42fa85a7041eeb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::get_crit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">node_t</a> *&#160;</td>
          <td class="paramname"><em>P1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create an const_ireverse_terator from a node pointer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator which point this node </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01288">1288</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a92ab9a699cd531e5ff4fea2834a5336c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::get_it </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">node_t</a> *&#160;</td>
          <td class="paramname"><em>P1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create an iterator from a node pointer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator which point this node </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01267">1267</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aec182bb28dbbf031995f1120e86e3536"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0cf6219c86ddf7632a671098d3c02b22">reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::get_rit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">node_t</a> *&#160;</td>
          <td class="paramname"><em>P1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create an <a class="el" href="classcountertree_1_1forest_1_1reverse__iterator.html" title="This class represent the iterators of the vector_tree structure.">reverse_iterator</a> from a node pointer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator which point this node </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01281">1281</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab012bdc51bc0656e056bf20b81b464b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a435616fae6b22fcb60996905ea17aef1">tree</a>&amp; <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::get_tree </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a const reference to the internal tree </p>
<dl class="section return"><dt>Returns</dt><dd>const reference to the internal tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00282">282</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a377d5b078a4bec3d9f1250834a52413e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::insert_norep </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a range of data, dropping all the elements of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">it_first</td><td>: iterator to the first element to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">it_last</td><td>: Iterator to the end of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00804">804</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af7daae8b7ad7bf0f4359a46adb0856e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::insert_norep_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a79f99777c67918d5cb846d69a6d640c4">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a range of data, dropping all the elements of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">it_first</td><td>: iterator to the first element to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">it_last</td><td>: Iterator to the end of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00819">819</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab196d44b28788bee9f9e4efa40871219"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::insert_rep </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a range of data, dropping all the elements of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">it_first</td><td>: iterator to the first element to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">it_last</td><td>: Iterator to the end of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00837">837</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a86a00c3373270990438c8600befce71e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::insert_rep_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a79f99777c67918d5cb846d69a6d640c4">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a range of data, dropping all the elements of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">it_first</td><td>: iterator to the first element to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">it_last</td><td>: Iterator to the end of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00852">852</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a06cb6dc1bc528c1b5cd75bd4f3b62a95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a>,bool&gt; <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::insert_value_norep </td>
          <td>(</td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a value in the tree. If the value exist, it is not inserted </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Val</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair &lt;iterator,bool&gt; with the iterator to the element inserted or or to the element that prevented the insertion, and a bool indication if the insertion is done </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00763">763</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae0c1f7e08ea7f94423c89905d648974f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::insert_value_rep </td>
          <td>(</td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a value Val in the sorted tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Val</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the node_t inserted. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>his function permit the insertion of repeated elements </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00733">733</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad2ff340620efde7bcb93c6978b19c67c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::is_mine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a>&#160;</td>
          <td class="paramname"><em>P1</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the iterator is pointing to this <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: iterator to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(true/false ) Indicate if it is pointing to this <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01247">1247</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5b229f419ccea87cc6f566faaecd6c6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::is_mine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">const_reverse_iterator</a>&#160;</td>
          <td class="paramname"><em>P1</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the iterator is pointing to this <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: iterator to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(true/false ) Indicate if it is pointing to this <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01257">1257</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a500134b78c8754c17a31f110b02ae050"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::it_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01311">1311</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af23206879d1f981d258a65a053e91fac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::it_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01313">1313</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a756aca92af630558ebdcbf7325bb7195"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::it_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01315">1315</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae407b7606da28d08f5c4bf9ac52cdf0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::it_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01316">1316</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3a95f50c7f3805560ee8719ad30a0ab7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::iterator_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a position in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the position. If don't exists return <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a35bed5373328cc8f91a74d9f0a2e7502">end()</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log N) </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00513">513</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa78c7d5841c23cf9f08463373066e69a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">comp_key_t <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::key_comp </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the object used to compare two keys </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>object comp_key </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00592">592</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae63443f36a70f6a62ae7c40ffae78226"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>K</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find a key in the tree. If there are repeated elements, return an <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the first of them. If the key don't exist return an iterator to the first element greater than the key </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>: key to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the element. If don't exist <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a35bed5373328cc8f91a74d9f0a2e7502">end()</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00430">430</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a64804ac994c5028a12ce268f60bdbed7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>K</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find a key in the tree. If there are repeated elements, return an <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the first of them. If the key don't exist return an iterator to the first element greater than the key </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>: key to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the element. If don't exist <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a35bed5373328cc8f91a74d9f0a2e7502">end()</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00467">467</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af04a22a766c81f9f2c91384f6b839bc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::max_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the maximun size of the container </p>
<dl class="section return"><dt>Returns</dt><dd>maximun size of the container </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00264">264</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa7a45c13724219d6608d514f5fb4d1b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a2a86f27200857c04dd1f46e11973e2a1">node_alloc_t</a>&amp; <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::node_alloc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function provides a reference to the node_t allocator of the internal tree object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">@return</td><td>reference to the node_t allocator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00602">602</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a92204dff437bb218e501ef42806a0ace"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a>&amp; <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>VT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asignation operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>: <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a> after the copy </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00192">192</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acf6999cf4af9d3b15926ab69f9d5b818"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename alloc_t2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a>&amp; <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>VT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asignation operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>: <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a> after the copy </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00204">204</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a52dcb5992fa8389894923db1eb5167ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a>&amp; <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asignation operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>: <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a> after the copy </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00215">215</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3fae1fd979ccb4c2318fb97f7914c2d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::pop_back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant) </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01010">1010</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa07e5cca31f51535ac1ca99526cdc975"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::pop_front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (constant) </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01000">1000</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7802aa8d674180088bd0819188097dac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_t&amp; <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a position in the <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the position. If don't exists throws an exception </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log N) </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00640">640</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa887cdd5913adb214a61d5e059cc47e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t&amp; <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos1</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a position in the <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the position. If don't exists throws an exception </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log N) </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00651">651</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab9c08b6cc1670e68abcfbb5ae5213670"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcountertree_1_1forest_1_1base__node.html">base_node</a>* <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::ptr_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a position in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the position. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log N). This function is called by others functions with the position controlled </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01172">1172</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acf970691af22d66061763de84d8d3875"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structcountertree_1_1forest_1_1base__node.html">base_node</a>* <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::ptr_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a position in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the position. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log N). This function is called by others functions with the position controlled </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01183">1183</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80810a262fce766a8a6adb93e587b8d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0cf6219c86ddf7632a671098d3c02b22">reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01356">1356</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc1da6e65e637f60a89f6abd3fa3c4ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01377">1377</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a105e2686329bdc16a6ef8b7532180fe0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::read_norep </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an copy of the object in the tree. If exist return true. If don't exist return false <br/>
 This function supouse there is only one element with the key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>: object where copy the element of the tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Key</td><td>: key to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true- copy in V false didn't find in the tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00394">394</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9856f4a48ca48983cfc15e90f3fca951"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::read_rep </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an copy of the object in the tree. If exist return true. If don't exist return false <br/>
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>: object where copy the element of the tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Key</td><td>: key to search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shift</td><td>: shift from the first element with the key K </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true- copy in V false didn't find in the tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00411">411</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac9fea0dbf44929cef68da4106f8a420d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a>* <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::remove_const </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function for to obtain <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a> pointer from a const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01440">1440</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3ad81ab405aa3cdf6d5ea9d1ce808e21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0cf6219c86ddf7632a671098d3c02b22">reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01358">1358</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a35c093b941ddceda9ecf6f6b89387bf0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a80d2d1888631c7aa84f1740348557a8e">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01380">1380</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a17a7897cb854c8855bfee57dee0109bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0cf6219c86ddf7632a671098d3c02b22">reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::rit_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01353">1353</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a64ad090cdd51d09f4a67ff7fe60b08d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0cf6219c86ddf7632a671098d3c02b22">reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::rit_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01354">1354</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a92add1c175fcc5796ffc9551a11d15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0cf6219c86ddf7632a671098d3c02b22">reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::rit_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01355">1355</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7285fea1a0a6dbc2a73a029fabefad25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0cf6219c86ddf7632a671098d3c02b22">reverse_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::rit_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01357">1357</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a66971ffe3ede965768e902a1b31f3727"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the number of elements in the <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a> </p>
<dl class="section return"><dt>Returns</dt><dd>number of elements in the <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a> </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00256">256</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a77b8abacc30729de63e25aaa23a8708c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>swap the data between the two <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>: <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html" title="This class is a countertree sorted, with all the functions needed for manage the ordered information...">sorted_tree</a> to swap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00234">234</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a405f368735323d6cac4a56c25e618030"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::upgrade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a>&#160;</td>
          <td class="paramname"><em>CT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to an iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td><a class="el" href="structcountertree_1_1forest_1_1base__node.html" title="This class represent a node of the tree.">base_node</a> pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01295">1295</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2bf9f602ca8ec14b0b3a3c38d287b7b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">node_t</a>* <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::upgrade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0aa91092ed36b3144a31906b9ba78054">base_node_t</a> *&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a base_node_t pointer in a node_t&lt;T&gt; pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>base_node_t pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01449">1449</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a368d066a25ea3c98113587d8763c0fc4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#ae2502bd7010efa55a0f7f7e0906a8aeb">node_t</a>* <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::upgrade </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a0aa91092ed36b3144a31906b9ba78054">base_node_t</a> *&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a base_node_t pointer in a node_t&lt;T&gt; pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>base_node_t pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer </dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l01458">1458</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8481530fc062c87024604b6cacab38e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a59c7473d19fefb5f0c5208211a62093a">iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>K</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return an <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the first element greater than K. If don't exist return <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a35bed5373328cc8f91a74d9f0a2e7502">end()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>: value to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the first element greater than K If don't exist return <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a35bed5373328cc8f91a74d9f0a2e7502">end()</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00480">480</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a521cc180c6c439d79185b9f6e31eb31b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a25b5bd26451460adb2ec43a8ed1815bb">const_iterator</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>K</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return an <a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the first element greater than K. If don't exist return <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a35bed5373328cc8f91a74d9f0a2e7502">end()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>: value to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcountertree_1_1forest_1_1const__iterator.html" title="This class represent the iterators of the vector_tree structure.">const_iterator</a> to the first element greater than K If don't exist return <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a35bed5373328cc8f91a74d9f0a2e7502">end()</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00502">502</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a6abef94b89eb2c79b3ca6ac525e6cbbb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">comp_key_t <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::cmpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00092">92</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a43de951fa4f29aaac65edd211d79fa14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">filter_t <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::fltr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00091">91</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab7bb69ee5b43461a27c1773f0bdd5d70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html#a435616fae6b22fcb60996905ea17aef1">tree</a> <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::T</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00089">89</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a374ddaeb42fdcf8c3527820c98357998"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, typename key_t = value_t, typename filter_t = filter_set&lt;key_t,value_t&gt;, typename comp_key_t = std::less&lt;key_t&gt;, typename alloc_t = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">alloc_t <a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">countertree::forest::sorted_tree</a>&lt; value_t, key_t, filter_t, comp_key_t, alloc_t &gt;::value_alloc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sorted__tree_8hpp_source.html#l00088">88</a> of file <a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="sorted__tree_8hpp_source.html">sorted_tree.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecountertree.html">countertree</a></li><li class="navelem"><a class="el" href="namespacecountertree_1_1forest.html">forest</a></li><li class="navelem"><a class="el" href="classcountertree_1_1forest_1_1sorted__tree.html">sorted_tree</a></li>
    <li class="footer">Generated on Tue Jul 30 2013 18:10:28 for Countertree by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
