<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>[ countertree + suballocator ]: countertree::cntree_multiset&lt; value_t, cnc, comp_key_t, alloc_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">[ countertree + suballocator ]
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00017.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="a00154.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">countertree::cntree_multiset&lt; value_t, cnc, comp_key_t, alloc_t &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class have the same interface than the STL set, plus access by position with the function at, and random access iterators.  
 <a href="a00017.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00112_source.html">cntree_multiset.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a83f74fcec6c1b8ce82f7e9d32b659f44"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00023.html">config_fastmutex</a>&lt; cnc &gt;<br class="typebreak"/>
::fastmutex_data&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a83f74fcec6c1b8ce82f7e9d32b659f44">mtx_data</a></td></tr>
<tr class="separator:a83f74fcec6c1b8ce82f7e9d32b659f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e82f00b98dc461b49080d82914e333"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00051.html">mutex_read</a>&lt; <a class="el" href="a00017.html#a83f74fcec6c1b8ce82f7e9d32b659f44">mtx_data</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a58e82f00b98dc461b49080d82914e333">mtx_read</a></td></tr>
<tr class="separator:a58e82f00b98dc461b49080d82914e333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa142db9e70c7ad8256e1a6c325670e47"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00053.html">mutex_write</a>&lt; <a class="el" href="a00017.html#a83f74fcec6c1b8ce82f7e9d32b659f44">mtx_data</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#aa142db9e70c7ad8256e1a6c325670e47">mtx_write</a></td></tr>
<tr class="separator:aa142db9e70c7ad8256e1a6c325670e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f986a5e808b1383c70213e1932aa09"><td class="memItemLeft" align="right" valign="top">typedef value_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#ab5f986a5e808b1383c70213e1932aa09">key_t</a></td></tr>
<tr class="separator:ab5f986a5e808b1383c70213e1932aa09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd04cfcfa5f895aacf2d507d0ab7b67c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00038.html">filter_set</a>&lt; <a class="el" href="a00017.html#ab5f986a5e808b1383c70213e1932aa09">key_t</a>, <br class="typebreak"/>
value_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#acd04cfcfa5f895aacf2d507d0ab7b67c">filter_t</a></td></tr>
<tr class="separator:acd04cfcfa5f895aacf2d507d0ab7b67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58b629a05562913c9024181967262c4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00096.html">c_forest::sorted_tree</a><br class="typebreak"/>
&lt; value_t, <a class="el" href="a00017.html#ab5f986a5e808b1383c70213e1932aa09">key_t</a>, <a class="el" href="a00017.html#acd04cfcfa5f895aacf2d507d0ab7b67c">filter_t</a>, <br class="typebreak"/>
comp_key_t, alloc_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#ab58b629a05562913c9024181967262c4">srt_tree_t</a></td></tr>
<tr class="separator:ab58b629a05562913c9024181967262c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1044b253259cffc7523bf36ccc1522cb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00018.html">cntree_set</a>&lt; value_t, <br class="typebreak"/>
cnc, comp_key_t, alloc_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a1044b253259cffc7523bf36ccc1522cb">set_t</a></td></tr>
<tr class="separator:a1044b253259cffc7523bf36ccc1522cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7068803ee650162b40db6d6244d54de"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00017.html#ab5f986a5e808b1383c70213e1932aa09">key_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#af7068803ee650162b40db6d6244d54de">key_type</a></td></tr>
<tr class="separator:af7068803ee650162b40db6d6244d54de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddb091d31b7a4ce0effe97b51d09996"><td class="memItemLeft" align="right" valign="top">typedef value_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a8ddb091d31b7a4ce0effe97b51d09996">value_type</a></td></tr>
<tr class="separator:a8ddb091d31b7a4ce0effe97b51d09996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a8bedfe0e1de9a0226edc7f2596b31"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00017.html#ab5f986a5e808b1383c70213e1932aa09">key_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a92a8bedfe0e1de9a0226edc7f2596b31">pointer</a></td></tr>
<tr class="separator:a92a8bedfe0e1de9a0226edc7f2596b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccaeedf5bddfad56567e5a4d8b0e6ba"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="a00017.html#ab5f986a5e808b1383c70213e1932aa09">key_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#acccaeedf5bddfad56567e5a4d8b0e6ba">const_pointer</a></td></tr>
<tr class="separator:acccaeedf5bddfad56567e5a4d8b0e6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcc77c7b98711c6ecbf8a6746a78c37"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00017.html#ab5f986a5e808b1383c70213e1932aa09">key_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a0fcc77c7b98711c6ecbf8a6746a78c37">reference</a></td></tr>
<tr class="separator:a0fcc77c7b98711c6ecbf8a6746a78c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12441712f56e7d27c67229f56349ce8"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="a00017.html#ab5f986a5e808b1383c70213e1932aa09">key_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#ab12441712f56e7d27c67229f56349ce8">const_reference</a></td></tr>
<tr class="separator:ab12441712f56e7d27c67229f56349ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4914d910164a4d95b388b2508863a9dd"><td class="memItemLeft" align="right" valign="top">typedef comp_key_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a4914d910164a4d95b388b2508863a9dd">key_compare</a></td></tr>
<tr class="separator:a4914d910164a4d95b388b2508863a9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad557c83a2b049e0ac140154b9fc84365"><td class="memItemLeft" align="right" valign="top">typedef comp_key_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#ad557c83a2b049e0ac140154b9fc84365">value_compare</a></td></tr>
<tr class="separator:ad557c83a2b049e0ac140154b9fc84365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d28e628e31fd9d79f52d9b6d66938f9"><td class="memItemLeft" align="right" valign="top">typedef alloc_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a8d28e628e31fd9d79f52d9b6d66938f9">allocator_type</a></td></tr>
<tr class="separator:a8d28e628e31fd9d79f52d9b6d66938f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65dd79fdadb0e0a1457705b8ee95a159"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00096.html#a435616fae6b22fcb60996905ea17aef1">srt_tree_t::tree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a65dd79fdadb0e0a1457705b8ee95a159">tree</a></td></tr>
<tr class="separator:a65dd79fdadb0e0a1457705b8ee95a159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126c1abe9ecda1bdea804ce58529ffa4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00096.html#ae2502bd7010efa55a0f7f7e0906a8aeb">srt_tree_t::node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a126c1abe9ecda1bdea804ce58529ffa4">node_t</a></td></tr>
<tr class="separator:a126c1abe9ecda1bdea804ce58529ffa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cc700c03cd5c424765d9270745f4c0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00096.html#a2a86f27200857c04dd1f46e11973e2a1">srt_tree_t::node_alloc_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a40cc700c03cd5c424765d9270745f4c0">node_alloc_t</a></td></tr>
<tr class="separator:a40cc700c03cd5c424765d9270745f4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac883ae93d6c5d0f229fe498f24007976"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00096.html#a25b5bd26451460adb2ec43a8ed1815bb">srt_tree_t::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#ac883ae93d6c5d0f229fe498f24007976">iterator</a></td></tr>
<tr class="separator:ac883ae93d6c5d0f229fe498f24007976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd8de91883f601dadb3bd8e83ce15f7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00096.html#a25b5bd26451460adb2ec43a8ed1815bb">srt_tree_t::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a></td></tr>
<tr class="separator:affd8de91883f601dadb3bd8e83ce15f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988f5a8665423db67eb4d86ffcf44ebf"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00149.html#aacea70d0e38fcfefebf3b6ad0a88ae6f">c_common::signed_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a988f5a8665423db67eb4d86ffcf44ebf">size_type</a></td></tr>
<tr class="separator:a988f5a8665423db67eb4d86ffcf44ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b4f48b985e4b5a09a8732bcc54b99f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00149.html#aacea70d0e38fcfefebf3b6ad0a88ae6f">c_common::signed_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#ad0b4f48b985e4b5a09a8732bcc54b99f">difference_type</a></td></tr>
<tr class="separator:ad0b4f48b985e4b5a09a8732bcc54b99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd75aef41064ee39d3a15bcbcac6323c"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="a00096.html#a80d2d1888631c7aa84f1740348557a8e">srt_tree_t::const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#afd75aef41064ee39d3a15bcbcac6323c">reverse_iterator</a></td></tr>
<tr class="separator:afd75aef41064ee39d3a15bcbcac6323c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3990dba2554010bdcb0182b0187e2b7f"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="a00096.html#a80d2d1888631c7aa84f1740348557a8e">srt_tree_t::const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a3990dba2554010bdcb0182b0187e2b7f">const_reverse_iterator</a></td></tr>
<tr class="separator:a3990dba2554010bdcb0182b0187e2b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847345ef25e35cc186840c77e480da46"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00032.html">c_forest::connector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a847345ef25e35cc186840c77e480da46">connector</a></td></tr>
<tr class="separator:a847345ef25e35cc186840c77e480da46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1bf34763cbdd69035375849e32aefd3d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a1bf34763cbdd69035375849e32aefd3d">cntree_multiset</a> (const <a class="el" href="a00017.html#a4914d910164a4d95b388b2508863a9dd">key_compare</a> &amp;C1=<a class="el" href="a00017.html#a4914d910164a4d95b388b2508863a9dd">key_compare</a>(), const alloc_t &amp;A1=alloc_t())</td></tr>
<tr class="memdesc:a1bf34763cbdd69035375849e32aefd3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from an object Comparer and an object Allocator.  <a href="#a1bf34763cbdd69035375849e32aefd3d">More...</a><br/></td></tr>
<tr class="separator:a1bf34763cbdd69035375849e32aefd3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6571dc3a67ee560977e99ff783eeb22"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:af6571dc3a67ee560977e99ff783eeb22"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#af6571dc3a67ee560977e99ff783eeb22">cntree_multiset</a> (InputIterator first, InputIterator last, const <a class="el" href="a00017.html#a4914d910164a4d95b388b2508863a9dd">key_compare</a> &amp;C1=<a class="el" href="a00017.html#a4914d910164a4d95b388b2508863a9dd">key_compare</a>(), const alloc_t &amp;A1=alloc_t())</td></tr>
<tr class="memdesc:af6571dc3a67ee560977e99ff783eeb22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from a pair of iterators and an object Comparer and an object Allocator.  <a href="#af6571dc3a67ee560977e99ff783eeb22">More...</a><br/></td></tr>
<tr class="separator:af6571dc3a67ee560977e99ff783eeb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d6352b21a90f8e212f6a3e4c55691c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a67d6352b21a90f8e212f6a3e4c55691c">cntree_multiset</a> (const <a class="el" href="a00017.html">cntree_multiset</a> &amp;x)</td></tr>
<tr class="memdesc:a67d6352b21a90f8e212f6a3e4c55691c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a67d6352b21a90f8e212f6a3e4c55691c">More...</a><br/></td></tr>
<tr class="separator:a67d6352b21a90f8e212f6a3e4c55691c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c2f05ddf4b3b3cba34ec90416c31bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#aa7c2f05ddf4b3b3cba34ec90416c31bf">cntree_multiset</a> (<a class="el" href="a00017.html">cntree_multiset</a> &amp;&amp;x)</td></tr>
<tr class="memdesc:aa7c2f05ddf4b3b3cba34ec90416c31bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#aa7c2f05ddf4b3b3cba34ec90416c31bf">More...</a><br/></td></tr>
<tr class="separator:aa7c2f05ddf4b3b3cba34ec90416c31bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1426fc9395dd3d82a53622be19ab38b5"><td class="memTemplParams" colspan="2">template&lt;typename alloc_t2 , bool cnc2&gt; </td></tr>
<tr class="memitem:a1426fc9395dd3d82a53622be19ab38b5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#a1426fc9395dd3d82a53622be19ab38b5">cntree_multiset</a> (const <a class="el" href="a00017.html">cntree_multiset</a>&lt; value_t, cnc2, comp_key_t, alloc_t2 &gt; &amp;x)</td></tr>
<tr class="memdesc:a1426fc9395dd3d82a53622be19ab38b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a1426fc9395dd3d82a53622be19ab38b5">More...</a><br/></td></tr>
<tr class="separator:a1426fc9395dd3d82a53622be19ab38b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612898f55f7c381e13c69c64077df590"><td class="memTemplParams" colspan="2">template&lt;typename alloc_t2 , bool cnc2&gt; </td></tr>
<tr class="memitem:a612898f55f7c381e13c69c64077df590"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#a612898f55f7c381e13c69c64077df590">cntree_multiset</a> (const <a class="el" href="a00018.html">cntree_set</a>&lt; value_t, cnc2, comp_key_t, alloc_t2 &gt; &amp;x)</td></tr>
<tr class="memdesc:a612898f55f7c381e13c69c64077df590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a612898f55f7c381e13c69c64077df590">More...</a><br/></td></tr>
<tr class="separator:a612898f55f7c381e13c69c64077df590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da99b2ad2617723946efeee8e01f4dc"><td class="memTemplParams" colspan="2">template&lt;bool cnc2&gt; </td></tr>
<tr class="memitem:a3da99b2ad2617723946efeee8e01f4dc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#a3da99b2ad2617723946efeee8e01f4dc">cntree_multiset</a> (<a class="el" href="a00017.html">cntree_multiset</a>&lt; value_t, cnc2, comp_key_t, alloc_t &gt; &amp;&amp;x)</td></tr>
<tr class="memdesc:a3da99b2ad2617723946efeee8e01f4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a3da99b2ad2617723946efeee8e01f4dc">More...</a><br/></td></tr>
<tr class="separator:a3da99b2ad2617723946efeee8e01f4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855dbdebe0785db316bfca4e10621bbc"><td class="memTemplParams" colspan="2">template&lt;bool cnc2&gt; </td></tr>
<tr class="memitem:a855dbdebe0785db316bfca4e10621bbc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#a855dbdebe0785db316bfca4e10621bbc">cntree_multiset</a> (<a class="el" href="a00018.html">cntree_set</a>&lt; value_t, cnc2, comp_key_t, alloc_t &gt; &amp;&amp;x)</td></tr>
<tr class="memdesc:a855dbdebe0785db316bfca4e10621bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a855dbdebe0785db316bfca4e10621bbc">More...</a><br/></td></tr>
<tr class="separator:a855dbdebe0785db316bfca4e10621bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f33227953a576db72d3fbca70bf7b3"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a71f33227953a576db72d3fbca70bf7b3">~cntree_multiset</a> (void)</td></tr>
<tr class="memdesc:a71f33227953a576db72d3fbca70bf7b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a71f33227953a576db72d3fbca70bf7b3">More...</a><br/></td></tr>
<tr class="separator:a71f33227953a576db72d3fbca70bf7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aaf2422689cf4f5bf1736e2fd530681"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html">cntree_multiset</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a5aaf2422689cf4f5bf1736e2fd530681">operator=</a> (const <a class="el" href="a00017.html">cntree_multiset</a> &amp;S)</td></tr>
<tr class="memdesc:a5aaf2422689cf4f5bf1736e2fd530681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asignation operator.  <a href="#a5aaf2422689cf4f5bf1736e2fd530681">More...</a><br/></td></tr>
<tr class="separator:a5aaf2422689cf4f5bf1736e2fd530681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d685ef8f17fec74053d89462c50f332"><td class="memTemplParams" colspan="2">template&lt;typename alloc_t2 , bool cnc2&gt; </td></tr>
<tr class="memitem:a1d685ef8f17fec74053d89462c50f332"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00017.html">cntree_multiset</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#a1d685ef8f17fec74053d89462c50f332">operator=</a> (const <a class="el" href="a00017.html">cntree_multiset</a>&lt; value_t, cnc2, comp_key_t, alloc_t2 &gt; &amp;S)</td></tr>
<tr class="memdesc:a1d685ef8f17fec74053d89462c50f332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asignation operator.  <a href="#a1d685ef8f17fec74053d89462c50f332">More...</a><br/></td></tr>
<tr class="separator:a1d685ef8f17fec74053d89462c50f332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f058059a072920e2e315953972503d"><td class="memTemplParams" colspan="2">template&lt;typename alloc_t2 , bool cnc2&gt; </td></tr>
<tr class="memitem:a70f058059a072920e2e315953972503d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00017.html">cntree_multiset</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#a70f058059a072920e2e315953972503d">operator=</a> (const <a class="el" href="a00018.html">cntree_set</a>&lt; value_t, cnc2, comp_key_t, alloc_t2 &gt; &amp;S)</td></tr>
<tr class="memdesc:a70f058059a072920e2e315953972503d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asignation operator.  <a href="#a70f058059a072920e2e315953972503d">More...</a><br/></td></tr>
<tr class="separator:a70f058059a072920e2e315953972503d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cc4aaa65bea1d353191546c18d87b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html">cntree_multiset</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a90cc4aaa65bea1d353191546c18d87b4">operator=</a> (<a class="el" href="a00017.html">cntree_multiset</a> &amp;&amp;S)</td></tr>
<tr class="memdesc:a90cc4aaa65bea1d353191546c18d87b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asignation operator.  <a href="#a90cc4aaa65bea1d353191546c18d87b4">More...</a><br/></td></tr>
<tr class="separator:a90cc4aaa65bea1d353191546c18d87b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfb5f92c91464e59733e9ed347ee2bd"><td class="memTemplParams" colspan="2">template&lt;bool cnc2&gt; </td></tr>
<tr class="memitem:afcfb5f92c91464e59733e9ed347ee2bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00017.html">cntree_multiset</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#afcfb5f92c91464e59733e9ed347ee2bd">operator=</a> (<a class="el" href="a00017.html">cntree_multiset</a>&lt; value_t, cnc2, comp_key_t, alloc_t &gt; &amp;&amp;x)</td></tr>
<tr class="memdesc:afcfb5f92c91464e59733e9ed347ee2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#afcfb5f92c91464e59733e9ed347ee2bd">More...</a><br/></td></tr>
<tr class="separator:afcfb5f92c91464e59733e9ed347ee2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7781270db6fe7233706c585ea31819f5"><td class="memTemplParams" colspan="2">template&lt;bool cnc2&gt; </td></tr>
<tr class="memitem:a7781270db6fe7233706c585ea31819f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00017.html">cntree_multiset</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#a7781270db6fe7233706c585ea31819f5">operator=</a> (<a class="el" href="a00018.html">cntree_set</a>&lt; value_t, cnc2, comp_key_t, alloc_t &gt; &amp;&amp;x)</td></tr>
<tr class="memdesc:a7781270db6fe7233706c585ea31819f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a7781270db6fe7233706c585ea31819f5">More...</a><br/></td></tr>
<tr class="separator:a7781270db6fe7233706c585ea31819f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e8a7857c8b60836f78d0d2559407c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a93e8a7857c8b60836f78d0d2559407c3">clear</a> (void)</td></tr>
<tr class="memdesc:a93e8a7857c8b60836f78d0d2559407c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all the elements of the set.  <a href="#a93e8a7857c8b60836f78d0d2559407c3">More...</a><br/></td></tr>
<tr class="separator:a93e8a7857c8b60836f78d0d2559407c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c2d4060d5c0705a2c0501e981f0bff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#ae0c2d4060d5c0705a2c0501e981f0bff">swap</a> (<a class="el" href="a00017.html">cntree_multiset</a> &amp;ms)</td></tr>
<tr class="memdesc:ae0c2d4060d5c0705a2c0501e981f0bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap the data of the <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> st with the actual <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a>  <a href="#ae0c2d4060d5c0705a2c0501e981f0bff">More...</a><br/></td></tr>
<tr class="separator:ae0c2d4060d5c0705a2c0501e981f0bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115b16c89064ffbca6f5e7161bbc2e90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a115b16c89064ffbca6f5e7161bbc2e90">empty</a> (void) const </td></tr>
<tr class="memdesc:a115b16c89064ffbca6f5e7161bbc2e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicate if the <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> is empty  <a href="#a115b16c89064ffbca6f5e7161bbc2e90">More...</a><br/></td></tr>
<tr class="separator:a115b16c89064ffbca6f5e7161bbc2e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d02ce2bac6ae56bfab125cf785d7dd8"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a9d02ce2bac6ae56bfab125cf785d7dd8">size</a> (void) const </td></tr>
<tr class="memdesc:a9d02ce2bac6ae56bfab125cf785d7dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of elements in the <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a>  <a href="#a9d02ce2bac6ae56bfab125cf785d7dd8">More...</a><br/></td></tr>
<tr class="separator:a9d02ce2bac6ae56bfab125cf785d7dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb5445e635c21c2a2884b97e0ba94f9"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a7bb5445e635c21c2a2884b97e0ba94f9">max_size</a> (void) const </td></tr>
<tr class="memdesc:a7bb5445e635c21c2a2884b97e0ba94f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the maximun size of the container  <a href="#a7bb5445e635c21c2a2884b97e0ba94f9">More...</a><br/></td></tr>
<tr class="separator:a7bb5445e635c21c2a2884b97e0ba94f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e147a478047f862deca40beeb61903c"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a3e147a478047f862deca40beeb61903c">pos</a> (signed_type Pos1) const </td></tr>
<tr class="memdesc:a3e147a478047f862deca40beeb61903c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to an element by their position in the <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a>.  <a href="#a3e147a478047f862deca40beeb61903c">More...</a><br/></td></tr>
<tr class="separator:a3e147a478047f862deca40beeb61903c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042aa52d0299a0cb68ccd0f6198d80b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a042aa52d0299a0cb68ccd0f6198d80b2">const_iterator_pos</a> (signed_type Pos1) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a042aa52d0299a0cb68ccd0f6198d80b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a position in the set.  <a href="#a042aa52d0299a0cb68ccd0f6198d80b2">More...</a><br/></td></tr>
<tr class="separator:a042aa52d0299a0cb68ccd0f6198d80b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88a47fbd58f7324578dfc25c8161b85"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#ad88a47fbd58f7324578dfc25c8161b85">front</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ad88a47fbd58f7324578dfc25c8161b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const_reference to the first element in the sorted_tree.  <a href="#ad88a47fbd58f7324578dfc25c8161b85">More...</a><br/></td></tr>
<tr class="separator:ad88a47fbd58f7324578dfc25c8161b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcf8a3c87333aad06e6d5171a75c08b"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a8bcf8a3c87333aad06e6d5171a75c08b">back</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a8bcf8a3c87333aad06e6d5171a75c08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const_reference to the last element in the sorted_tree.  <a href="#a8bcf8a3c87333aad06e6d5171a75c08b">More...</a><br/></td></tr>
<tr class="separator:a8bcf8a3c87333aad06e6d5171a75c08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f9d8f85b94c6f488f85682f1aede2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ac883ae93d6c5d0f229fe498f24007976">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a45f9d8f85b94c6f488f85682f1aede2c">find</a> (const <a class="el" href="a00017.html#af7068803ee650162b40db6d6244d54de">key_type</a> &amp;x) const </td></tr>
<tr class="memdesc:a45f9d8f85b94c6f488f85682f1aede2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the iterator to the element with the key x  <a href="#a45f9d8f85b94c6f488f85682f1aede2c">More...</a><br/></td></tr>
<tr class="separator:a45f9d8f85b94c6f488f85682f1aede2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e89acd93ccaa51ca09bff10670a158"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a85e89acd93ccaa51ca09bff10670a158">count</a> (const <a class="el" href="a00017.html#af7068803ee650162b40db6d6244d54de">key_type</a> &amp;x) const </td></tr>
<tr class="memdesc:a85e89acd93ccaa51ca09bff10670a158"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of elements in the <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> with the key x  <a href="#a85e89acd93ccaa51ca09bff10670a158">More...</a><br/></td></tr>
<tr class="separator:a85e89acd93ccaa51ca09bff10670a158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add20c972445fcf10221244f328fc8722"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ac883ae93d6c5d0f229fe498f24007976">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#add20c972445fcf10221244f328fc8722">lower_bound</a> (const <a class="el" href="a00017.html#af7068803ee650162b40db6d6244d54de">key_type</a> &amp;x) const </td></tr>
<tr class="memdesc:add20c972445fcf10221244f328fc8722"><td class="mdescLeft">&#160;</td><td class="mdescRight">return one iterator to the first appearance of the key x if exist <br/>
 and if don't exist return one iterator to the first element greather than x  <a href="#add20c972445fcf10221244f328fc8722">More...</a><br/></td></tr>
<tr class="separator:add20c972445fcf10221244f328fc8722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059c573215d8598add052136aefff3de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ac883ae93d6c5d0f229fe498f24007976">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a059c573215d8598add052136aefff3de">upper_bound</a> (const <a class="el" href="a00017.html#af7068803ee650162b40db6d6244d54de">key_type</a> &amp;x) const </td></tr>
<tr class="memdesc:a059c573215d8598add052136aefff3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">return one iterator to the first element greather than x. If don't exist any element greather than x , return <a class="el" href="a00017.html#a40707b27ba587a9460bada710e901955">end()</a>  <a href="#a059c573215d8598add052136aefff3de">More...</a><br/></td></tr>
<tr class="separator:a059c573215d8598add052136aefff3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718397f627c03a7565166ffb19744517"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="a00017.html#ac883ae93d6c5d0f229fe498f24007976">iterator</a>, <a class="el" href="a00017.html#ac883ae93d6c5d0f229fe498f24007976">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a718397f627c03a7565166ffb19744517">equal_range</a> (const <a class="el" href="a00017.html#af7068803ee650162b40db6d6244d54de">key_type</a> &amp;x) const </td></tr>
<tr class="memdesc:a718397f627c03a7565166ffb19744517"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a pair of iterators, the first is the lower_bound (x) and the second is upper_bound (x)  <a href="#a718397f627c03a7565166ffb19744517">More...</a><br/></td></tr>
<tr class="separator:a718397f627c03a7565166ffb19744517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac535867ca577306e4b76808a98da41ca"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ac535867ca577306e4b76808a98da41ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#ac535867ca577306e4b76808a98da41ca">emplace_internal</a> (<a class="el" href="a00017.html#aa142db9e70c7ad8256e1a6c325670e47">mtx_write</a> &amp;BM, <a class="el" href="a00017.html#a847345ef25e35cc186840c77e480da46">connector</a> C, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ac535867ca577306e4b76808a98da41ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in a the position specified by the connector  <a href="#ac535867ca577306e4b76808a98da41ca">More...</a><br/></td></tr>
<tr class="separator:ac535867ca577306e4b76808a98da41ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6c84ddcc8ac134629206f5be0e156d"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a3d6c84ddcc8ac134629206f5be0e156d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#a3d6c84ddcc8ac134629206f5be0e156d">insert</a> (P &amp;&amp;Val)</td></tr>
<tr class="memdesc:a3d6c84ddcc8ac134629206f5be0e156d"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a value in the <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a>  <a href="#a3d6c84ddcc8ac134629206f5be0e156d">More...</a><br/></td></tr>
<tr class="separator:a3d6c84ddcc8ac134629206f5be0e156d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4296b7d03665c5eefc39ba18bbe8cebc"><td class="memTemplParams" colspan="2">template&lt;class Function , class P &gt; </td></tr>
<tr class="memitem:a4296b7d03665c5eefc39ba18bbe8cebc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#a4296b7d03665c5eefc39ba18bbe8cebc">insert_if</a> (Function &amp;&amp;M, P &amp;&amp;Val)</td></tr>
<tr class="memdesc:a4296b7d03665c5eefc39ba18bbe8cebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a value in the set  <a href="#a4296b7d03665c5eefc39ba18bbe8cebc">More...</a><br/></td></tr>
<tr class="separator:a4296b7d03665c5eefc39ba18bbe8cebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e213fb86ba45454c1cdc7d2fb5b06b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a35e213fb86ba45454c1cdc7d2fb5b06b">insert</a> (<a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>, const <a class="el" href="a00017.html#a8ddb091d31b7a4ce0effe97b51d09996">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a35e213fb86ba45454c1cdc7d2fb5b06b"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a value in the <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a>  <a href="#a35e213fb86ba45454c1cdc7d2fb5b06b">More...</a><br/></td></tr>
<tr class="separator:a35e213fb86ba45454c1cdc7d2fb5b06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0919f687b417e49eb846322c86b75c10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a0919f687b417e49eb846322c86b75c10">insert</a> (<a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>, <a class="el" href="a00017.html#a8ddb091d31b7a4ce0effe97b51d09996">value_type</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:a0919f687b417e49eb846322c86b75c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a value in the <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a>  <a href="#a0919f687b417e49eb846322c86b75c10">More...</a><br/></td></tr>
<tr class="separator:a0919f687b417e49eb846322c86b75c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9f8047710b7ec9abe4a130e38ae4d8"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a4e9f8047710b7ec9abe4a130e38ae4d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#a4e9f8047710b7ec9abe4a130e38ae4d8">emplace</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a4e9f8047710b7ec9abe4a130e38ae4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a value in the set  <a href="#a4e9f8047710b7ec9abe4a130e38ae4d8">More...</a><br/></td></tr>
<tr class="separator:a4e9f8047710b7ec9abe4a130e38ae4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e3c569d9cb8f8a9730498403129092"><td class="memTemplParams" colspan="2">template&lt;class Function , class... Args&gt; </td></tr>
<tr class="memitem:a09e3c569d9cb8f8a9730498403129092"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#a09e3c569d9cb8f8a9730498403129092">emplace_if</a> (Function &amp;&amp;M, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a09e3c569d9cb8f8a9730498403129092"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a value in the set  <a href="#a09e3c569d9cb8f8a9730498403129092">More...</a><br/></td></tr>
<tr class="separator:a09e3c569d9cb8f8a9730498403129092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c28e7f48b9d38618ca0fe4d784f57b9"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a3c28e7f48b9d38618ca0fe4d784f57b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#a3c28e7f48b9d38618ca0fe4d784f57b9">emplace_hint</a> (<a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a3c28e7f48b9d38618ca0fe4d784f57b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a value in the set  <a href="#a3c28e7f48b9d38618ca0fe4d784f57b9">More...</a><br/></td></tr>
<tr class="separator:a3c28e7f48b9d38618ca0fe4d784f57b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf5c0de65a8c77e5017f07892b63ca7"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a2cf5c0de65a8c77e5017f07892b63ca7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#a2cf5c0de65a8c77e5017f07892b63ca7">insert</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a2cf5c0de65a8c77e5017f07892b63ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion of range of elements from two iterators.  <a href="#a2cf5c0de65a8c77e5017f07892b63ca7">More...</a><br/></td></tr>
<tr class="separator:a2cf5c0de65a8c77e5017f07892b63ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bbc79418437c54d765433d8bb13ae44"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Function &gt; </td></tr>
<tr class="memitem:a8bbc79418437c54d765433d8bb13ae44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#a8bbc79418437c54d765433d8bb13ae44">insert_if</a> (InputIterator first, InputIterator last, Function &amp;&amp;M)</td></tr>
<tr class="memdesc:a8bbc79418437c54d765433d8bb13ae44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion of range of elements from two iterators.  <a href="#a8bbc79418437c54d765433d8bb13ae44">More...</a><br/></td></tr>
<tr class="separator:a8bbc79418437c54d765433d8bb13ae44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d44ba1b00e3167d8b80c092fb78e1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a56d44ba1b00e3167d8b80c092fb78e1a">pop_front</a> (void)</td></tr>
<tr class="memdesc:a56d44ba1b00e3167d8b80c092fb78e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the container  <a href="#a56d44ba1b00e3167d8b80c092fb78e1a">More...</a><br/></td></tr>
<tr class="separator:a56d44ba1b00e3167d8b80c092fb78e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1863b2c7fb9a2ae806f6aa16d49d34"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:acd1863b2c7fb9a2ae806f6aa16d49d34"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#acd1863b2c7fb9a2ae806f6aa16d49d34">pop_front_if</a> (Function &amp;&amp;M1)</td></tr>
<tr class="memdesc:acd1863b2c7fb9a2ae806f6aa16d49d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the container  <a href="#acd1863b2c7fb9a2ae806f6aa16d49d34">More...</a><br/></td></tr>
<tr class="separator:acd1863b2c7fb9a2ae806f6aa16d49d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11bc5c6b264c40c3dc0eea25c418c50b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a11bc5c6b264c40c3dc0eea25c418c50b">pop_copy_front</a> (value_t &amp;V)</td></tr>
<tr class="memdesc:a11bc5c6b264c40c3dc0eea25c418c50b"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the tree and return a copy  <a href="#a11bc5c6b264c40c3dc0eea25c418c50b">More...</a><br/></td></tr>
<tr class="separator:a11bc5c6b264c40c3dc0eea25c418c50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9dca95e70ee501252ca24a1f26bb28"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a9a9dca95e70ee501252ca24a1f26bb28"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#a9a9dca95e70ee501252ca24a1f26bb28">pop_copy_front_if</a> (value_t &amp;V, Function &amp;&amp;M1)</td></tr>
<tr class="memdesc:a9a9dca95e70ee501252ca24a1f26bb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the tree and return a copy  <a href="#a9a9dca95e70ee501252ca24a1f26bb28">More...</a><br/></td></tr>
<tr class="separator:a9a9dca95e70ee501252ca24a1f26bb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805344ae93e6f3f723dc3fe77ba9804b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a805344ae93e6f3f723dc3fe77ba9804b">pop_move_front</a> (value_t &amp;V)</td></tr>
<tr class="memdesc:a805344ae93e6f3f723dc3fe77ba9804b"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the tree and return a copy with rvalues  <a href="#a805344ae93e6f3f723dc3fe77ba9804b">More...</a><br/></td></tr>
<tr class="separator:a805344ae93e6f3f723dc3fe77ba9804b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38812a5f9c0ffcd155892f451c1ea64a"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a38812a5f9c0ffcd155892f451c1ea64a"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#a38812a5f9c0ffcd155892f451c1ea64a">pop_move_front_if</a> (value_t &amp;V, Function &amp;&amp;M1)</td></tr>
<tr class="memdesc:a38812a5f9c0ffcd155892f451c1ea64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the tree and return a copy with rvalues  <a href="#a38812a5f9c0ffcd155892f451c1ea64a">More...</a><br/></td></tr>
<tr class="separator:a38812a5f9c0ffcd155892f451c1ea64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bcb5702dcb2b868e18ecd53625e1fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#af8bcb5702dcb2b868e18ecd53625e1fb">pop_back</a> (void)</td></tr>
<tr class="memdesc:af8bcb5702dcb2b868e18ecd53625e1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the container  <a href="#af8bcb5702dcb2b868e18ecd53625e1fb">More...</a><br/></td></tr>
<tr class="separator:af8bcb5702dcb2b868e18ecd53625e1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3da27f7cdb5a919800162dd0c548db"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:aed3da27f7cdb5a919800162dd0c548db"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#aed3da27f7cdb5a919800162dd0c548db">pop_back_if</a> (Function &amp;&amp;M1)</td></tr>
<tr class="memdesc:aed3da27f7cdb5a919800162dd0c548db"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the container  <a href="#aed3da27f7cdb5a919800162dd0c548db">More...</a><br/></td></tr>
<tr class="separator:aed3da27f7cdb5a919800162dd0c548db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0878b9401c9dd2336a4df2e2dd63546"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#af0878b9401c9dd2336a4df2e2dd63546">pop_copy_back</a> (value_t &amp;V)</td></tr>
<tr class="memdesc:af0878b9401c9dd2336a4df2e2dd63546"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the tree and return a copy  <a href="#af0878b9401c9dd2336a4df2e2dd63546">More...</a><br/></td></tr>
<tr class="separator:af0878b9401c9dd2336a4df2e2dd63546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547d9f0915d4371b99a479da6b7b0f18"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a547d9f0915d4371b99a479da6b7b0f18"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#a547d9f0915d4371b99a479da6b7b0f18">pop_copy_back_if</a> (value_t &amp;V, Function &amp;&amp;M1)</td></tr>
<tr class="memdesc:a547d9f0915d4371b99a479da6b7b0f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the tree and return a copy  <a href="#a547d9f0915d4371b99a479da6b7b0f18">More...</a><br/></td></tr>
<tr class="separator:a547d9f0915d4371b99a479da6b7b0f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf06304569fa0862bca05224acadf0a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a9bf06304569fa0862bca05224acadf0a">pop_move_back</a> (value_t &amp;V)</td></tr>
<tr class="memdesc:a9bf06304569fa0862bca05224acadf0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the tree and return a copy with rvalues  <a href="#a9bf06304569fa0862bca05224acadf0a">More...</a><br/></td></tr>
<tr class="separator:a9bf06304569fa0862bca05224acadf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823815fe7fd9c12b9f6efab0917e0967"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a823815fe7fd9c12b9f6efab0917e0967"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#a823815fe7fd9c12b9f6efab0917e0967">pop_move_back_if</a> (value_t &amp;V, Function &amp;&amp;M1)</td></tr>
<tr class="memdesc:a823815fe7fd9c12b9f6efab0917e0967"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the tree and return a copy with rvalues  <a href="#a823815fe7fd9c12b9f6efab0917e0967">More...</a><br/></td></tr>
<tr class="separator:a823815fe7fd9c12b9f6efab0917e0967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924232aef056f0d5bf7958f1200c4c1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a924232aef056f0d5bf7958f1200c4c1a">erase</a> (<a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> iter)</td></tr>
<tr class="memdesc:a924232aef056f0d5bf7958f1200c4c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element pointed by iter  <a href="#a924232aef056f0d5bf7958f1200c4c1a">More...</a><br/></td></tr>
<tr class="separator:a924232aef056f0d5bf7958f1200c4c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8d5468c67e2074485f6c9548dc213e"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a0a8d5468c67e2074485f6c9548dc213e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#a0a8d5468c67e2074485f6c9548dc213e">erase_if</a> (<a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> iter, Function &amp;&amp;M)</td></tr>
<tr class="memdesc:a0a8d5468c67e2074485f6c9548dc213e"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element pointed by iter  <a href="#a0a8d5468c67e2074485f6c9548dc213e">More...</a><br/></td></tr>
<tr class="separator:a0a8d5468c67e2074485f6c9548dc213e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6333318801724ebd2a2c19f588fd7479"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a6333318801724ebd2a2c19f588fd7479">erase</a> (const <a class="el" href="a00017.html#af7068803ee650162b40db6d6244d54de">key_type</a> &amp;x)</td></tr>
<tr class="memdesc:a6333318801724ebd2a2c19f588fd7479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all the elements with a key.  <a href="#a6333318801724ebd2a2c19f588fd7479">More...</a><br/></td></tr>
<tr class="separator:a6333318801724ebd2a2c19f588fd7479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2793aa6e35fc826f46c1793e75d84dd"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:ad2793aa6e35fc826f46c1793e75d84dd"><td class="memTemplItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#ad2793aa6e35fc826f46c1793e75d84dd">erase_if</a> (const <a class="el" href="a00017.html#af7068803ee650162b40db6d6244d54de">key_type</a> &amp;x, Function &amp;&amp;M)</td></tr>
<tr class="memdesc:ad2793aa6e35fc826f46c1793e75d84dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all the elements with a key.  <a href="#ad2793aa6e35fc826f46c1793e75d84dd">More...</a><br/></td></tr>
<tr class="separator:ad2793aa6e35fc826f46c1793e75d84dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f3d857c1d5b896f125c010a0ec5eaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a11f3d857c1d5b896f125c010a0ec5eaa">erase</a> (<a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> first, <a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> last)</td></tr>
<tr class="memdesc:a11f3d857c1d5b896f125c010a0ec5eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase a range of elements in the range first, last  <a href="#a11f3d857c1d5b896f125c010a0ec5eaa">More...</a><br/></td></tr>
<tr class="separator:a11f3d857c1d5b896f125c010a0ec5eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03feeb2f7efa7196b2087d1b89186390"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a03feeb2f7efa7196b2087d1b89186390"><td class="memTemplItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#a03feeb2f7efa7196b2087d1b89186390">erase_if</a> (<a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> first_it, <a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> last_it, Function &amp;&amp;M)</td></tr>
<tr class="memdesc:a03feeb2f7efa7196b2087d1b89186390"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase a range of elements between first_it and last_it  <a href="#a03feeb2f7efa7196b2087d1b89186390">More...</a><br/></td></tr>
<tr class="separator:a03feeb2f7efa7196b2087d1b89186390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293d727959c150efe33c3e92d80ee264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a293d727959c150efe33c3e92d80ee264">erase_pos</a> (signed_type Pos)</td></tr>
<tr class="memdesc:a293d727959c150efe33c3e92d80ee264"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element of the position pos  <a href="#a293d727959c150efe33c3e92d80ee264">More...</a><br/></td></tr>
<tr class="separator:a293d727959c150efe33c3e92d80ee264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45b5a552a7b0ce4925b3c50a9264810"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:ab45b5a552a7b0ce4925b3c50a9264810"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#ab45b5a552a7b0ce4925b3c50a9264810">erase_pos_if</a> (signed_type Pos, Function &amp;&amp;M)</td></tr>
<tr class="memdesc:ab45b5a552a7b0ce4925b3c50a9264810"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element of the position pos  <a href="#ab45b5a552a7b0ce4925b3c50a9264810">More...</a><br/></td></tr>
<tr class="separator:ab45b5a552a7b0ce4925b3c50a9264810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133884c983e1ddc1af63cab620a79ee7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a133884c983e1ddc1af63cab620a79ee7">erase_pos</a> (signed_type Prim, signed_type NElem)</td></tr>
<tr class="memdesc:a133884c983e1ddc1af63cab620a79ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase NElem elements beginning in the position Prim  <a href="#a133884c983e1ddc1af63cab620a79ee7">More...</a><br/></td></tr>
<tr class="separator:a133884c983e1ddc1af63cab620a79ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10023578f4df19297258e22fbafff37d"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a10023578f4df19297258e22fbafff37d"><td class="memTemplItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#a10023578f4df19297258e22fbafff37d">erase_pos_if</a> (signed_type Prim, signed_type NElem, Function &amp;&amp;M)</td></tr>
<tr class="memdesc:a10023578f4df19297258e22fbafff37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase NElem elements beginning in the position Prim  <a href="#a10023578f4df19297258e22fbafff37d">More...</a><br/></td></tr>
<tr class="separator:a10023578f4df19297258e22fbafff37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fae6a44bba242989c027cf3b34e0d29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#a4914d910164a4d95b388b2508863a9dd">key_compare</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a2fae6a44bba242989c027cf3b34e0d29">key_comp</a> () const </td></tr>
<tr class="memdesc:a2fae6a44bba242989c027cf3b34e0d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the object used to compare two keys  <a href="#a2fae6a44bba242989c027cf3b34e0d29">More...</a><br/></td></tr>
<tr class="separator:a2fae6a44bba242989c027cf3b34e0d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7f82de54d855c318ebc1aa1460ebf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ad557c83a2b049e0ac140154b9fc84365">value_compare</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a2b7f82de54d855c318ebc1aa1460ebf2">value_comp</a> () const </td></tr>
<tr class="memdesc:a2b7f82de54d855c318ebc1aa1460ebf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the object used to compare two values  <a href="#a2b7f82de54d855c318ebc1aa1460ebf2">More...</a><br/></td></tr>
<tr class="separator:a2b7f82de54d855c318ebc1aa1460ebf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74b74a403c2f76d56b7aa9ace9105ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#a8d28e628e31fd9d79f52d9b6d66938f9">allocator_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#af74b74a403c2f76d56b7aa9ace9105ac">get_allocator</a> () const </td></tr>
<tr class="memdesc:af74b74a403c2f76d56b7aa9ace9105ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the object allocator of the set  <a href="#af74b74a403c2f76d56b7aa9ace9105ac">More...</a><br/></td></tr>
<tr class="separator:af74b74a403c2f76d56b7aa9ace9105ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ca436edde9ec515134368c29e9e89d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a24ca436edde9ec515134368c29e9e89d">is_mine</a> (<a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> it) const </td></tr>
<tr class="memdesc:a24ca436edde9ec515134368c29e9e89d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the iterator is pointing to this set.  <a href="#a24ca436edde9ec515134368c29e9e89d">More...</a><br/></td></tr>
<tr class="separator:a24ca436edde9ec515134368c29e9e89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50245d0b481d82b77a82abd3809b28a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#ac50245d0b481d82b77a82abd3809b28a">is_mine</a> (<a class="el" href="a00017.html#a3990dba2554010bdcb0182b0187e2b7f">const_reverse_iterator</a> it) const </td></tr>
<tr class="memdesc:ac50245d0b481d82b77a82abd3809b28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the iterator is pointing to this set.  <a href="#ac50245d0b481d82b77a82abd3809b28a">More...</a><br/></td></tr>
<tr class="separator:ac50245d0b481d82b77a82abd3809b28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc73a774d5c1abd668b9d2b5ff03c831"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#abc73a774d5c1abd668b9d2b5ff03c831">cit_begin</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:abc73a774d5c1abd668b9d2b5ff03c831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaeb2f9d27718491a69a4a6edc176b75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#adaeb2f9d27718491a69a4a6edc176b75">begin</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:adaeb2f9d27718491a69a4a6edc176b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f21a1a4296798e855beb4437f19792"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a46f21a1a4296798e855beb4437f19792">cbegin</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a46f21a1a4296798e855beb4437f19792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7624e508d6a2facfaa6841da76763215"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a7624e508d6a2facfaa6841da76763215">cit_end</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a7624e508d6a2facfaa6841da76763215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40707b27ba587a9460bada710e901955"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a40707b27ba587a9460bada710e901955">end</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a40707b27ba587a9460bada710e901955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495c5264605543539ee8f602a1a0993e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a495c5264605543539ee8f602a1a0993e">cend</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a495c5264605543539ee8f602a1a0993e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3296f93c2b6069c11b67d873822a14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#afe3296f93c2b6069c11b67d873822a14">cit_rbegin</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:afe3296f93c2b6069c11b67d873822a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28eb4da689e3f98c24c2991490423e98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a28eb4da689e3f98c24c2991490423e98">cit_rend</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a28eb4da689e3f98c24c2991490423e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bc762d671677d8999fe51b62fa5adf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#a3990dba2554010bdcb0182b0187e2b7f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#ab9bc762d671677d8999fe51b62fa5adf">crit_begin</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ab9bc762d671677d8999fe51b62fa5adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad5240838fe0c886925fd05b8ac4b68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#a3990dba2554010bdcb0182b0187e2b7f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#abad5240838fe0c886925fd05b8ac4b68">crit_end</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:abad5240838fe0c886925fd05b8ac4b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d13107474bd9085168bda91a29da8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#a3990dba2554010bdcb0182b0187e2b7f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a14d13107474bd9085168bda91a29da8c">crit_rbegin</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a14d13107474bd9085168bda91a29da8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467885454cd3c23a273e72d0617e72dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#a3990dba2554010bdcb0182b0187e2b7f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a467885454cd3c23a273e72d0617e72dd">rbegin</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a467885454cd3c23a273e72d0617e72dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa057453b05b15a87625da1c08dc04119"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#a3990dba2554010bdcb0182b0187e2b7f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#aa057453b05b15a87625da1c08dc04119">crbegin</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aa057453b05b15a87625da1c08dc04119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fcbea716a7baa8875b5d853b3d618d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#a3990dba2554010bdcb0182b0187e2b7f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a9fcbea716a7baa8875b5d853b3d618d5">crit_rend</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a9fcbea716a7baa8875b5d853b3d618d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb89201862efe14e85b94fe09956a48d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#a3990dba2554010bdcb0182b0187e2b7f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#adb89201862efe14e85b94fe09956a48d">rend</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:adb89201862efe14e85b94fe09956a48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0e39907621e99128ba072bac7965e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#a3990dba2554010bdcb0182b0187e2b7f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a5f0e39907621e99128ba072bac7965e3">crend</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a5f0e39907621e99128ba072bac7965e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a0cb9ba0b2636b10dd8a4bb3b9e0dd93d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#a83f74fcec6c1b8ce82f7e9d32b659f44">mtx_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a0cb9ba0b2636b10dd8a4bb3b9e0dd93d">BD</a></td></tr>
<tr class="separator:a0cb9ba0b2636b10dd8a4bb3b9e0dd93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9ef560970a45c9e4caf09480dda45ca3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00017.html#ab58b629a05562913c9024181967262c4">srt_tree_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html#a9ef560970a45c9e4caf09480dda45ca3">st</a></td></tr>
<tr class="separator:a9ef560970a45c9e4caf09480dda45ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a2322fd5e1cffe75b7cf1508b4f3b6d44"><td class="memTemplParams" colspan="2">template&lt;class value_t2 , bool cnc2, typename comp_key_t2 , typename alloc_t2 &gt; </td></tr>
<tr class="memitem:a2322fd5e1cffe75b7cf1508b4f3b6d44"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#a2322fd5e1cffe75b7cf1508b4f3b6d44">cntree_multiset</a></td></tr>
<tr class="separator:a2322fd5e1cffe75b7cf1508b4f3b6d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe7b75d71ee9e25d2ab8e361676c077"><td class="memTemplParams" colspan="2">template&lt;class value_t2 , bool cnc2, typename comp_key_t2 , typename alloc_t2 &gt; </td></tr>
<tr class="memitem:a5fe7b75d71ee9e25d2ab8e361676c077"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00017.html#a5fe7b75d71ee9e25d2ab8e361676c077">cntree_set</a></td></tr>
<tr class="separator:a5fe7b75d71ee9e25d2ab8e361676c077"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt;<br/>
class countertree::cntree_multiset&lt; value_t, cnc, comp_key_t, alloc_t &gt;</h3>

<p>This class have the same interface than the STL set, plus access by position with the function at, and random access iterators. </p>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00054">54</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a8d28e628e31fd9d79f52d9b6d66938f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef alloc_t <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#a8d28e628e31fd9d79f52d9b6d66938f9">allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00078">78</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a847345ef25e35cc186840c77e480da46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00032.html">c_forest::connector</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#a847345ef25e35cc186840c77e480da46">connector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00089">89</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="affd8de91883f601dadb3bd8e83ce15f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00096.html#a25b5bd26451460adb2ec43a8ed1815bb">srt_tree_t::const_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00084">84</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acccaeedf5bddfad56567e5a4d8b0e6ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="a00017.html#ab5f986a5e808b1383c70213e1932aa09">key_t</a>* <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#acccaeedf5bddfad56567e5a4d8b0e6ba">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00072">72</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab12441712f56e7d27c67229f56349ce8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="a00017.html#ab5f986a5e808b1383c70213e1932aa09">key_t</a>&amp; <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#ab12441712f56e7d27c67229f56349ce8">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00074">74</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3990dba2554010bdcb0182b0187e2b7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00096.html#a80d2d1888631c7aa84f1740348557a8e">srt_tree_t::const_reverse_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#a3990dba2554010bdcb0182b0187e2b7f">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00088">88</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad0b4f48b985e4b5a09a8732bcc54b99f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00149.html#aacea70d0e38fcfefebf3b6ad0a88ae6f">c_common::signed_type</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#ad0b4f48b985e4b5a09a8732bcc54b99f">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00086">86</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acd04cfcfa5f895aacf2d507d0ab7b67c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00038.html">filter_set</a>&lt;<a class="el" href="a00017.html#ab5f986a5e808b1383c70213e1932aa09">key_t</a>,value_t&gt; <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#acd04cfcfa5f895aacf2d507d0ab7b67c">filter_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00065">65</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac883ae93d6c5d0f229fe498f24007976"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00096.html#a25b5bd26451460adb2ec43a8ed1815bb">srt_tree_t::const_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#ac883ae93d6c5d0f229fe498f24007976">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00083">83</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4914d910164a4d95b388b2508863a9dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef comp_key_t <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#a4914d910164a4d95b388b2508863a9dd">key_compare</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00076">76</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab5f986a5e808b1383c70213e1932aa09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef value_t <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#ab5f986a5e808b1383c70213e1932aa09">key_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00064">64</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af7068803ee650162b40db6d6244d54de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00017.html#ab5f986a5e808b1383c70213e1932aa09">key_t</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#af7068803ee650162b40db6d6244d54de">key_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00069">69</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a83f74fcec6c1b8ce82f7e9d32b659f44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00023.html">config_fastmutex</a>&lt;cnc&gt;::fastmutex_data <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#a83f74fcec6c1b8ce82f7e9d32b659f44">mtx_data</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00060">60</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a58e82f00b98dc461b49080d82914e333"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00051.html">mutex_read</a>&lt;<a class="el" href="a00017.html#a83f74fcec6c1b8ce82f7e9d32b659f44">mtx_data</a>&gt; <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#a58e82f00b98dc461b49080d82914e333">mtx_read</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00061">61</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa142db9e70c7ad8256e1a6c325670e47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00053.html">mutex_write</a>&lt;<a class="el" href="a00017.html#a83f74fcec6c1b8ce82f7e9d32b659f44">mtx_data</a>&gt; <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#aa142db9e70c7ad8256e1a6c325670e47">mtx_write</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00062">62</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a40cc700c03cd5c424765d9270745f4c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00096.html#a2a86f27200857c04dd1f46e11973e2a1">srt_tree_t::node_alloc_t</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#a40cc700c03cd5c424765d9270745f4c0">node_alloc_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00081">81</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a126c1abe9ecda1bdea804ce58529ffa4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00096.html#ae2502bd7010efa55a0f7f7e0906a8aeb">srt_tree_t::node_t</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#a126c1abe9ecda1bdea804ce58529ffa4">node_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00080">80</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a92a8bedfe0e1de9a0226edc7f2596b31"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00017.html#ab5f986a5e808b1383c70213e1932aa09">key_t</a>* <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#a92a8bedfe0e1de9a0226edc7f2596b31">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00071">71</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0fcc77c7b98711c6ecbf8a6746a78c37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00017.html#ab5f986a5e808b1383c70213e1932aa09">key_t</a>&amp; <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#a0fcc77c7b98711c6ecbf8a6746a78c37">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00073">73</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afd75aef41064ee39d3a15bcbcac6323c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00096.html#a80d2d1888631c7aa84f1740348557a8e">srt_tree_t::const_reverse_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#afd75aef41064ee39d3a15bcbcac6323c">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00087">87</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1044b253259cffc7523bf36ccc1522cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00018.html">cntree_set</a>&lt;value_t, cnc, comp_key_t, alloc_t &gt; <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#a1044b253259cffc7523bf36ccc1522cb">set_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00067">67</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a988f5a8665423db67eb4d86ffcf44ebf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00149.html#aacea70d0e38fcfefebf3b6ad0a88ae6f">c_common::signed_type</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#a988f5a8665423db67eb4d86ffcf44ebf">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00085">85</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab58b629a05562913c9024181967262c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00096.html">c_forest::sorted_tree</a>&lt;value_t,<a class="el" href="a00017.html#ab5f986a5e808b1383c70213e1932aa09">key_t</a>,<a class="el" href="a00017.html#acd04cfcfa5f895aacf2d507d0ab7b67c">filter_t</a>,comp_key_t,alloc_t&gt; <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#ab58b629a05562913c9024181967262c4">srt_tree_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00066">66</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a65dd79fdadb0e0a1457705b8ee95a159"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00096.html#a435616fae6b22fcb60996905ea17aef1">srt_tree_t::tree</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#a65dd79fdadb0e0a1457705b8ee95a159">tree</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00079">79</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad557c83a2b049e0ac140154b9fc84365"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef comp_key_t <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#ad557c83a2b049e0ac140154b9fc84365">value_compare</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00077">77</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8ddb091d31b7a4ce0effe97b51d09996"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef value_t <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html#a8ddb091d31b7a4ce0effe97b51d09996">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00070">70</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1bf34763cbdd69035375849e32aefd3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html">cntree_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00017.html#a4914d910164a4d95b388b2508863a9dd">key_compare</a> &amp;&#160;</td>
          <td class="paramname"><em>C1</em> = <code><a class="el" href="a00017.html#a4914d910164a4d95b388b2508863a9dd">key_compare</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const alloc_t &amp;&#160;</td>
          <td class="paramname"><em>A1</em> = <code>alloc_t&#160;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from an object Comparer and an object Allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C1</td><td>: Comparer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A1</td><td>: Allocator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00153">153</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6571dc3a67ee560977e99ff783eeb22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html">cntree_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00017.html#a4914d910164a4d95b388b2508863a9dd">key_compare</a> &amp;&#160;</td>
          <td class="paramname"><em>C1</em> = <code><a class="el" href="a00017.html#a4914d910164a4d95b388b2508863a9dd">key_compare</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const alloc_t &amp;&#160;</td>
          <td class="paramname"><em>A1</em> = <code>alloc_t&#160;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from a pair of iterators and an object Comparer and an object Allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>: iterator to the first element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>: iterator to the last element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C1</td><td>: Comparer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A1</td><td>: Allocator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00167">167</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a67d6352b21a90f8e212f6a3e4c55691c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html">cntree_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00017.html">cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00181">181</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa7c2f05ddf4b3b3cba34ec90416c31bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html">cntree_multiset</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00017.html">cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00192">192</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1426fc9395dd3d82a53622be19ab38b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename alloc_t2 , bool cnc2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html">cntree_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00017.html">cntree_multiset</a>&lt; value_t, cnc2, comp_key_t, alloc_t2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00205">205</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a612898f55f7c381e13c69c64077df590"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename alloc_t2 , bool cnc2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html">cntree_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00018.html">cntree_set</a>&lt; value_t, cnc2, comp_key_t, alloc_t2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00219">219</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3da99b2ad2617723946efeee8e01f4dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;bool cnc2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html">cntree_multiset</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00017.html">cntree_multiset</a>&lt; value_t, cnc2, comp_key_t, alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00233">233</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a855dbdebe0785db316bfca4e10621bbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;bool cnc2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::<a class="el" href="a00017.html">cntree_multiset</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00018.html">cntree_set</a>&lt; value_t, cnc2, comp_key_t, alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00241">241</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a71f33227953a576db72d3fbca70bf7b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::~<a class="el" href="a00017.html">cntree_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="a00112_source.html#l00247">247</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8bcf8a3c87333aad06e6d5171a75c08b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t&amp; <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const_reference to the last element in the sorted_tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the last element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00498">498</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adaeb2f9d27718491a69a4a6edc176b75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01352">1352</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a46f21a1a4296798e855beb4437f19792"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01360">1360</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a495c5264605543539ee8f602a1a0993e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::cend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01384">1384</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc73a774d5c1abd668b9d2b5ff03c831"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::cit_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01344">1344</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7624e508d6a2facfaa6841da76763215"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::cit_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01368">1368</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afe3296f93c2b6069c11b67d873822a14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::cit_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01392">1392</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a28eb4da689e3f98c24c2991490423e98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::cit_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01400">1400</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a93e8a7857c8b60836f78d0d2559407c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete all the elements of the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00373">373</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a042aa52d0299a0cb68ccd0f6198d80b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::const_iterator_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos1</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a position in the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the position. If don't exists throws an exception </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log N) </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00476">476</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a85e89acd93ccaa51ca09bff10670a158"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00017.html#af7068803ee650162b40db6d6244d54de">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the number of elements in the <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> with the key x </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements in the <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> with the key x </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is log (N) </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00533">533</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa057453b05b15a87625da1c08dc04119"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#a3990dba2554010bdcb0182b0187e2b7f">const_reverse_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::crbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01455">1455</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5f0e39907621e99128ba072bac7965e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#a3990dba2554010bdcb0182b0187e2b7f">const_reverse_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::crend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01479">1479</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab9bc762d671677d8999fe51b62fa5adf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#a3990dba2554010bdcb0182b0187e2b7f">const_reverse_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::crit_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01423">1423</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abad5240838fe0c886925fd05b8ac4b68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#a3990dba2554010bdcb0182b0187e2b7f">const_reverse_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::crit_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01431">1431</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a14d13107474bd9085168bda91a29da8c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#a3990dba2554010bdcb0182b0187e2b7f">const_reverse_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::crit_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01439">1439</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9fcbea716a7baa8875b5d853b3d618d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#a3990dba2554010bdcb0182b0187e2b7f">const_reverse_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::crit_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01463">1463</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4e9f8047710b7ec9abe4a130e38ae4d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a value in the set </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>: arguments needed for to build the node to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00689">689</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3c28e7f48b9d38618ca0fe4d784f57b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::emplace_hint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a value in the set </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">const_iterator</td><td>for to hel in the insertion ( unused) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>: arguments needed for to build the node to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00733">733</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a09e3c569d9cb8f8a9730498403129092"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::emplace_if </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a value in the set </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format bool( const value_t &amp;). if return true the element is iserted , if false not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted or or to the element that prevented the insertion When the element is rejected by the function , the itertor is <a class="el" href="a00017.html#a40707b27ba587a9460bada710e901955">end()</a> </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00710">710</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac535867ca577306e4b76808a98da41ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::emplace_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00017.html#aa142db9e70c7ad8256e1a6c325670e47">mtx_write</a> &amp;&#160;</td>
          <td class="paramname"><em>BM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00017.html#a847345ef25e35cc186840c77e480da46">connector</a>&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in a the position specified by the connector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">BM</td><td>: barrier modify needed for to exec the wait_no_readers inside the function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>: connector which indicate where must insert the node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>: arguments to build the node to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ). DOn't be used by the final users </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00625">625</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a115b16c89064ffbca6f5e7161bbc2e90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>indicate if the <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> is empty </p>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> is empty, false in any other case </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00408">408</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a40707b27ba587a9460bada710e901955"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01376">1376</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a718397f627c03a7565166ffb19744517"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="a00017.html#ac883ae93d6c5d0f229fe498f24007976">iterator</a>,<a class="el" href="a00017.html#ac883ae93d6c5d0f229fe498f24007976">iterator</a>&gt; <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00017.html#af7068803ee650162b40db6d6244d54de">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a pair of iterators, the first is the lower_bound (x) and the second is upper_bound (x) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>:key to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of iterators </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00566">566</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a924232aef056f0d5bf7958f1200c4c1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element pointed by iter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>: iterator to the element to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01087">1087</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6333318801724ebd2a2c19f588fd7479"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00017.html#af7068803ee650162b40db6d6244d54de">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase all the elements with a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key of all the elements to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements erased </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01116">1116</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a11f3d857c1d5b896f125c010a0ec5eaa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase a range of elements in the range first, last </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>: iterator to the first element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>: iterator to the last element of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01148">1148</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0a8d5468c67e2074485f6c9548dc213e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element pointed by iter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>: iterator to the element to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format bool(const value_t &amp;). if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01102">1102</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad2793aa6e35fc826f46c1793e75d84dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::erase_if </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00017.html#af7068803ee650162b40db6d6244d54de">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase all the elements with a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key of all the elements to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format bool(const value_t &amp;). if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements erased </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01133">1133</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a03feeb2f7efa7196b2087d1b89186390"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase a range of elements between first_it and last_it </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first_it</td><td>: const_iterator to the first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last_it</td><td>: const_iterator to the final element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format bool(const value_t &amp;). if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements erased </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01165">1165</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a293d727959c150efe33c3e92d80ee264"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::erase_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element of the position pos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>: position to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01179">1179</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a133884c983e1ddc1af63cab620a79ee7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::erase_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Prim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>NElem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase NElem elements beginning in the position Prim </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Prim</td><td>: position to the first element to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Position</td><td>to the last element to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01212">1212</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab45b5a552a7b0ce4925b3c50a9264810"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::erase_pos_if </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element of the position pos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>: position to delete </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format bool(const value_t &amp;). if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01195">1195</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a10023578f4df19297258e22fbafff37d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::erase_pos_if </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Prim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>NElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase NElem elements beginning in the position Prim </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Prim</td><td>: position to the first element to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NElem</td><td>: Number of elements to delete </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format bool(const value_t &amp;). if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01228">1228</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a45f9d8f85b94c6f488f85682f1aede2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ac883ae93d6c5d0f229fe498f24007976">iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00017.html#af7068803ee650162b40db6d6244d54de">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the iterator to the element with the key x </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key to find in the <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element with the key x. If don't exist return <a class="el" href="a00017.html#a40707b27ba587a9460bada710e901955">end()</a> </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00522">522</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad88a47fbd58f7324578dfc25c8161b85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t&amp; <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const_reference to the first element in the sorted_tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the first element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00487">487</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af74b74a403c2f76d56b7aa9ace9105ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#a8d28e628e31fd9d79f52d9b6d66938f9">allocator_type</a>&amp; <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the object allocator of the set </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>object allocator </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01280">1280</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3d6c84ddcc8ac134629206f5be0e156d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a value in the <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Val</td><td>: value to insert. It can ve a value , a reference or an rvalue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00640">640</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a35e213fb86ba45454c1cdc7d2fb5b06b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00017.html#a8ddb091d31b7a4ce0effe97b51d09996">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a value in the <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterator</td><td>for to help in the insertion ( unused) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00668">668</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0919f687b417e49eb846322c86b75c10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00017.html#a8ddb091d31b7a4ce0effe97b51d09996">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a value in the <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterator</td><td>for to help in the insertion ( unused) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>: value to insert with rvalue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00678">678</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2cf5c0de65a8c77e5017f07892b63ca7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insertion of range of elements from two iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>: Iterator to the first element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>: Iterator to the last lement of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00744">744</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4296b7d03665c5eefc39ba18bbe8cebc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function , class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::insert_if </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>Val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a value in the set </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>: value to insert It can ve a value , a reference or an rvalue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format bool( const value_t &amp;). if return true the element is iserted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted or or to the element that prevented the insertion When the element is rejected by the function , the itertor is <a class="el" href="a00017.html#a40707b27ba587a9460bada710e901955">end()</a> </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00654">654</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8bbc79418437c54d765433d8bb13ae44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator , class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::insert_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insertion of range of elements from two iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>: Iterator to the first element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>: Iterator to the last lement of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format bool( const value_t &amp;). if return true the element is iserted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00760">760</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a24ca436edde9ec515134368c29e9e89d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::is_mine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00017.html#affd8de91883f601dadb3bd8e83ce15f7">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the iterator is pointing to this set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: iterator to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(true/false ) Indicate if it is pointing to this set </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01310">1310</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac50245d0b481d82b77a82abd3809b28a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::is_mine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00017.html#a3990dba2554010bdcb0182b0187e2b7f">const_reverse_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the iterator is pointing to this set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: iterator to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(true/false ) Indicate if it is pointing to this set </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01321">1321</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2fae6a44bba242989c027cf3b34e0d29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#a4914d910164a4d95b388b2508863a9dd">key_compare</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::key_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the object used to compare two keys </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>object used to compare two keys </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01260">1260</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="add20c972445fcf10221244f328fc8722"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ac883ae93d6c5d0f229fe498f24007976">iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00017.html#af7068803ee650162b40db6d6244d54de">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return one iterator to the first appearance of the key x if exist <br/>
 and if don't exist return one iterator to the first element greather than x </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00544">544</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7bb5445e635c21c2a2884b97e0ba94f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::max_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the maximun size of the container </p>
<dl class="section return"><dt>Returns</dt><dd>maximun size of the container </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00426">426</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5aaf2422689cf4f5bf1736e2fd530681"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html">cntree_multiset</a>&amp; <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00017.html">cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asignation operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>: setr from where copy the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> after the copy </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00280">280</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1d685ef8f17fec74053d89462c50f332"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename alloc_t2 , bool cnc2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html">cntree_multiset</a>&amp; <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00017.html">cntree_multiset</a>&lt; value_t, cnc2, comp_key_t, alloc_t2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asignation operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>: <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> after the copy </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00295">295</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a70f058059a072920e2e315953972503d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename alloc_t2 , bool cnc2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html">cntree_multiset</a>&amp; <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00018.html">cntree_set</a>&lt; value_t, cnc2, comp_key_t, alloc_t2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asignation operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>: <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> after the copy </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00311">311</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a90cc4aaa65bea1d353191546c18d87b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html">cntree_multiset</a>&amp; <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00017.html">cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asignation operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>: <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> from where move the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> after the copy </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00326">326</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afcfb5f92c91464e59733e9ed347ee2bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;bool cnc2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html">cntree_multiset</a>&amp; <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00017.html">cntree_multiset</a>&lt; value_t, cnc2, comp_key_t, alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> from where move the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00341">341</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7781270db6fe7233706c585ea31819f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;bool cnc2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html">cntree_multiset</a>&amp; <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00018.html">cntree_set</a>&lt; value_t, cnc2, comp_key_t, alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> from where move the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00357">357</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af8bcb5702dcb2b868e18ecd53625e1fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pop_back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant) </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00941">941</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed3da27f7cdb5a919800162dd0c548db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pop_back_if </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format bool(const value_t &amp;). if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree 2 - Function returns false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant) </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00958">958</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af0878b9401c9dd2336a4df2e2dd63546"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pop_copy_back </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the tree and return a copy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00977">977</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a547d9f0915d4371b99a479da6b7b0f18"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pop_copy_back_if </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the tree and return a copy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format bool(const value_t &amp;). if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree 2 - Function returns false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00999">999</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a11bc5c6b264c40c3dc0eea25c418c50b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pop_copy_front </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the tree and return a copy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00841">841</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9a9dca95e70ee501252ca24a1f26bb28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pop_copy_front_if </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the tree and return a copy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format bool(const value_t &amp;). if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree 2 - Function returns false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00863">863</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a56d44ba1b00e3167d8b80c092fb78e1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pop_front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (constant) </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00804">804</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acd1863b2c7fb9a2ae806f6aa16d49d34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pop_front_if </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format bool(const value_t &amp;). if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree 2 - Function returns false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (constant) </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00821">821</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9bf06304569fa0862bca05224acadf0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pop_move_back </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the tree and return a copy with rvalues </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01018">1018</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a823815fe7fd9c12b9f6efab0917e0967"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pop_move_back_if </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the tree and return a copy with rvalues </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format bool(const value_t &amp;). if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01039">1039</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a805344ae93e6f3f723dc3fe77ba9804b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pop_move_front </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the tree and return a copy with rvalues </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00882">882</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a38812a5f9c0ffcd155892f451c1ea64a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pop_move_front_if </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the tree and return a copy with rvalues </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format bool(const value_t &amp;). if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00903">903</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3e147a478047f862deca40beeb61903c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t&amp; <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos1</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to an element by their position in the <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the object selected </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is an random access function of the <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a>.<br/>
 I didn't use the operator [ ] because it is used in the map class, and the function at is used in std map in C++11<br/>
 It is very important to be uniform access method in the four classes( cntree_multiset, cntree_multiset, map and multimap)<br/>
 This operation is O (log(N)) </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00464">464</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a467885454cd3c23a273e72d0617e72dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#a3990dba2554010bdcb0182b0187e2b7f">const_reverse_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01447">1447</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb89201862efe14e85b94fe09956a48d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#a3990dba2554010bdcb0182b0187e2b7f">const_reverse_iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01471">1471</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9d02ce2bac6ae56bfab125cf785d7dd8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the number of elements in the <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> </p>
<dl class="section return"><dt>Returns</dt><dd>number of elements in the <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00417">417</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae0c2d4060d5c0705a2c0501e981f0bff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00017.html">cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>swap the data of the <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> st with the actual <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">st</td><td>: <a class="el" href="a00017.html" title="This class have the same interface than the STL set, plus access by position with the function at...">cntree_multiset</a> to swap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00385">385</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a059c573215d8598add052136aefff3de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ac883ae93d6c5d0f229fe498f24007976">iterator</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00017.html#af7068803ee650162b40db6d6244d54de">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return one iterator to the first element greather than x. If don't exist any element greather than x , return <a class="el" href="a00017.html#a40707b27ba587a9460bada710e901955">end()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: key to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l00555">555</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2b7f82de54d855c318ebc1aa1460ebf2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ad557c83a2b049e0ac140154b9fc84365">value_compare</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::value_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the object used to compare two values </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>object used to compare two values </dd></dl>

<p>Definition at line <a class="el" href="a00112_source.html#l01270">1270</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a2322fd5e1cffe75b7cf1508b4f3b6d44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class value_t2 , bool cnc2, typename comp_key_t2 , typename alloc_t2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="a00017.html">cntree_multiset</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00092">92</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5fe7b75d71ee9e25d2ab8e361676c077"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class value_t2 , bool cnc2, typename comp_key_t2 , typename alloc_t2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="a00018.html">cntree_set</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00093">93</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a0cb9ba0b2636b10dd8a4bb3b9e0dd93d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#a83f74fcec6c1b8ce82f7e9d32b659f44">mtx_data</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::BD</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00104">104</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9ef560970a45c9e4caf09480dda45ca3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename comp_key_t = std::less&lt;value_t&gt;, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00017.html#ab58b629a05562913c9024181967262c4">srt_tree_t</a> <a class="el" href="a00017.html">countertree::cntree_multiset</a>&lt; value_t, cnc, comp_key_t, alloc_t &gt;::st</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00112_source.html#l00097">97</a> of file <a class="el" href="a00112_source.html">cntree_multiset.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00112_source.html">cntree_multiset.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00147.html">countertree</a></li><li class="navelem"><a class="el" href="a00017.html">cntree_multiset</a></li>
    <li class="footer">Generated on Mon Oct 14 2013 22:46:59 for [ countertree + suballocator ] by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
