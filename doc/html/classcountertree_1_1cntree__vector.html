<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Countertree: countertree::cntree_vector&lt; value_t, cnc, alloc_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Countertree
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">concurrent set , multiset map and multimap with random access iterators</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcountertree_1_1cntree__vector.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classcountertree_1_1cntree__vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">countertree::cntree_vector&lt; value_t, cnc, alloc_t &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class have the same interface than the STL vector, but istead of be a vector is a tree. <br/>
 Due to this all the operations ( insert, delete, access) a O( logN). <br/>
.  
 <a href="classcountertree_1_1cntree__vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a62f8be059bc86f9ccc8f3efd80a8163b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structcountertree_1_1config__barrier.html">config_barrier</a>&lt; cnc &gt;<br class="typebreak"/>
::<a class="el" href="classcountertree_1_1cntree__vector.html#a62f8be059bc86f9ccc8f3efd80a8163b">barrier_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a62f8be059bc86f9ccc8f3efd80a8163b">barrier_data</a></td></tr>
<tr class="separator:a62f8be059bc86f9ccc8f3efd80a8163b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d6538bd64e1e32bdeb295ddec0d781"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structcountertree_1_1config__barrier.html">config_barrier</a>&lt; cnc &gt;<br class="typebreak"/>
::<a class="el" href="classcountertree_1_1cntree__vector.html#ae4d6538bd64e1e32bdeb295ddec0d781">barrier_read</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#ae4d6538bd64e1e32bdeb295ddec0d781">barrier_read</a></td></tr>
<tr class="separator:ae4d6538bd64e1e32bdeb295ddec0d781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e448b604750c070e9d6a60885ecc630"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structcountertree_1_1config__barrier.html">config_barrier</a>&lt; cnc &gt;<br class="typebreak"/>
::<a class="el" href="classcountertree_1_1cntree__vector.html#a9e448b604750c070e9d6a60885ecc630">barrier_modify</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a9e448b604750c070e9d6a60885ecc630">barrier_modify</a></td></tr>
<tr class="separator:a9e448b604750c070e9d6a60885ecc630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4defa8ea643d60d28ab7e0b32aa7a37f"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="structcountertree_1_1forest_1_1node.html">countertree::forest::node</a><br class="typebreak"/>
&lt; value_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a4defa8ea643d60d28ab7e0b32aa7a37f">node_t</a></td></tr>
<tr class="separator:a4defa8ea643d60d28ab7e0b32aa7a37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0f814170aa1d0ab669794e311f638b"><td class="memItemLeft" align="right" valign="top">typedef alloc_t::template <br class="typebreak"/>
rebind&lt; <a class="el" href="classcountertree_1_1cntree__vector.html#a4defa8ea643d60d28ab7e0b32aa7a37f">node_t</a> &gt;::other&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#adc0f814170aa1d0ab669794e311f638b">node_alloc_t</a></td></tr>
<tr class="separator:adc0f814170aa1d0ab669794e311f638b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43753d3c0e064cc6d601496645811657"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html">c_forest::tree</a><br class="typebreak"/>
&lt; value_t, <a class="el" href="classcountertree_1_1cntree__vector.html#adc0f814170aa1d0ab669794e311f638b">node_alloc_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a43753d3c0e064cc6d601496645811657">tree_t</a></td></tr>
<tr class="separator:a43753d3c0e064cc6d601496645811657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cf48091959d644080dfdfb462998c2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#af62e7d9749b95b2cfe4aa45a1ba09d3a">tree_t::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a76cf48091959d644080dfdfb462998c2">size_type</a></td></tr>
<tr class="separator:a76cf48091959d644080dfdfb462998c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1206c13bbfb20d762a1b3e28662e784e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#ac4899fc42db7c3418d99a86118933342">tree_t::difference_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a1206c13bbfb20d762a1b3e28662e784e">difference_type</a></td></tr>
<tr class="separator:a1206c13bbfb20d762a1b3e28662e784e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87cf343c3367539a136887208feeee1d"><td class="memItemLeft" align="right" valign="top">typedef value_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a></td></tr>
<tr class="separator:a87cf343c3367539a136887208feeee1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e3cfb56871236abfb5dceb841797b0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a38e3cfb56871236abfb5dceb841797b0">pointer</a></td></tr>
<tr class="separator:a38e3cfb56871236abfb5dceb841797b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5f52cde3f23c059262c35b8dd529c4"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a7d5f52cde3f23c059262c35b8dd529c4">const_pointer</a></td></tr>
<tr class="separator:a7d5f52cde3f23c059262c35b8dd529c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e5b16f508fded9604f1708112c75b5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a75e5b16f508fded9604f1708112c75b5">reference</a></td></tr>
<tr class="separator:a75e5b16f508fded9604f1708112c75b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7707089005acdf518d94759af5176b40"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a7707089005acdf518d94759af5176b40">const_reference</a></td></tr>
<tr class="separator:a7707089005acdf518d94759af5176b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a9f2752a974795fba5d7ae1cad3695"><td class="memItemLeft" align="right" valign="top">typedef alloc_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#ad0a9f2752a974795fba5d7ae1cad3695">allocator_type</a></td></tr>
<tr class="separator:ad0a9f2752a974795fba5d7ae1cad3695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7de56907efcce713cbd358c14b5906c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">tree_t::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a></td></tr>
<tr class="separator:ad7de56907efcce713cbd358c14b5906c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb62c282670d63c6ae02c0d9b6c096b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">tree_t::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a></td></tr>
<tr class="separator:abcb62c282670d63c6ae02c0d9b6c096b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be73be0ae348fa005c4e399186d91ff"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">tree_t::reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a></td></tr>
<tr class="separator:a7be73be0ae348fa005c4e399186d91ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bd4af0141eb3ccd69c9385f94f3e0f"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">tree_t::const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a></td></tr>
<tr class="separator:a43bd4af0141eb3ccd69c9385f94f3e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225e342728d3e2d927f54aa78728f883"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; <a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a225e342728d3e2d927f54aa78728f883">mypair</a></td></tr>
<tr class="separator:a225e342728d3e2d927f54aa78728f883"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a344c20c31fd347cf4ed4f16ab0d438fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a344c20c31fd347cf4ed4f16ab0d438fb">cntree_vector</a> (const alloc_t &amp;ALLC=alloc_t())</td></tr>
<tr class="memdesc:a344c20c31fd347cf4ed4f16ab0d438fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from an object Allocator.  <a href="#a344c20c31fd347cf4ed4f16ab0d438fb">More...</a><br/></td></tr>
<tr class="separator:a344c20c31fd347cf4ed4f16ab0d438fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594872e2afc204197d7660571659c2dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a594872e2afc204197d7660571659c2dc">cntree_vector</a> (const <a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a> &amp;VT)</td></tr>
<tr class="memdesc:a594872e2afc204197d7660571659c2dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a594872e2afc204197d7660571659c2dc">More...</a><br/></td></tr>
<tr class="separator:a594872e2afc204197d7660571659c2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81e0fdbc22bb24af7aa0f84e899c97a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#ad81e0fdbc22bb24af7aa0f84e899c97a">cntree_vector</a> (<a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a> &amp;&amp;VT)</td></tr>
<tr class="memdesc:ad81e0fdbc22bb24af7aa0f84e899c97a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#ad81e0fdbc22bb24af7aa0f84e899c97a">More...</a><br/></td></tr>
<tr class="separator:ad81e0fdbc22bb24af7aa0f84e899c97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba70b9a3a7162c384dd3bdf2b0f6913f"><td class="memTemplParams" colspan="2">template&lt;typename alloc_t2  = alloc_t, bool cnc2 = cnc&gt; </td></tr>
<tr class="memitem:aba70b9a3a7162c384dd3bdf2b0f6913f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#aba70b9a3a7162c384dd3bdf2b0f6913f">cntree_vector</a> (const <a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a>&lt; value_t, cnc2, alloc_t2 &gt; &amp;VT)</td></tr>
<tr class="memdesc:aba70b9a3a7162c384dd3bdf2b0f6913f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asignation operator.  <a href="#aba70b9a3a7162c384dd3bdf2b0f6913f">More...</a><br/></td></tr>
<tr class="separator:aba70b9a3a7162c384dd3bdf2b0f6913f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8675fd4c7e9a6631c1b881dfdad894b"><td class="memTemplParams" colspan="2">template&lt;bool cnc2&gt; </td></tr>
<tr class="memitem:ac8675fd4c7e9a6631c1b881dfdad894b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#ac8675fd4c7e9a6631c1b881dfdad894b">cntree_vector</a> (<a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a>&lt; value_t, cnc2, alloc_t &gt; &amp;&amp;VT)</td></tr>
<tr class="memdesc:ac8675fd4c7e9a6631c1b881dfdad894b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#ac8675fd4c7e9a6631c1b881dfdad894b">More...</a><br/></td></tr>
<tr class="separator:ac8675fd4c7e9a6631c1b881dfdad894b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9632c5c54d53f81381d6e3668c533a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#acb9632c5c54d53f81381d6e3668c533a">cntree_vector</a> (unsigned_type n, const value_t &amp;Val=value_t(), const alloc_t &amp;A=alloc_t())</td></tr>
<tr class="memdesc:acb9632c5c54d53f81381d6e3668c533a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from a value repeated a number of times and an object Allocator.  <a href="#acb9632c5c54d53f81381d6e3668c533a">More...</a><br/></td></tr>
<tr class="separator:acb9632c5c54d53f81381d6e3668c533a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1190b582c791f6e9c09301608ff3aac"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:aa1190b582c791f6e9c09301608ff3aac"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#aa1190b582c791f6e9c09301608ff3aac">cntree_vector</a> (InputIterator it_first, InputIterator it_last, const alloc_t &amp;A=alloc_t())</td></tr>
<tr class="memdesc:aa1190b582c791f6e9c09301608ff3aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from a pair of iterators and an object Allocator.  <a href="#aa1190b582c791f6e9c09301608ff3aac">More...</a><br/></td></tr>
<tr class="separator:aa1190b582c791f6e9c09301608ff3aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af145677a55604df5465cfbaba5e3dba4"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#af145677a55604df5465cfbaba5e3dba4">~cntree_vector</a> (void)</td></tr>
<tr class="memdesc:af145677a55604df5465cfbaba5e3dba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#af145677a55604df5465cfbaba5e3dba4">More...</a><br/></td></tr>
<tr class="separator:af145677a55604df5465cfbaba5e3dba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106653ec27cdda561bd86fb08ccfcf03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a106653ec27cdda561bd86fb08ccfcf03">operator=</a> (const <a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a> &amp;VT)</td></tr>
<tr class="memdesc:a106653ec27cdda561bd86fb08ccfcf03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asignation operator.  <a href="#a106653ec27cdda561bd86fb08ccfcf03">More...</a><br/></td></tr>
<tr class="separator:a106653ec27cdda561bd86fb08ccfcf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bf41521b42e053728c32d649e584c8"><td class="memTemplParams" colspan="2">template&lt;typename alloc_t2 , bool cnc2&gt; </td></tr>
<tr class="memitem:ab1bf41521b42e053728c32d649e584c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#ab1bf41521b42e053728c32d649e584c8">operator=</a> (const <a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a>&lt; value_t, cnc2, alloc_t2 &gt; &amp;VT)</td></tr>
<tr class="memdesc:ab1bf41521b42e053728c32d649e584c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asignation operator.  <a href="#ab1bf41521b42e053728c32d649e584c8">More...</a><br/></td></tr>
<tr class="separator:ab1bf41521b42e053728c32d649e584c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2164589da63a2f4cb2c1416eec65436"><td class="memTemplParams" colspan="2">template&lt;bool cnc2&gt; </td></tr>
<tr class="memitem:ac2164589da63a2f4cb2c1416eec65436"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#ac2164589da63a2f4cb2c1416eec65436">operator=</a> (<a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a>&lt; value_t, cnc2, alloc_t &gt; &amp;&amp;A)</td></tr>
<tr class="memdesc:ac2164589da63a2f4cb2c1416eec65436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asignation operator.  <a href="#ac2164589da63a2f4cb2c1416eec65436">More...</a><br/></td></tr>
<tr class="separator:ac2164589da63a2f4cb2c1416eec65436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae271710d82d3a0165821169863316945"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:ae271710d82d3a0165821169863316945"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#ae271710d82d3a0165821169863316945">assign</a> (InputIterator it_first, InputIterator it_last)</td></tr>
<tr class="memdesc:ae271710d82d3a0165821169863316945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a range of data, dropping all the elements of the container It's like the assignation operator but with several parameters.  <a href="#ae271710d82d3a0165821169863316945">More...</a><br/></td></tr>
<tr class="separator:ae271710d82d3a0165821169863316945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42638c1a9c3da5539fe5b488d09ad6f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a42638c1a9c3da5539fe5b488d09ad6f5">assign</a> (unsigned_type n, const value_t &amp;u)</td></tr>
<tr class="memdesc:a42638c1a9c3da5539fe5b488d09ad6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a range of data, dropping all the elements of the container It's like the assignation operator but with several parameters.  <a href="#a42638c1a9c3da5539fe5b488d09ad6f5">More...</a><br/></td></tr>
<tr class="separator:a42638c1a9c3da5539fe5b488d09ad6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133cc49537ff0ab05a4d4dd40cbd5999"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a133cc49537ff0ab05a4d4dd40cbd5999"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a133cc49537ff0ab05a4d4dd40cbd5999">assign_if</a> (InputIterator it_first, InputIterator it_last, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt; M)</td></tr>
<tr class="memdesc:a133cc49537ff0ab05a4d4dd40cbd5999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a range of data, dropping all the elements of the container It's like the assignation operator but with several parameters.  <a href="#a133cc49537ff0ab05a4d4dd40cbd5999">More...</a><br/></td></tr>
<tr class="separator:a133cc49537ff0ab05a4d4dd40cbd5999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeeba4da0cb6bd0e93e170f23d31d6ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#afeeba4da0cb6bd0e93e170f23d31d6ab">clear</a> (void)</td></tr>
<tr class="memdesc:afeeba4da0cb6bd0e93e170f23d31d6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all the elements of the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>.  <a href="#afeeba4da0cb6bd0e93e170f23d31d6ab">More...</a><br/></td></tr>
<tr class="separator:afeeba4da0cb6bd0e93e170f23d31d6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb8161d8d8e5a3e5a31c358fa565bfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#afbb8161d8d8e5a3e5a31c358fa565bfc">swap</a> (<a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a> &amp;A) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:afbb8161d8d8e5a3e5a31c358fa565bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap the data between the two <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>  <a href="#afbb8161d8d8e5a3e5a31c358fa565bfc">More...</a><br/></td></tr>
<tr class="separator:afbb8161d8d8e5a3e5a31c358fa565bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938c8e7b8066ef4e3907c256f953f098"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a938c8e7b8066ef4e3907c256f953f098">size</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a938c8e7b8066ef4e3907c256f953f098"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of elements in the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>  <a href="#a938c8e7b8066ef4e3907c256f953f098">More...</a><br/></td></tr>
<tr class="separator:a938c8e7b8066ef4e3907c256f953f098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ce0a0cb03c86dc51c655fab20eaa9d"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a13ce0a0cb03c86dc51c655fab20eaa9d">max_size</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a13ce0a0cb03c86dc51c655fab20eaa9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the maximun size of the container  <a href="#a13ce0a0cb03c86dc51c655fab20eaa9d">More...</a><br/></td></tr>
<tr class="separator:a13ce0a0cb03c86dc51c655fab20eaa9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0399fba189f3010653664f2a07ba387f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a0399fba189f3010653664f2a07ba387f">resize</a> (signed_type sz, value_t c=value_t())</td></tr>
<tr class="memdesc:a0399fba189f3010653664f2a07ba387f"><td class="mdescLeft">&#160;</td><td class="mdescRight">resize the current vector size and change to sz.<br/>
 If sz is smaller than the current size, delete elements to end<br/>
 If sz is greater than the current size, insert elements to the end with the value c  <a href="#a0399fba189f3010653664f2a07ba387f">More...</a><br/></td></tr>
<tr class="separator:a0399fba189f3010653664f2a07ba387f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d3c4a6ad67cd69128d8f9e1c948b19"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#ad9d3c4a6ad67cd69128d8f9e1c948b19">capacity</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ad9d3c4a6ad67cd69128d8f9e1c948b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the maximun size of the container  <a href="#ad9d3c4a6ad67cd69128d8f9e1c948b19">More...</a><br/></td></tr>
<tr class="separator:ad9d3c4a6ad67cd69128d8f9e1c948b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05fa08d8156b2cf1be54148874731b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#ab05fa08d8156b2cf1be54148874731b2">empty</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ab05fa08d8156b2cf1be54148874731b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicate if the map is empty  <a href="#ab05fa08d8156b2cf1be54148874731b2">More...</a><br/></td></tr>
<tr class="separator:ab05fa08d8156b2cf1be54148874731b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154c3aadf8e287cd2f35cf8721846857"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a154c3aadf8e287cd2f35cf8721846857">reserve</a> (signed_type n) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a154c3aadf8e287cd2f35cf8721846857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the capacity for to contain , at least n elements.  <a href="#a154c3aadf8e287cd2f35cf8721846857">More...</a><br/></td></tr>
<tr class="separator:a154c3aadf8e287cd2f35cf8721846857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430b67855e0b0796d8086d7138c50414"><td class="memItemLeft" align="right" valign="top">value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a430b67855e0b0796d8086d7138c50414">at</a> (signed_type Pos) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a430b67855e0b0796d8086d7138c50414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked access to an element by their position in the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>.  <a href="#a430b67855e0b0796d8086d7138c50414">More...</a><br/></td></tr>
<tr class="separator:a430b67855e0b0796d8086d7138c50414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e240e500a80d4396f7503ca9268fb8b"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a3e240e500a80d4396f7503ca9268fb8b">at</a> (signed_type Pos) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a3e240e500a80d4396f7503ca9268fb8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked access to an element by their position in the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>.  <a href="#a3e240e500a80d4396f7503ca9268fb8b">More...</a><br/></td></tr>
<tr class="separator:a3e240e500a80d4396f7503ca9268fb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f89089e07505024f6216bbb7fd5c3a"><td class="memItemLeft" align="right" valign="top">value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a11f89089e07505024f6216bbb7fd5c3a">operator[]</a> (signed_type Pos) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a11f89089e07505024f6216bbb7fd5c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked access to an element by their position in the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>.  <a href="#a11f89089e07505024f6216bbb7fd5c3a">More...</a><br/></td></tr>
<tr class="separator:a11f89089e07505024f6216bbb7fd5c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04a32ab965d08a6d028fe515d5f4b3a"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#af04a32ab965d08a6d028fe515d5f4b3a">operator[]</a> (signed_type Pos) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:af04a32ab965d08a6d028fe515d5f4b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked access to an element by their position in the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>.  <a href="#af04a32ab965d08a6d028fe515d5f4b3a">More...</a><br/></td></tr>
<tr class="separator:af04a32ab965d08a6d028fe515d5f4b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a023d059f84ec5f2798381208458708"><td class="memItemLeft" align="right" valign="top">value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a1a023d059f84ec5f2798381208458708">front</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a1a023d059f84ec5f2798381208458708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the first element in the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>.  <a href="#a1a023d059f84ec5f2798381208458708">More...</a><br/></td></tr>
<tr class="separator:a1a023d059f84ec5f2798381208458708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21565c8b856507c247539f6ae95c00a4"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a21565c8b856507c247539f6ae95c00a4">front</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a21565c8b856507c247539f6ae95c00a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const_reference to the first element in the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>.  <a href="#a21565c8b856507c247539f6ae95c00a4">More...</a><br/></td></tr>
<tr class="separator:a21565c8b856507c247539f6ae95c00a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6267e7911794d81f93dd9c2d1c3c7e69"><td class="memItemLeft" align="right" valign="top">value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a6267e7911794d81f93dd9c2d1c3c7e69">back</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a6267e7911794d81f93dd9c2d1c3c7e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the last element in the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>.  <a href="#a6267e7911794d81f93dd9c2d1c3c7e69">More...</a><br/></td></tr>
<tr class="separator:a6267e7911794d81f93dd9c2d1c3c7e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f097cc0a4cd7632ccd18e3b3f7ff924"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a3f097cc0a4cd7632ccd18e3b3f7ff924">back</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a3f097cc0a4cd7632ccd18e3b3f7ff924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const_reference to the last element in the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>.  <a href="#a3f097cc0a4cd7632ccd18e3b3f7ff924">More...</a><br/></td></tr>
<tr class="separator:a3f097cc0a4cd7632ccd18e3b3f7ff924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c32244e91820d940c9be0fd8884b435"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a9c32244e91820d940c9be0fd8884b435">push_front</a> (const value_t &amp;D)</td></tr>
<tr class="memdesc:a9c32244e91820d940c9be0fd8884b435"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in the front of the container  <a href="#a9c32244e91820d940c9be0fd8884b435">More...</a><br/></td></tr>
<tr class="separator:a9c32244e91820d940c9be0fd8884b435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd94db19d1b7f476aba9e3e0c935e02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a4fd94db19d1b7f476aba9e3e0c935e02">push_front_if</a> (const value_t &amp;D, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt; M)</td></tr>
<tr class="memdesc:a4fd94db19d1b7f476aba9e3e0c935e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in the front of the container  <a href="#a4fd94db19d1b7f476aba9e3e0c935e02">More...</a><br/></td></tr>
<tr class="separator:a4fd94db19d1b7f476aba9e3e0c935e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be15443e2ba2c9d6666ab991b2a67bd"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a9be15443e2ba2c9d6666ab991b2a67bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a9be15443e2ba2c9d6666ab991b2a67bd">emplace_front</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a9be15443e2ba2c9d6666ab991b2a67bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in the front of the container  <a href="#a9be15443e2ba2c9d6666ab991b2a67bd">More...</a><br/></td></tr>
<tr class="separator:a9be15443e2ba2c9d6666ab991b2a67bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a763a9a500148bd32f568c8fdae0e57"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a2a763a9a500148bd32f568c8fdae0e57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a2a763a9a500148bd32f568c8fdae0e57">emplace_front_if</a> (std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt; M, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a2a763a9a500148bd32f568c8fdae0e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in the front of the container  <a href="#a2a763a9a500148bd32f568c8fdae0e57">More...</a><br/></td></tr>
<tr class="separator:a2a763a9a500148bd32f568c8fdae0e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcb8871f9f617e12e862680a24989d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#aadcb8871f9f617e12e862680a24989d1">push_back</a> (const value_t &amp;D)</td></tr>
<tr class="memdesc:aadcb8871f9f617e12e862680a24989d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert one element in the back of the container.  <a href="#aadcb8871f9f617e12e862680a24989d1">More...</a><br/></td></tr>
<tr class="separator:aadcb8871f9f617e12e862680a24989d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19888249e6317faa8d83dc6406131ecb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a19888249e6317faa8d83dc6406131ecb">push_back_if</a> (const value_t &amp;D, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt; M)</td></tr>
<tr class="memdesc:a19888249e6317faa8d83dc6406131ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert one element in the back of the container.  <a href="#a19888249e6317faa8d83dc6406131ecb">More...</a><br/></td></tr>
<tr class="separator:a19888249e6317faa8d83dc6406131ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d926610131daae834ac3d18ded02cae"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a5d926610131daae834ac3d18ded02cae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a5d926610131daae834ac3d18ded02cae">emplace_back</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a5d926610131daae834ac3d18ded02cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert one element in the back of the container.  <a href="#a5d926610131daae834ac3d18ded02cae">More...</a><br/></td></tr>
<tr class="separator:a5d926610131daae834ac3d18ded02cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043faa007319c6cf9428f364a7d63514"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a043faa007319c6cf9428f364a7d63514"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a043faa007319c6cf9428f364a7d63514">emplace_back_if</a> (std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt; M, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a043faa007319c6cf9428f364a7d63514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert one element in the back of the container.  <a href="#a043faa007319c6cf9428f364a7d63514">More...</a><br/></td></tr>
<tr class="separator:a043faa007319c6cf9428f364a7d63514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b40dd87eb147780cb53043bc4789a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a04b40dd87eb147780cb53043bc4789a2">insert_pos</a> (signed_type Pos, const value_t &amp;D)</td></tr>
<tr class="memdesc:a04b40dd87eb147780cb53043bc4789a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in a specified position  <a href="#a04b40dd87eb147780cb53043bc4789a2">More...</a><br/></td></tr>
<tr class="separator:a04b40dd87eb147780cb53043bc4789a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7742e1cce4e7d058e242fd49f6da895c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a7742e1cce4e7d058e242fd49f6da895c">insert_pos_if</a> (signed_type Pos, const value_t &amp;D, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt; M)</td></tr>
<tr class="memdesc:a7742e1cce4e7d058e242fd49f6da895c"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in a specified position  <a href="#a7742e1cce4e7d058e242fd49f6da895c">More...</a><br/></td></tr>
<tr class="separator:a7742e1cce4e7d058e242fd49f6da895c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7d34c3f93974224d263f663a9af05a"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a5d7d34c3f93974224d263f663a9af05a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a5d7d34c3f93974224d263f663a9af05a">emplace_pos</a> (signed_type Pos, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a5d7d34c3f93974224d263f663a9af05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in a specified position  <a href="#a5d7d34c3f93974224d263f663a9af05a">More...</a><br/></td></tr>
<tr class="separator:a5d7d34c3f93974224d263f663a9af05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af974ab4ec3222e7c0c8e0c2525bd46a1"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:af974ab4ec3222e7c0c8e0c2525bd46a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#af974ab4ec3222e7c0c8e0c2525bd46a1">emplace_pos_if</a> (signed_type Pos, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt; M, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:af974ab4ec3222e7c0c8e0c2525bd46a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in a specified position  <a href="#af974ab4ec3222e7c0c8e0c2525bd46a1">More...</a><br/></td></tr>
<tr class="separator:af974ab4ec3222e7c0c8e0c2525bd46a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4836227fe01fe94b7c8f376e0c5d47d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a4836227fe01fe94b7c8f376e0c5d47d7">insert</a> (<a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> iter, const value_t &amp;D)</td></tr>
<tr class="memdesc:a4836227fe01fe94b7c8f376e0c5d47d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in the previous position to the pointed by the iterator  <a href="#a4836227fe01fe94b7c8f376e0c5d47d7">More...</a><br/></td></tr>
<tr class="separator:a4836227fe01fe94b7c8f376e0c5d47d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3654638298857c07c32c354af178245"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#ac3654638298857c07c32c354af178245">insert_if</a> (<a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> iter, const value_t &amp;D, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt; M)</td></tr>
<tr class="memdesc:ac3654638298857c07c32c354af178245"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in the previous position to the pointed by the iterator  <a href="#ac3654638298857c07c32c354af178245">More...</a><br/></td></tr>
<tr class="separator:ac3654638298857c07c32c354af178245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf158fcb2cef65354f7c7d41baf1c3c1"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:acf158fcb2cef65354f7c7d41baf1c3c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#acf158fcb2cef65354f7c7d41baf1c3c1">emplace</a> (<a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> iter, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:acf158fcb2cef65354f7c7d41baf1c3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in the previous position to the pointed by the iterator  <a href="#acf158fcb2cef65354f7c7d41baf1c3c1">More...</a><br/></td></tr>
<tr class="separator:acf158fcb2cef65354f7c7d41baf1c3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ce2b6284bb372b4c4854582cd98abd"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a38ce2b6284bb372b4c4854582cd98abd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a38ce2b6284bb372b4c4854582cd98abd">emplace_if</a> (<a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> iter, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt; M, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a38ce2b6284bb372b4c4854582cd98abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in the previous position to the pointed by the iterator  <a href="#a38ce2b6284bb372b4c4854582cd98abd">More...</a><br/></td></tr>
<tr class="separator:a38ce2b6284bb372b4c4854582cd98abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9180a9d48392f8d324188b3069be5539"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a9180a9d48392f8d324188b3069be5539">insert</a> (<a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> iter, unsigned_type n, const value_t &amp;D)</td></tr>
<tr class="memdesc:a9180a9d48392f8d324188b3069be5539"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert n elements with the value D element in the position specified by an iterator  <a href="#a9180a9d48392f8d324188b3069be5539">More...</a><br/></td></tr>
<tr class="separator:a9180a9d48392f8d324188b3069be5539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36aff656106d6a2693f3ad696bc96bf7"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a36aff656106d6a2693f3ad696bc96bf7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a36aff656106d6a2693f3ad696bc96bf7">insert</a> (<a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> iter, InputIterator A_first, InputIterator A_last)</td></tr>
<tr class="memdesc:a36aff656106d6a2693f3ad696bc96bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a range of lements defined by the pair of iterators A_first, A_last in the position defined by the iterator iter.  <a href="#a36aff656106d6a2693f3ad696bc96bf7">More...</a><br/></td></tr>
<tr class="separator:a36aff656106d6a2693f3ad696bc96bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3239915847575e68208bc6fe9edb1c16"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a3239915847575e68208bc6fe9edb1c16"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a3239915847575e68208bc6fe9edb1c16">insert_if</a> (<a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> iter, InputIterator A_first, InputIterator A_last, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt; M)</td></tr>
<tr class="memdesc:a3239915847575e68208bc6fe9edb1c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a range of lements defined by the pair of iterators A_first, A_last in the position defined by the iterator iter. But insert only the elements which make true the function M  <a href="#a3239915847575e68208bc6fe9edb1c16">More...</a><br/></td></tr>
<tr class="separator:a3239915847575e68208bc6fe9edb1c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e762b6d54e5a3fdfd00b65b0561dde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a12e762b6d54e5a3fdfd00b65b0561dde">pop_front</a> (void)</td></tr>
<tr class="memdesc:a12e762b6d54e5a3fdfd00b65b0561dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the container  <a href="#a12e762b6d54e5a3fdfd00b65b0561dde">More...</a><br/></td></tr>
<tr class="separator:a12e762b6d54e5a3fdfd00b65b0561dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722c4ddacaf01b71e9e9b84539661bf7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a722c4ddacaf01b71e9e9b84539661bf7">pop_front_if</a> (std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt; M1)</td></tr>
<tr class="memdesc:a722c4ddacaf01b71e9e9b84539661bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the container  <a href="#a722c4ddacaf01b71e9e9b84539661bf7">More...</a><br/></td></tr>
<tr class="separator:a722c4ddacaf01b71e9e9b84539661bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848f40ed32e2e4811bf6f4fa79e514ac"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a848f40ed32e2e4811bf6f4fa79e514ac">pop_copy_front</a> (value_t &amp;V)</td></tr>
<tr class="memdesc:a848f40ed32e2e4811bf6f4fa79e514ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the tree and return a copy  <a href="#a848f40ed32e2e4811bf6f4fa79e514ac">More...</a><br/></td></tr>
<tr class="separator:a848f40ed32e2e4811bf6f4fa79e514ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7714d96a48606de6df3e4942d0b5ea1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#ac7714d96a48606de6df3e4942d0b5ea1">pop_copy_front_if</a> (value_t &amp;V, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt; M1)</td></tr>
<tr class="memdesc:ac7714d96a48606de6df3e4942d0b5ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the tree and return a copy  <a href="#ac7714d96a48606de6df3e4942d0b5ea1">More...</a><br/></td></tr>
<tr class="separator:ac7714d96a48606de6df3e4942d0b5ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c948029fb21c4aa0f412041660438cd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a9c948029fb21c4aa0f412041660438cd">pop_move_front</a> (value_t &amp;V)</td></tr>
<tr class="memdesc:a9c948029fb21c4aa0f412041660438cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the tree and return a copy with rvalues  <a href="#a9c948029fb21c4aa0f412041660438cd">More...</a><br/></td></tr>
<tr class="separator:a9c948029fb21c4aa0f412041660438cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d9663d8453a747dae28e2a95e0f922"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a20d9663d8453a747dae28e2a95e0f922">pop_move_front_if</a> (value_t &amp;V, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt; M1)</td></tr>
<tr class="memdesc:a20d9663d8453a747dae28e2a95e0f922"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the tree and return a copy with rvalues  <a href="#a20d9663d8453a747dae28e2a95e0f922">More...</a><br/></td></tr>
<tr class="separator:a20d9663d8453a747dae28e2a95e0f922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0e7ffff475fd1dd217d7b6d7011d77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a3d0e7ffff475fd1dd217d7b6d7011d77">pop_back</a> (void)</td></tr>
<tr class="memdesc:a3d0e7ffff475fd1dd217d7b6d7011d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the container  <a href="#a3d0e7ffff475fd1dd217d7b6d7011d77">More...</a><br/></td></tr>
<tr class="separator:a3d0e7ffff475fd1dd217d7b6d7011d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77338d1277873fae7f160a9d412a9ffb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a77338d1277873fae7f160a9d412a9ffb">pop_back_if</a> (std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt; M1)</td></tr>
<tr class="memdesc:a77338d1277873fae7f160a9d412a9ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the container  <a href="#a77338d1277873fae7f160a9d412a9ffb">More...</a><br/></td></tr>
<tr class="separator:a77338d1277873fae7f160a9d412a9ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc192c22d58d3672538f555e85c27677"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#acc192c22d58d3672538f555e85c27677">pop_copy_back</a> (value_t &amp;V)</td></tr>
<tr class="memdesc:acc192c22d58d3672538f555e85c27677"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the tree and return a copy  <a href="#acc192c22d58d3672538f555e85c27677">More...</a><br/></td></tr>
<tr class="separator:acc192c22d58d3672538f555e85c27677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1286fb1553d296a58aec3a2a3fcf98ba"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a1286fb1553d296a58aec3a2a3fcf98ba">pop_copy_back_if</a> (value_t &amp;V, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt; M1)</td></tr>
<tr class="memdesc:a1286fb1553d296a58aec3a2a3fcf98ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the tree and return a copy  <a href="#a1286fb1553d296a58aec3a2a3fcf98ba">More...</a><br/></td></tr>
<tr class="separator:a1286fb1553d296a58aec3a2a3fcf98ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf0be597d2da20cb13f60452edc561e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#accf0be597d2da20cb13f60452edc561e">pop_move_back</a> (value_t &amp;V)</td></tr>
<tr class="memdesc:accf0be597d2da20cb13f60452edc561e"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the tree and return a copy with rvalues  <a href="#accf0be597d2da20cb13f60452edc561e">More...</a><br/></td></tr>
<tr class="separator:accf0be597d2da20cb13f60452edc561e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0660913e41a01e2e5c6ce9aa3bbb29f1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a0660913e41a01e2e5c6ce9aa3bbb29f1">pop_move_back_if</a> (value_t &amp;V, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt; M1)</td></tr>
<tr class="memdesc:a0660913e41a01e2e5c6ce9aa3bbb29f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the tree and return a copy with rvalues  <a href="#a0660913e41a01e2e5c6ce9aa3bbb29f1">More...</a><br/></td></tr>
<tr class="separator:a0660913e41a01e2e5c6ce9aa3bbb29f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77ceb4ed076de0fc04d97202cac2caf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#ac77ceb4ed076de0fc04d97202cac2caf">erase</a> (<a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> iter)</td></tr>
<tr class="memdesc:ac77ceb4ed076de0fc04d97202cac2caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element pointed by iter  <a href="#ac77ceb4ed076de0fc04d97202cac2caf">More...</a><br/></td></tr>
<tr class="separator:ac77ceb4ed076de0fc04d97202cac2caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea2a17c910aefa17ff3f73f1df5c125"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a0ea2a17c910aefa17ff3f73f1df5c125">erase_if</a> (<a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> iter, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt;(M1))</td></tr>
<tr class="memdesc:a0ea2a17c910aefa17ff3f73f1df5c125"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element pointed by iter if the function return true  <a href="#a0ea2a17c910aefa17ff3f73f1df5c125">More...</a><br/></td></tr>
<tr class="separator:a0ea2a17c910aefa17ff3f73f1df5c125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace99e43aa93880be75facb3bcbaf05f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#ace99e43aa93880be75facb3bcbaf05f7">erase_pos</a> (signed_type Pos)</td></tr>
<tr class="memdesc:ace99e43aa93880be75facb3bcbaf05f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element of the position pos  <a href="#ace99e43aa93880be75facb3bcbaf05f7">More...</a><br/></td></tr>
<tr class="separator:ace99e43aa93880be75facb3bcbaf05f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddea09c57b90f71fcf77f05e6f63499"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a4ddea09c57b90f71fcf77f05e6f63499">erase_pos_if</a> (signed_type Pos, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt; M)</td></tr>
<tr class="memdesc:a4ddea09c57b90f71fcf77f05e6f63499"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element of the position pos  <a href="#a4ddea09c57b90f71fcf77f05e6f63499">More...</a><br/></td></tr>
<tr class="separator:a4ddea09c57b90f71fcf77f05e6f63499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553e33fd6be44e45a85800a6ed148c0c"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a553e33fd6be44e45a85800a6ed148c0c">erase</a> (<a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> first_it, <a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> last_it)</td></tr>
<tr class="memdesc:a553e33fd6be44e45a85800a6ed148c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase a range of elements between first_it and last_it  <a href="#a553e33fd6be44e45a85800a6ed148c0c">More...</a><br/></td></tr>
<tr class="separator:a553e33fd6be44e45a85800a6ed148c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539f9ae449208546218c634fa05f9a8c"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a539f9ae449208546218c634fa05f9a8c">erase_if</a> (<a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> first_it, <a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> last_it, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt; M1)</td></tr>
<tr class="memdesc:a539f9ae449208546218c634fa05f9a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase a range of elements between first_it and last_it  <a href="#a539f9ae449208546218c634fa05f9a8c">More...</a><br/></td></tr>
<tr class="separator:a539f9ae449208546218c634fa05f9a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8dc242c5e9162a0099ecdd49543ddf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a9a8dc242c5e9162a0099ecdd49543ddf">erase_pos</a> (signed_type First, signed_type NElem)</td></tr>
<tr class="memdesc:a9a8dc242c5e9162a0099ecdd49543ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the NElem elements after the position First  <a href="#a9a8dc242c5e9162a0099ecdd49543ddf">More...</a><br/></td></tr>
<tr class="separator:a9a8dc242c5e9162a0099ecdd49543ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9331596f1940de5ef88e3ee07ef08d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#ad9331596f1940de5ef88e3ee07ef08d0">erase_pos_if</a> (signed_type First, signed_type NElem, std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt; M)</td></tr>
<tr class="memdesc:ad9331596f1940de5ef88e3ee07ef08d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the NElem elements after the position First if the function M return true when receives the element as parameter  <a href="#ad9331596f1940de5ef88e3ee07ef08d0">More...</a><br/></td></tr>
<tr class="separator:ad9331596f1940de5ef88e3ee07ef08d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe72de2023c4ba8c686f793eeffa73a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#abe72de2023c4ba8c686f793eeffa73a0">modify</a> (<a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> It, const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;D)</td></tr>
<tr class="memdesc:abe72de2023c4ba8c686f793eeffa73a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign D to the element pointed by It  <a href="#abe72de2023c4ba8c686f793eeffa73a0">More...</a><br/></td></tr>
<tr class="separator:abe72de2023c4ba8c686f793eeffa73a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bd7113108bb0d2a724b851b7333e1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a76bd7113108bb0d2a724b851b7333e1d">modify</a> (<a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> It, <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;&amp;D)</td></tr>
<tr class="memdesc:a76bd7113108bb0d2a724b851b7333e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign D to the element pointed by It  <a href="#a76bd7113108bb0d2a724b851b7333e1d">More...</a><br/></td></tr>
<tr class="separator:a76bd7113108bb0d2a724b851b7333e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b934a524f06df3c5f071258c7b34230"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a6b934a524f06df3c5f071258c7b34230">modify</a> (<a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> It, std::function&lt; void(<a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt; M)</td></tr>
<tr class="memdesc:a6b934a524f06df3c5f071258c7b34230"><td class="mdescLeft">&#160;</td><td class="mdescRight">modify the element pointed by It with a function M  <a href="#a6b934a524f06df3c5f071258c7b34230">More...</a><br/></td></tr>
<tr class="separator:a6b934a524f06df3c5f071258c7b34230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9450defa202f7281531a9d74f98e7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#aae9450defa202f7281531a9d74f98e7b">modify_pos</a> (signed_type Pos, const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;D)</td></tr>
<tr class="memdesc:aae9450defa202f7281531a9d74f98e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign D to the element of the position Pos  <a href="#aae9450defa202f7281531a9d74f98e7b">More...</a><br/></td></tr>
<tr class="separator:aae9450defa202f7281531a9d74f98e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c06816505cafa4b03959ac6dab37a5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a0c06816505cafa4b03959ac6dab37a5f">modify_pos</a> (signed_type Pos, <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;&amp;D)</td></tr>
<tr class="memdesc:a0c06816505cafa4b03959ac6dab37a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign D to the element of the position Pos  <a href="#a0c06816505cafa4b03959ac6dab37a5f">More...</a><br/></td></tr>
<tr class="separator:a0c06816505cafa4b03959ac6dab37a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fbb9309e92bf3be8a9af8dd4941b7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a87fbb9309e92bf3be8a9af8dd4941b7d">modify_pos</a> (signed_type Pos, std::function&lt; void(<a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt; M)</td></tr>
<tr class="memdesc:a87fbb9309e92bf3be8a9af8dd4941b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">modify the element of the position Pos with the function M  <a href="#a87fbb9309e92bf3be8a9af8dd4941b7d">More...</a><br/></td></tr>
<tr class="separator:a87fbb9309e92bf3be8a9af8dd4941b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dafe2d43c54cbb61761b3509bc676c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a5dafe2d43c54cbb61761b3509bc676c9">is_mine</a> (<a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> P1) const </td></tr>
<tr class="memdesc:a5dafe2d43c54cbb61761b3509bc676c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the iterator is pointing to this <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>.  <a href="#a5dafe2d43c54cbb61761b3509bc676c9">More...</a><br/></td></tr>
<tr class="separator:a5dafe2d43c54cbb61761b3509bc676c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cf78fe631c8a850ceff7c6602e516f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a31cf78fe631c8a850ceff7c6602e516f">is_mine</a> (<a class="el" href="classcountertree_1_1cntree__vector.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a> P1) const </td></tr>
<tr class="memdesc:a31cf78fe631c8a850ceff7c6602e516f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the iterator is pointing to this <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>.  <a href="#a31cf78fe631c8a850ceff7c6602e516f">More...</a><br/></td></tr>
<tr class="separator:a31cf78fe631c8a850ceff7c6602e516f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d7ffb109841406412ddb587cb11e48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a92d7ffb109841406412ddb587cb11e48">iterator_pos</a> (signed_type Pos1)</td></tr>
<tr class="memdesc:a92d7ffb109841406412ddb587cb11e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a position in the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>.  <a href="#a92d7ffb109841406412ddb587cb11e48">More...</a><br/></td></tr>
<tr class="separator:a92d7ffb109841406412ddb587cb11e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31b98694ed8525f90cb4deb8b98957d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#ab31b98694ed8525f90cb4deb8b98957d">const_iterator_pos</a> (signed_type Pos1) const </td></tr>
<tr class="memdesc:ab31b98694ed8525f90cb4deb8b98957d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a position in the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>.  <a href="#ab31b98694ed8525f90cb4deb8b98957d">More...</a><br/></td></tr>
<tr class="separator:ab31b98694ed8525f90cb4deb8b98957d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31b3e45d90b7a96bbd7a9c320f5ea1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#aa31b3e45d90b7a96bbd7a9c320f5ea1b">it_begin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aa31b3e45d90b7a96bbd7a9c320f5ea1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4b6e31674152b9cb651a9dedd96ded"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a4d4b6e31674152b9cb651a9dedd96ded">begin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a4d4b6e31674152b9cb651a9dedd96ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bd0195e0f7fa434e8f1240f2886f2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#af1bd0195e0f7fa434e8f1240f2886f2d">it_end</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:af1bd0195e0f7fa434e8f1240f2886f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca25490ad91ef590a20ecc1feeaf5d1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#aca25490ad91ef590a20ecc1feeaf5d1b">end</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aca25490ad91ef590a20ecc1feeaf5d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56c18a3c1d2a1ea9ccda3d787b299bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#aa56c18a3c1d2a1ea9ccda3d787b299bb">it_rbegin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aa56c18a3c1d2a1ea9ccda3d787b299bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeace62194fd6dceb1eb9a7e74ab4d585"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#aeace62194fd6dceb1eb9a7e74ab4d585">it_rend</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aeace62194fd6dceb1eb9a7e74ab4d585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d66de8d33541dd0bc004e26d1603048"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a4d66de8d33541dd0bc004e26d1603048">cit_begin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a4d66de8d33541dd0bc004e26d1603048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7537430437e3583341d559bbed347d28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a7537430437e3583341d559bbed347d28">begin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a7537430437e3583341d559bbed347d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7a976297f187d1c362e3ffadfa02a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#aca7a976297f187d1c362e3ffadfa02a9">cbegin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aca7a976297f187d1c362e3ffadfa02a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed021874a605ccbdad59b75bd0338e00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#aed021874a605ccbdad59b75bd0338e00">cit_end</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aed021874a605ccbdad59b75bd0338e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9288d9389d1bdd2cc8695253de7cf545"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a9288d9389d1bdd2cc8695253de7cf545">end</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a9288d9389d1bdd2cc8695253de7cf545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba145affac65da63ef632a3e4b3d2ab8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#aba145affac65da63ef632a3e4b3d2ab8">cend</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aba145affac65da63ef632a3e4b3d2ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7280b6a156afd2c913adc442ea4bf96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#aa7280b6a156afd2c913adc442ea4bf96">cit_rbegin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aa7280b6a156afd2c913adc442ea4bf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448209fbdd7f9bc800fccdbcef156828"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a448209fbdd7f9bc800fccdbcef156828">cit_rend</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a448209fbdd7f9bc800fccdbcef156828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78b1ce43f0c85bceda1d91902863166"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#af78b1ce43f0c85bceda1d91902863166">rit_begin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:af78b1ce43f0c85bceda1d91902863166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b381c905e49bd704dab3bc32f3442d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a9b381c905e49bd704dab3bc32f3442d3">rit_end</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a9b381c905e49bd704dab3bc32f3442d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc23d344971d36d528707a9e0a6af17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#affc23d344971d36d528707a9e0a6af17">rit_rbegin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:affc23d344971d36d528707a9e0a6af17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89ea00525332c83fcc5a7139f17557e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#af89ea00525332c83fcc5a7139f17557e">rbegin</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:af89ea00525332c83fcc5a7139f17557e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5680c212c840c8841989dbe07b1a48ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a5680c212c840c8841989dbe07b1a48ee">rit_rend</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a5680c212c840c8841989dbe07b1a48ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b59a192483536c9dbbec54e608548d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a9b59a192483536c9dbbec54e608548d5">rend</a> (void) <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a9b59a192483536c9dbbec54e608548d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc568bbd22027687f7033f0ee20f6538"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#adc568bbd22027687f7033f0ee20f6538">crit_begin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:adc568bbd22027687f7033f0ee20f6538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b52753fa26fe35c0cea9f3c82aa76d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a6b52753fa26fe35c0cea9f3c82aa76d6">crit_end</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a6b52753fa26fe35c0cea9f3c82aa76d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d3200e06a8e1f80a1b5b1b9b1001e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#ac1d3200e06a8e1f80a1b5b1b9b1001e2">crit_rbegin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ac1d3200e06a8e1f80a1b5b1b9b1001e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376df61f6285b5f2b5ad9d9161038b4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a376df61f6285b5f2b5ad9d9161038b4b">rbegin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a376df61f6285b5f2b5ad9d9161038b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1e48e0ea2638eec6b6484c95b72eb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#abc1e48e0ea2638eec6b6484c95b72eb6">crbegin</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:abc1e48e0ea2638eec6b6484c95b72eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d3643852ac5c502852a80655710981"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#ab6d3643852ac5c502852a80655710981">crit_rend</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ab6d3643852ac5c502852a80655710981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5f9653fa7c0eacbf21a40c44922e1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a5e5f9653fa7c0eacbf21a40c44922e1c">rend</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a5e5f9653fa7c0eacbf21a40c44922e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad210f0ec4ff240fddbfca2b3cbef3841"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#ad210f0ec4ff240fddbfca2b3cbef3841">crend</a> (void) const <a class="el" href="definitions_8hpp.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ad210f0ec4ff240fddbfca2b3cbef3841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2ab2c5cf22418bb0a5fe2fa2f5b1c1"><td class="memItemLeft" align="right" valign="top">alloc_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#ade2ab2c5cf22418bb0a5fe2fa2f5b1c1">get_allocator</a> () const </td></tr>
<tr class="memdesc:ade2ab2c5cf22418bb0a5fe2fa2f5b1c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the object allocator of the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>  <a href="#ade2ab2c5cf22418bb0a5fe2fa2f5b1c1">More...</a><br/></td></tr>
<tr class="separator:ade2ab2c5cf22418bb0a5fe2fa2f5b1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a2602a76e3b8fbbfea79182769243c922"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#a62f8be059bc86f9ccc8f3efd80a8163b">barrier_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a2602a76e3b8fbbfea79182769243c922">BD</a></td></tr>
<tr class="separator:a2602a76e3b8fbbfea79182769243c922"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a439da6f9eefc2ca2267d20db7bc08d2e"><td class="memItemLeft" align="right" valign="top">alloc_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a439da6f9eefc2ca2267d20db7bc08d2e">value_alloc</a></td></tr>
<tr class="separator:a439da6f9eefc2ca2267d20db7bc08d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c395854fb54d4b307488590e0f4e60d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#adc0f814170aa1d0ab669794e311f638b">node_alloc_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a2c395854fb54d4b307488590e0f4e60d">node_alloc</a></td></tr>
<tr class="separator:a2c395854fb54d4b307488590e0f4e60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1704766d3e53c5b8fc77286ad0c6525b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcountertree_1_1cntree__vector.html#a43753d3c0e064cc6d601496645811657">tree_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a1704766d3e53c5b8fc77286ad0c6525b">T</a></td></tr>
<tr class="separator:a1704766d3e53c5b8fc77286ad0c6525b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a5d141ff25b2b38d29d8e6b76e1d5108e"><td class="memTemplParams" colspan="2">template&lt;class value_t2 , bool cnc2, class alloc_t2 &gt; </td></tr>
<tr class="memitem:a5d141ff25b2b38d29d8e6b76e1d5108e"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcountertree_1_1cntree__vector.html#a5d141ff25b2b38d29d8e6b76e1d5108e">cntree_vector</a></td></tr>
<tr class="separator:a5d141ff25b2b38d29d8e6b76e1d5108e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt;<br/>
class countertree::cntree_vector&lt; value_t, cnc, alloc_t &gt;</h3>

<p>This class have the same interface than the STL vector, but istead of be a vector is a tree. <br/>
 Due to this all the operations ( insert, delete, access) a O( logN). <br/>
. </p>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00051">51</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ad0a9f2752a974795fba5d7ae1cad3695"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef alloc_t <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html#ad0a9f2752a974795fba5d7ae1cad3695">allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00072">72</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a62f8be059bc86f9ccc8f3efd80a8163b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcountertree_1_1config__barrier.html">config_barrier</a>&lt;cnc&gt;::<a class="el" href="classcountertree_1_1cntree__vector.html#a62f8be059bc86f9ccc8f3efd80a8163b">barrier_data</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html#a62f8be059bc86f9ccc8f3efd80a8163b">barrier_data</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00057">57</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9e448b604750c070e9d6a60885ecc630"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcountertree_1_1config__barrier.html">config_barrier</a>&lt;cnc&gt;::<a class="el" href="classcountertree_1_1cntree__vector.html#a9e448b604750c070e9d6a60885ecc630">barrier_modify</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html#a9e448b604750c070e9d6a60885ecc630">barrier_modify</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00059">59</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae4d6538bd64e1e32bdeb295ddec0d781"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcountertree_1_1config__barrier.html">config_barrier</a>&lt;cnc&gt;::<a class="el" href="classcountertree_1_1cntree__vector.html#ae4d6538bd64e1e32bdeb295ddec0d781">barrier_read</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html#ae4d6538bd64e1e32bdeb295ddec0d781">barrier_read</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00058">58</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abcb62c282670d63c6ae02c0d9b6c096b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#aaf68addaf301fecce33fc7c2a82987d5">tree_t::const_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00075">75</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7d5f52cde3f23c059262c35b8dd529c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a>* <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html#a7d5f52cde3f23c059262c35b8dd529c4">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00069">69</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7707089005acdf518d94759af5176b40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a>&amp; <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html#a7707089005acdf518d94759af5176b40">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00071">71</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a43bd4af0141eb3ccd69c9385f94f3e0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#afb8570b4b8f3076f34067fa4ec34afca">tree_t::const_reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00077">77</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1206c13bbfb20d762a1b3e28662e784e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#ac4899fc42db7c3418d99a86118933342">tree_t::difference_type</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html#a1206c13bbfb20d762a1b3e28662e784e">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00066">66</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad7de56907efcce713cbd358c14b5906c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#a752155609649dc94fe17ae0239376f04">tree_t::iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00074">74</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a225e342728d3e2d927f54aa78728f883"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt; <a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>, bool&gt; <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html#a225e342728d3e2d927f54aa78728f883">mypair</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00078">78</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adc0f814170aa1d0ab669794e311f638b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef alloc_t::template rebind&lt;<a class="el" href="classcountertree_1_1cntree__vector.html#a4defa8ea643d60d28ab7e0b32aa7a37f">node_t</a>&gt;::other <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html#adc0f814170aa1d0ab669794e311f638b">node_alloc_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00062">62</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4defa8ea643d60d28ab7e0b32aa7a37f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcountertree_1_1forest_1_1node.html">countertree::forest::node</a>&lt;value_t&gt; <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html#a4defa8ea643d60d28ab7e0b32aa7a37f">node_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00061">61</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a38e3cfb56871236abfb5dceb841797b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a>* <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html#a38e3cfb56871236abfb5dceb841797b0">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00068">68</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a75e5b16f508fded9604f1708112c75b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a>&amp; <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html#a75e5b16f508fded9604f1708112c75b5">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00070">70</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7be73be0ae348fa005c4e399186d91ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#a9cc1af3e272082d169789594bdcd0114">tree_t::reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00076">76</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a76cf48091959d644080dfdfb462998c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html#af62e7d9749b95b2cfe4aa45a1ba09d3a">tree_t::size_type</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html#a76cf48091959d644080dfdfb462998c2">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00065">65</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a43753d3c0e064cc6d601496645811657"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcountertree_1_1forest_1_1tree.html">c_forest::tree</a>&lt;value_t, <a class="el" href="classcountertree_1_1cntree__vector.html#adc0f814170aa1d0ab669794e311f638b">node_alloc_t</a>&gt; <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html#a43753d3c0e064cc6d601496645811657">tree_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00063">63</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a87cf343c3367539a136887208feeee1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef value_t <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00067">67</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a344c20c31fd347cf4ed4f16ab0d438fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const alloc_t &amp;&#160;</td>
          <td class="paramname"><em>ALLC</em> = <code>alloc_t&#160;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from an object Allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>: Allocator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00138">138</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a594872e2afc204197d7660571659c2dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a>&lt; value_t, cnc, alloc_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>VT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VT</td><td>: <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00145">145</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad81e0fdbc22bb24af7aa0f84e899c97a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a>&lt; value_t, cnc, alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>VT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VT</td><td>: <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00155">155</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aba70b9a3a7162c384dd3bdf2b0f6913f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename alloc_t2  = alloc_t, bool cnc2 = cnc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a>&lt; value_t, cnc2, alloc_t2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>VT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asignation operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>: <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> after the copy </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00164">164</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac8675fd4c7e9a6631c1b881dfdad894b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;bool cnc2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a>&lt; value_t, cnc2, alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>VT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VT</td><td>: <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00175">175</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acb9632c5c54d53f81381d6e3668c533a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>Val</em> = <code>value_t()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const alloc_t &amp;&#160;</td>
          <td class="paramname"><em>A</em> = <code>alloc_t()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from a value repeated a number of times and an object Allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: Number of repetitions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Val</td><td>: Value to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>: Allocator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00186">186</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa1190b582c791f6e9c09301608ff3aac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const alloc_t &amp;&#160;</td>
          <td class="paramname"><em>A</em> = <code>alloc_t()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from a pair of iterators and an object Allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>: iterator to the first element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>: iterator to the last element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A1</td><td>: Allocator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00201">201</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af145677a55604df5465cfbaba5e3dba4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::~<a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00211">211</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae271710d82d3a0165821169863316945"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a range of data, dropping all the elements of the container It's like the assignation operator but with several parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">it_first</td><td>: iterator to the first element to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">it_last</td><td>: Iterator to the end of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00301">301</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a42638c1a9c3da5539fe5b488d09ad6f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">unsigned_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a range of data, dropping all the elements of the container It's like the assignation operator but with several parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: number of elements to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00315">315</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a133cc49537ff0ab05a4d4dd40cbd5999"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::assign_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a range of data, dropping all the elements of the container It's like the assignation operator but with several parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">it_first</td><td>: iterator to the first element to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">it_last</td><td>: Iterator to the end of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function which receives an element and when return true the lement is inserted and when false , not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00332">332</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a430b67855e0b0796d8086d7138c50414"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_t&amp; <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::at </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checked access to an element by their position in the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the object selected </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (log(N)) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00471">471</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3e240e500a80d4396f7503ca9268fb8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t&amp; <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::at </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checked access to an element by their position in the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the object selected </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (log(N)) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00482">482</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6267e7911794d81f93dd9c2d1c3c7e69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_t&amp; <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the last element in the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the last element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00537">537</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3f097cc0a4cd7632ccd18e3b3f7ff924"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t&amp; <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const_reference to the last element in the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the last element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00548">548</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d4b6e31674152b9cb651a9dedd96ded"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01485">1485</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7537430437e3583341d559bbed347d28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01546">1546</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad9d3c4a6ad67cd69128d8f9e1c948b19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::capacity </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the maximun size of the container </p>
<dl class="section return"><dt>Returns</dt><dd>maximun size of the container </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00415">415</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca7a976297f187d1c362e3ffadfa02a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01553">1553</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aba145affac65da63ef632a3e4b3d2ab8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::cend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01575">1575</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d66de8d33541dd0bc004e26d1603048"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::cit_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01538">1538</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed021874a605ccbdad59b75bd0338e00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::cit_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01560">1560</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa7280b6a156afd2c913adc442ea4bf96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::cit_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01582">1582</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a448209fbdd7f9bc800fccdbcef156828"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::cit_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01590">1590</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afeeba4da0cb6bd0e93e170f23d31d6ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete all the elements of the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00345">345</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab31b98694ed8525f90cb4deb8b98957d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::const_iterator_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos1</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a position in the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the position. If don't exists throws an exception </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log N) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01458">1458</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc1e48e0ea2638eec6b6484c95b72eb6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::crbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01703">1703</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad210f0ec4ff240fddbfca2b3cbef3841"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::crend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01725">1725</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adc568bbd22027687f7033f0ee20f6538"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::crit_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01672">1672</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b52753fa26fe35c0cea9f3c82aa76d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::crit_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01680">1680</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac1d3200e06a8e1f80a1b5b1b9b1001e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::crit_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01688">1688</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab6d3643852ac5c502852a80655710981"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::crit_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01710">1710</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acf158fcb2cef65354f7c7d41baf1c3c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in the previous position to the pointed by the iterator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: Itera which indicates the position to insert the value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the iterator is <a class="el" href="classcountertree_1_1cntree__vector.html#a9b59a192483536c9dbbec54e608548d5">rend()</a> there is an error because we can't insert before it </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00787">787</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5d926610131daae834ac3d18ded02cae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert one element in the back of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00674">674</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a043faa007319c6cf9428f364a7d63514"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::emplace_back_if </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert one element in the back of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00686">686</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9be15443e2ba2c9d6666ab991b2a67bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::emplace_front </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in the front of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00626">626</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2a763a9a500148bd32f568c8fdae0e57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::emplace_front_if </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in the front of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00639">639</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a38ce2b6284bb372b4c4854582cd98abd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::emplace_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in the previous position to the pointed by the iterator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: Itera which indicates the position to insert the value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the iterator is <a class="el" href="classcountertree_1_1cntree__vector.html#a9b59a192483536c9dbbec54e608548d5">rend()</a> there is an error because we can't insert before it </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00806">806</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5d7d34c3f93974224d263f663a9af05a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::emplace_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in a specified position </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to insert the value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00725">725</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af974ab4ec3222e7c0c8e0c2525bd46a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::emplace_pos_if </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in a specified position </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to insert the value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00740">740</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab05fa08d8156b2cf1be54148874731b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>indicate if the map is empty </p>
<dl class="section return"><dt>Returns</dt><dd>true if the map is empty, false in any other case </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00424">424</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca25490ad91ef590a20ecc1feeaf5d1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01500">1500</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9288d9389d1bdd2cc8695253de7cf545"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01568">1568</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac77ceb4ed076de0fc04d97202cac2caf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element pointed by iter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>: iterator to the element to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01159">1159</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a553e33fd6be44e45a85800a6ed148c0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase a range of elements between first_it and last_it </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first_it</td><td>: iterator to the first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last_it</td><td>: iterator to the final element of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements erased </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01227">1227</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0ea2a17c910aefa17ff3f73f1df5c125"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; &#160;</td>
          <td class="paramname"><em>bool</em>const value_type &amp;)&gt;(M1&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element pointed by iter if the function return true </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>: iterator to the element to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01171">1171</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a539f9ae449208546218c634fa05f9a8c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase a range of elements between first_it and last_it </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first_it</td><td>: iterator to the first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last_it</td><td>: iterator to the final element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M1</td><td>: function for to select the elements to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements erased </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01242">1242</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ace99e43aa93880be75facb3bcbaf05f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::erase_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element of the position pos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>: position to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01188">1188</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9a8dc242c5e9162a0099ecdd49543ddf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::erase_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>First</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>NElem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the NElem elements after the position First </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">First</td><td>: position to the first element to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NElem</td><td>: number of elements to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01256">1256</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4ddea09c57b90f71fcf77f05e6f63499"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::erase_pos_if </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element of the position pos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>: position to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true -&gt;deleted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01205">1205</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad9331596f1940de5ef88e3ee07ef08d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::erase_pos_if </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>First</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>NElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the NElem elements after the position First if the function M return true when receives the element as parameter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">First</td><td>: position to the first element to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NElem</td><td>: number of elements to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function for to evaluate the element to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01272">1272</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1a023d059f84ec5f2798381208458708"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_t&amp; <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the first element in the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the first element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00515">515</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a21565c8b856507c247539f6ae95c00a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t&amp; <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const_reference to the first element in the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the first element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00526">526</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ade2ab2c5cf22418bb0a5fe2fa2f5b1c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">alloc_t <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the object allocator of the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>object allocator </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01744">1744</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4836227fe01fe94b7c8f376e0c5d47d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in the previous position to the pointed by the iterator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: Itera which indicates the position to insert the value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the iterator is <a class="el" href="classcountertree_1_1cntree__vector.html#a9b59a192483536c9dbbec54e608548d5">rend()</a> there is an error because we can't insert before it </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00758">758</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9180a9d48392f8d324188b3069be5539"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert n elements with the value D element in the position specified by an iterator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>: Iterator which indicates the position to insert the value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: Number of elements to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the iterator is <a class="el" href="classcountertree_1_1cntree__vector.html#a9b59a192483536c9dbbec54e608548d5">rend()</a> there is an error because we can't insert before it </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00828">828</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a36aff656106d6a2693f3ad696bc96bf7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>A_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>A_last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a range of lements defined by the pair of iterators A_first, A_last in the position defined by the iterator iter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>: Iterator which indicates the position to insert the value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_first</td><td>: InputIterator to thje first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_last</td><td>: InputIterator to the next element of the last </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the iterator is <a class="el" href="classcountertree_1_1cntree__vector.html#a9b59a192483536c9dbbec54e608548d5">rend()</a> there is an error because we can't insert before it </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00848">848</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac3654638298857c07c32c354af178245"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::insert_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in the previous position to the pointed by the iterator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: Itera which indicates the position to insert the value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the iterator is <a class="el" href="classcountertree_1_1cntree__vector.html#a9b59a192483536c9dbbec54e608548d5">rend()</a> there is an error because we can't insert before it </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00771">771</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3239915847575e68208bc6fe9edb1c16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::insert_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>A_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>A_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a range of lements defined by the pair of iterators A_first, A_last in the position defined by the iterator iter. But insert only the elements which make true the function M </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>: Iterator which indicates the position to insert the value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_first</td><td>: InputIterator to thje first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_last</td><td>: InputIterator to the next element of the last </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function which select the elements to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the iterator is <a class="el" href="classcountertree_1_1cntree__vector.html#a9b59a192483536c9dbbec54e608548d5">rend()</a> there is an error because we can't insert before it </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00870">870</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a04b40dd87eb147780cb53043bc4789a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::insert_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in a specified position </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to insert the value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00699">699</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7742e1cce4e7d058e242fd49f6da895c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::insert_pos_if </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in a specified position </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to insert the value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00711">711</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5dafe2d43c54cbb61761b3509bc676c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::is_mine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__vector.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>P1</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the iterator is pointing to this <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: iterator to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(true/false ) Indicate if it is pointing to this <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01424">1424</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a31cf78fe631c8a850ceff7c6602e516f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::is_mine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__vector.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a>&#160;</td>
          <td class="paramname"><em>P1</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the iterator is pointing to this <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: iterator to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(true/false ) Indicate if it is pointing to this <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01435">1435</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa31b3e45d90b7a96bbd7a9c320f5ea1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::it_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01477">1477</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af1bd0195e0f7fa434e8f1240f2886f2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::it_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01492">1492</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa56c18a3c1d2a1ea9ccda3d787b299bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::it_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01507">1507</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeace62194fd6dceb1eb9a7e74ab4d585"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::it_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01515">1515</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a92d7ffb109841406412ddb587cb11e48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::iterator_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a position in the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the position. If don't exists throw an exception </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log N) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01446">1446</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a13ce0a0cb03c86dc51c655fab20eaa9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::max_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the maximun size of the container </p>
<dl class="section return"><dt>Returns</dt><dd>maximun size of the container </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00391">391</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abe72de2023c4ba8c686f793eeffa73a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::modify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td>
          <td class="paramname"><em>It</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>assign D to the element pointed by It </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">It</td><td>: iterator to the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: new value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01311">1311</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a76bd7113108bb0d2a724b851b7333e1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::modify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td>
          <td class="paramname"><em>It</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>assign D to the element pointed by It </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">It</td><td>: iterator to the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: new value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01326">1326</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b934a524f06df3c5f071258c7b34230"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::modify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td>
          <td class="paramname"><em>It</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>modify the element pointed by It with a function M </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">It</td><td>; iterator to the element to modify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function to modify the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01341">1341</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aae9450defa202f7281531a9d74f98e7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::modify_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>assign D to the element of the position Pos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: position to modify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: new value to assign </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01356">1356</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0c06816505cafa4b03959ac6dab37a5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::modify_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>assign D to the element of the position Pos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: position to modify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: new value to assign </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01371">1371</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a87fbb9309e92bf3be8a9af8dd4941b7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::modify_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>modify the element of the position Pos with the function M </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: position to modify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function to modify the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01386">1386</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a106653ec27cdda561bd86fb08ccfcf03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a>&amp; <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a>&lt; value_t, cnc, alloc_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>VT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asignation operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>: <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> after the copy </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00249">249</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab1bf41521b42e053728c32d649e584c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename alloc_t2 , bool cnc2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a>&amp; <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a>&lt; value_t, cnc2, alloc_t2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>VT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asignation operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>: <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> after the copy </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00265">265</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac2164589da63a2f4cb2c1416eec65436"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;bool cnc2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a>&amp; <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a>&lt; value_t, cnc2, alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asignation operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>: <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> after the copy </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00281">281</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a11f89089e07505024f6216bbb7fd5c3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_t&amp; <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checked access to an element by their position in the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the object selected </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (log(N)) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00493">493</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af04a32ab965d08a6d028fe515d5f4b3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t&amp; <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checked access to an element by their position in the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the object selected </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(log(N)) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00504">504</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3d0e7ffff475fd1dd217d7b6d7011d77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::pop_back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01047">1047</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a77338d1277873fae7f160a9d412a9ffb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::pop_back_if </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M1</td><td>: function to check the value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree 2 - Function returns false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01062">1062</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acc192c22d58d3672538f555e85c27677"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::pop_copy_back </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the tree and return a copy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01081">1081</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1286fb1553d296a58aec3a2a3fcf98ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::pop_copy_back_if </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the tree and return a copy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree 2 - Function returns false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01101">1101</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a848f40ed32e2e4811bf6f4fa79e514ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::pop_copy_front </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the tree and return a copy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00967">967</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac7714d96a48606de6df3e4942d0b5ea1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::pop_copy_front_if </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the tree and return a copy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree 2 - Function returns false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00987">987</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a12e762b6d54e5a3fdfd00b65b0561dde"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::pop_front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (constant) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00932">932</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a722c4ddacaf01b71e9e9b84539661bf7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::pop_front_if </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree 2 - Function returns false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (constant) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00947">947</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="accf0be597d2da20cb13f60452edc561e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::pop_move_back </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the tree and return a copy with rvalues </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01122">1122</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0660913e41a01e2e5c6ce9aa3bbb29f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::pop_move_back_if </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the tree and return a copy with rvalues </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01141">1141</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9c948029fb21c4aa0f412041660438cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::pop_move_front </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the tree and return a copy with rvalues </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01008">1008</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a20d9663d8453a747dae28e2a95e0f922"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::pop_move_front_if </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the tree and return a copy with rvalues </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01027">1027</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aadcb8871f9f617e12e862680a24989d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert one element in the back of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00652">652</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a19888249e6317faa8d83dc6406131ecb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::push_back_if </td>
          <td>(</td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert one element in the back of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00662">662</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9c32244e91820d940c9be0fd8884b435"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in the front of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00604">604</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4fd94db19d1b7f476aba9e3e0c935e02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::push_front_if </td>
          <td>(</td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classcountertree_1_1cntree__vector.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in the front of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00614">614</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af89ea00525332c83fcc5a7139f17557e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01635">1635</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a376df61f6285b5f2b5ad9d9161038b4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01696">1696</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9b59a192483536c9dbbec54e608548d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01650">1650</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5e5f9653fa7c0eacbf21a40c44922e1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01718">1718</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a154c3aadf8e287cd2f35cf8721846857"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the capacity for to contain , at least n elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: number of elements for the new capacity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function has not utility. It is provided only for compatibility with the STL vector interface </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00436">436</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0399fba189f3010653664f2a07ba387f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_t&#160;</td>
          <td class="paramname"><em>c</em> = <code>value_t()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>resize the current vector size and change to sz.<br/>
 If sz is smaller than the current size, delete elements to end<br/>
 If sz is greater than the current size, insert elements to the end with the value c </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>: new size of the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> after the resize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>: Value to insert if sz is greather than the current size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00405">405</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af78b1ce43f0c85bceda1d91902863166"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::rit_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01611">1611</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9b381c905e49bd704dab3bc32f3442d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::rit_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01619">1619</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="affc23d344971d36d528707a9e0a6af17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::rit_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01627">1627</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5680c212c840c8841989dbe07b1a48ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::rit_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l01642">1642</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a938c8e7b8066ef4e3907c256f953f098"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the number of elements in the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> </p>
<dl class="section return"><dt>Returns</dt><dd>number of elements in the <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00382">382</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afbb8161d8d8e5a3e5a31c358fa565bfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a>&lt; value_t, cnc, alloc_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>swap the data between the two <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>: <a class="el" href="classcountertree_1_1cntree__vector.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> to swap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00356">356</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a5d141ff25b2b38d29d8e6b76e1d5108e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class value_t2 , bool cnc2, class alloc_t2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00093">93</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a2602a76e3b8fbbfea79182769243c922"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#a62f8be059bc86f9ccc8f3efd80a8163b">barrier_data</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::BD</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00092">92</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2c395854fb54d4b307488590e0f4e60d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#adc0f814170aa1d0ab669794e311f638b">node_alloc_t</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::node_alloc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00085">85</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1704766d3e53c5b8fc77286ad0c6525b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcountertree_1_1cntree__vector.html#a43753d3c0e064cc6d601496645811657">tree_t</a> <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::T</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00086">86</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a439da6f9eefc2ca2267d20db7bc08d2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">alloc_t <a class="el" href="classcountertree_1_1cntree__vector.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::value_alloc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cntree__vector_8hpp_source.html#l00084">84</a> of file <a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="cntree__vector_8hpp_source.html">cntree_vector.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecountertree.html">countertree</a></li><li class="navelem"><a class="el" href="classcountertree_1_1cntree__vector.html">cntree_vector</a></li>
    <li class="footer">Generated on Tue Jul 30 2013 18:10:27 for Countertree by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
