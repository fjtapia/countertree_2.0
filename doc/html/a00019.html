<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>[ countertree + suballocator ]: countertree::cntree_vector&lt; value_t, cnc, alloc_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">[ countertree + suballocator ]
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00019.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="a00156.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">countertree::cntree_vector&lt; value_t, cnc, alloc_t &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class have the same interface than the STL vector, but istead of be a vector is a tree. <br/>
 Due to this all the operations ( insert, delete, access) a O( logN). <br/>
.  
 <a href="a00019.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00114_source.html">cntree_vector.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7df32d590dc511949720cfa75f878018"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00023.html">config_fastmutex</a>&lt; cnc &gt;<br class="typebreak"/>
::fastmutex_data&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a7df32d590dc511949720cfa75f878018">mtx_data</a></td></tr>
<tr class="separator:a7df32d590dc511949720cfa75f878018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57eb20355ea7a0d1070446429100d7d8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00051.html">mutex_read</a>&lt; <a class="el" href="a00019.html#a7df32d590dc511949720cfa75f878018">mtx_data</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a57eb20355ea7a0d1070446429100d7d8">mtx_read</a></td></tr>
<tr class="separator:a57eb20355ea7a0d1070446429100d7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f58e9b32cfb6fd6d7b037664ef7a27e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00053.html">mutex_write</a>&lt; <a class="el" href="a00019.html#a7df32d590dc511949720cfa75f878018">mtx_data</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a6f58e9b32cfb6fd6d7b037664ef7a27e">mtx_write</a></td></tr>
<tr class="separator:a6f58e9b32cfb6fd6d7b037664ef7a27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4defa8ea643d60d28ab7e0b32aa7a37f"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="a00065.html">countertree::forest::node</a><br class="typebreak"/>
&lt; value_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a4defa8ea643d60d28ab7e0b32aa7a37f">node_t</a></td></tr>
<tr class="separator:a4defa8ea643d60d28ab7e0b32aa7a37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0f814170aa1d0ab669794e311f638b"><td class="memItemLeft" align="right" valign="top">typedef alloc_t::template <br class="typebreak"/>
rebind&lt; <a class="el" href="a00019.html#a4defa8ea643d60d28ab7e0b32aa7a37f">node_t</a> &gt;::other&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#adc0f814170aa1d0ab669794e311f638b">node_alloc_t</a></td></tr>
<tr class="separator:adc0f814170aa1d0ab669794e311f638b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43753d3c0e064cc6d601496645811657"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00103.html">c_forest::tree</a><br class="typebreak"/>
&lt; value_t, <a class="el" href="a00019.html#adc0f814170aa1d0ab669794e311f638b">node_alloc_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a43753d3c0e064cc6d601496645811657">tree_t</a></td></tr>
<tr class="separator:a43753d3c0e064cc6d601496645811657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cf48091959d644080dfdfb462998c2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00103.html#af62e7d9749b95b2cfe4aa45a1ba09d3a">tree_t::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a76cf48091959d644080dfdfb462998c2">size_type</a></td></tr>
<tr class="separator:a76cf48091959d644080dfdfb462998c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1206c13bbfb20d762a1b3e28662e784e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00103.html#ac4899fc42db7c3418d99a86118933342">tree_t::difference_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a1206c13bbfb20d762a1b3e28662e784e">difference_type</a></td></tr>
<tr class="separator:a1206c13bbfb20d762a1b3e28662e784e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87cf343c3367539a136887208feeee1d"><td class="memItemLeft" align="right" valign="top">typedef value_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a87cf343c3367539a136887208feeee1d">value_type</a></td></tr>
<tr class="separator:a87cf343c3367539a136887208feeee1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e3cfb56871236abfb5dceb841797b0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00019.html#a87cf343c3367539a136887208feeee1d">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a38e3cfb56871236abfb5dceb841797b0">pointer</a></td></tr>
<tr class="separator:a38e3cfb56871236abfb5dceb841797b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5f52cde3f23c059262c35b8dd529c4"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="a00019.html#a87cf343c3367539a136887208feeee1d">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a7d5f52cde3f23c059262c35b8dd529c4">const_pointer</a></td></tr>
<tr class="separator:a7d5f52cde3f23c059262c35b8dd529c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e5b16f508fded9604f1708112c75b5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00019.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a75e5b16f508fded9604f1708112c75b5">reference</a></td></tr>
<tr class="separator:a75e5b16f508fded9604f1708112c75b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7707089005acdf518d94759af5176b40"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="a00019.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a7707089005acdf518d94759af5176b40">const_reference</a></td></tr>
<tr class="separator:a7707089005acdf518d94759af5176b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a9f2752a974795fba5d7ae1cad3695"><td class="memItemLeft" align="right" valign="top">typedef alloc_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ad0a9f2752a974795fba5d7ae1cad3695">allocator_type</a></td></tr>
<tr class="separator:ad0a9f2752a974795fba5d7ae1cad3695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7de56907efcce713cbd358c14b5906c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00103.html#a752155609649dc94fe17ae0239376f04">tree_t::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a></td></tr>
<tr class="separator:ad7de56907efcce713cbd358c14b5906c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb62c282670d63c6ae02c0d9b6c096b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00103.html#aaf68addaf301fecce33fc7c2a82987d5">tree_t::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a></td></tr>
<tr class="separator:abcb62c282670d63c6ae02c0d9b6c096b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be73be0ae348fa005c4e399186d91ff"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00103.html#a9cc1af3e272082d169789594bdcd0114">tree_t::reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a></td></tr>
<tr class="separator:a7be73be0ae348fa005c4e399186d91ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bd4af0141eb3ccd69c9385f94f3e0f"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="a00103.html#afb8570b4b8f3076f34067fa4ec34afca">tree_t::const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a></td></tr>
<tr class="separator:a43bd4af0141eb3ccd69c9385f94f3e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225e342728d3e2d927f54aa78728f883"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; <a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a225e342728d3e2d927f54aa78728f883">mypair</a></td></tr>
<tr class="separator:a225e342728d3e2d927f54aa78728f883"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a344c20c31fd347cf4ed4f16ab0d438fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a344c20c31fd347cf4ed4f16ab0d438fb">cntree_vector</a> (const alloc_t &amp;ALLC=alloc_t())</td></tr>
<tr class="memdesc:a344c20c31fd347cf4ed4f16ab0d438fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from an object Allocator.  <a href="#a344c20c31fd347cf4ed4f16ab0d438fb">More...</a><br/></td></tr>
<tr class="separator:a344c20c31fd347cf4ed4f16ab0d438fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594872e2afc204197d7660571659c2dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a594872e2afc204197d7660571659c2dc">cntree_vector</a> (const <a class="el" href="a00019.html">cntree_vector</a> &amp;VT)</td></tr>
<tr class="memdesc:a594872e2afc204197d7660571659c2dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a594872e2afc204197d7660571659c2dc">More...</a><br/></td></tr>
<tr class="separator:a594872e2afc204197d7660571659c2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81e0fdbc22bb24af7aa0f84e899c97a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ad81e0fdbc22bb24af7aa0f84e899c97a">cntree_vector</a> (<a class="el" href="a00019.html">cntree_vector</a> &amp;&amp;VT)</td></tr>
<tr class="memdesc:ad81e0fdbc22bb24af7aa0f84e899c97a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#ad81e0fdbc22bb24af7aa0f84e899c97a">More...</a><br/></td></tr>
<tr class="separator:ad81e0fdbc22bb24af7aa0f84e899c97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba70b9a3a7162c384dd3bdf2b0f6913f"><td class="memTemplParams" colspan="2">template&lt;typename alloc_t2  = alloc_t, bool cnc2 = cnc&gt; </td></tr>
<tr class="memitem:aba70b9a3a7162c384dd3bdf2b0f6913f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#aba70b9a3a7162c384dd3bdf2b0f6913f">cntree_vector</a> (const <a class="el" href="a00019.html">cntree_vector</a>&lt; value_t, cnc2, alloc_t2 &gt; &amp;VT)</td></tr>
<tr class="memdesc:aba70b9a3a7162c384dd3bdf2b0f6913f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor from a vector of different allocator.  <a href="#aba70b9a3a7162c384dd3bdf2b0f6913f">More...</a><br/></td></tr>
<tr class="separator:aba70b9a3a7162c384dd3bdf2b0f6913f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8675fd4c7e9a6631c1b881dfdad894b"><td class="memTemplParams" colspan="2">template&lt;bool cnc2&gt; </td></tr>
<tr class="memitem:ac8675fd4c7e9a6631c1b881dfdad894b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#ac8675fd4c7e9a6631c1b881dfdad894b">cntree_vector</a> (<a class="el" href="a00019.html">cntree_vector</a>&lt; value_t, cnc2, alloc_t &gt; &amp;&amp;VT)</td></tr>
<tr class="memdesc:ac8675fd4c7e9a6631c1b881dfdad894b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor from a vector with the same allocator and different.  <a href="#ac8675fd4c7e9a6631c1b881dfdad894b">More...</a><br/></td></tr>
<tr class="separator:ac8675fd4c7e9a6631c1b881dfdad894b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9632c5c54d53f81381d6e3668c533a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#acb9632c5c54d53f81381d6e3668c533a">cntree_vector</a> (unsigned_type n, const value_t &amp;Val=value_t(), const alloc_t &amp;A=alloc_t())</td></tr>
<tr class="memdesc:acb9632c5c54d53f81381d6e3668c533a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from a value repeated a number of times and an object Allocator.  <a href="#acb9632c5c54d53f81381d6e3668c533a">More...</a><br/></td></tr>
<tr class="separator:acb9632c5c54d53f81381d6e3668c533a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1190b582c791f6e9c09301608ff3aac"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:aa1190b582c791f6e9c09301608ff3aac"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#aa1190b582c791f6e9c09301608ff3aac">cntree_vector</a> (InputIterator it_first, InputIterator it_last, const alloc_t &amp;A=alloc_t())</td></tr>
<tr class="memdesc:aa1190b582c791f6e9c09301608ff3aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from a pair of iterators and an object Allocator.  <a href="#aa1190b582c791f6e9c09301608ff3aac">More...</a><br/></td></tr>
<tr class="separator:aa1190b582c791f6e9c09301608ff3aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af145677a55604df5465cfbaba5e3dba4"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#af145677a55604df5465cfbaba5e3dba4">~cntree_vector</a> (void)</td></tr>
<tr class="memdesc:af145677a55604df5465cfbaba5e3dba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#af145677a55604df5465cfbaba5e3dba4">More...</a><br/></td></tr>
<tr class="separator:af145677a55604df5465cfbaba5e3dba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106653ec27cdda561bd86fb08ccfcf03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html">cntree_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a106653ec27cdda561bd86fb08ccfcf03">operator=</a> (const <a class="el" href="a00019.html">cntree_vector</a> &amp;VT)</td></tr>
<tr class="memdesc:a106653ec27cdda561bd86fb08ccfcf03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asignation operator.  <a href="#a106653ec27cdda561bd86fb08ccfcf03">More...</a><br/></td></tr>
<tr class="separator:a106653ec27cdda561bd86fb08ccfcf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bf41521b42e053728c32d649e584c8"><td class="memTemplParams" colspan="2">template&lt;typename alloc_t2 , bool cnc2&gt; </td></tr>
<tr class="memitem:ab1bf41521b42e053728c32d649e584c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00019.html">cntree_vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#ab1bf41521b42e053728c32d649e584c8">operator=</a> (const <a class="el" href="a00019.html">cntree_vector</a>&lt; value_t, cnc2, alloc_t2 &gt; &amp;VT)</td></tr>
<tr class="memdesc:ab1bf41521b42e053728c32d649e584c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asignation operator.  <a href="#ab1bf41521b42e053728c32d649e584c8">More...</a><br/></td></tr>
<tr class="separator:ab1bf41521b42e053728c32d649e584c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2164589da63a2f4cb2c1416eec65436"><td class="memTemplParams" colspan="2">template&lt;bool cnc2&gt; </td></tr>
<tr class="memitem:ac2164589da63a2f4cb2c1416eec65436"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00019.html">cntree_vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#ac2164589da63a2f4cb2c1416eec65436">operator=</a> (<a class="el" href="a00019.html">cntree_vector</a>&lt; value_t, cnc2, alloc_t &gt; &amp;&amp;A)</td></tr>
<tr class="memdesc:ac2164589da63a2f4cb2c1416eec65436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asignation operator.  <a href="#ac2164589da63a2f4cb2c1416eec65436">More...</a><br/></td></tr>
<tr class="separator:ac2164589da63a2f4cb2c1416eec65436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae271710d82d3a0165821169863316945"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:ae271710d82d3a0165821169863316945"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#ae271710d82d3a0165821169863316945">assign</a> (InputIterator it_first, InputIterator it_last)</td></tr>
<tr class="memdesc:ae271710d82d3a0165821169863316945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a range of data, It's like the assignation operator but with several parameters.  <a href="#ae271710d82d3a0165821169863316945">More...</a><br/></td></tr>
<tr class="separator:ae271710d82d3a0165821169863316945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42638c1a9c3da5539fe5b488d09ad6f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a42638c1a9c3da5539fe5b488d09ad6f5">assign</a> (unsigned_type n, const value_t &amp;u)</td></tr>
<tr class="memdesc:a42638c1a9c3da5539fe5b488d09ad6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a range of data, dropping all the elements of the container It's like the assignation operator but with several parameters.  <a href="#a42638c1a9c3da5539fe5b488d09ad6f5">More...</a><br/></td></tr>
<tr class="separator:a42638c1a9c3da5539fe5b488d09ad6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0663c9418c1d3fafe3221eda53e7086e"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Function &gt; </td></tr>
<tr class="memitem:a0663c9418c1d3fafe3221eda53e7086e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#a0663c9418c1d3fafe3221eda53e7086e">assign_if</a> (InputIterator it_first, InputIterator it_last, Function &amp;&amp;M)</td></tr>
<tr class="memdesc:a0663c9418c1d3fafe3221eda53e7086e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a range of data, dropping all the elements of the container It's like the assignation operator but with several parameters.  <a href="#a0663c9418c1d3fafe3221eda53e7086e">More...</a><br/></td></tr>
<tr class="separator:a0663c9418c1d3fafe3221eda53e7086e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeeba4da0cb6bd0e93e170f23d31d6ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#afeeba4da0cb6bd0e93e170f23d31d6ab">clear</a> (void)</td></tr>
<tr class="memdesc:afeeba4da0cb6bd0e93e170f23d31d6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all the elements of the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. It's a function O(N)  <a href="#afeeba4da0cb6bd0e93e170f23d31d6ab">More...</a><br/></td></tr>
<tr class="separator:afeeba4da0cb6bd0e93e170f23d31d6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb8161d8d8e5a3e5a31c358fa565bfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#afbb8161d8d8e5a3e5a31c358fa565bfc">swap</a> (<a class="el" href="a00019.html">cntree_vector</a> &amp;A) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:afbb8161d8d8e5a3e5a31c358fa565bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap the data between the two <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>  <a href="#afbb8161d8d8e5a3e5a31c358fa565bfc">More...</a><br/></td></tr>
<tr class="separator:afbb8161d8d8e5a3e5a31c358fa565bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938c8e7b8066ef4e3907c256f953f098"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a938c8e7b8066ef4e3907c256f953f098">size</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a938c8e7b8066ef4e3907c256f953f098"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of elements in the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>  <a href="#a938c8e7b8066ef4e3907c256f953f098">More...</a><br/></td></tr>
<tr class="separator:a938c8e7b8066ef4e3907c256f953f098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ce0a0cb03c86dc51c655fab20eaa9d"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a13ce0a0cb03c86dc51c655fab20eaa9d">max_size</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a13ce0a0cb03c86dc51c655fab20eaa9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the maximun size of the container  <a href="#a13ce0a0cb03c86dc51c655fab20eaa9d">More...</a><br/></td></tr>
<tr class="separator:a13ce0a0cb03c86dc51c655fab20eaa9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0399fba189f3010653664f2a07ba387f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a0399fba189f3010653664f2a07ba387f">resize</a> (signed_type sz, value_t c=value_t())</td></tr>
<tr class="memdesc:a0399fba189f3010653664f2a07ba387f"><td class="mdescLeft">&#160;</td><td class="mdescRight">resize the current vector size and change to sz.<br/>
 If sz is smaller than the current size, delete elements to end<br/>
 If sz is greater than the current size, insert elements to the end with the value c  <a href="#a0399fba189f3010653664f2a07ba387f">More...</a><br/></td></tr>
<tr class="separator:a0399fba189f3010653664f2a07ba387f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d3c4a6ad67cd69128d8f9e1c948b19"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ad9d3c4a6ad67cd69128d8f9e1c948b19">capacity</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ad9d3c4a6ad67cd69128d8f9e1c948b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the maximun size of the container  <a href="#ad9d3c4a6ad67cd69128d8f9e1c948b19">More...</a><br/></td></tr>
<tr class="separator:ad9d3c4a6ad67cd69128d8f9e1c948b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05fa08d8156b2cf1be54148874731b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ab05fa08d8156b2cf1be54148874731b2">empty</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:ab05fa08d8156b2cf1be54148874731b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicate if the map is empty  <a href="#ab05fa08d8156b2cf1be54148874731b2">More...</a><br/></td></tr>
<tr class="separator:ab05fa08d8156b2cf1be54148874731b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154c3aadf8e287cd2f35cf8721846857"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a154c3aadf8e287cd2f35cf8721846857">reserve</a> (signed_type n) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a154c3aadf8e287cd2f35cf8721846857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the capacity for to contain , at least n elements.  <a href="#a154c3aadf8e287cd2f35cf8721846857">More...</a><br/></td></tr>
<tr class="separator:a154c3aadf8e287cd2f35cf8721846857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430b67855e0b0796d8086d7138c50414"><td class="memItemLeft" align="right" valign="top">value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a430b67855e0b0796d8086d7138c50414">at</a> (signed_type Pos) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a430b67855e0b0796d8086d7138c50414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked access to an element by their position in the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>.  <a href="#a430b67855e0b0796d8086d7138c50414">More...</a><br/></td></tr>
<tr class="separator:a430b67855e0b0796d8086d7138c50414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e240e500a80d4396f7503ca9268fb8b"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a3e240e500a80d4396f7503ca9268fb8b">at</a> (signed_type Pos) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a3e240e500a80d4396f7503ca9268fb8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked access to an element by their position in the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>.  <a href="#a3e240e500a80d4396f7503ca9268fb8b">More...</a><br/></td></tr>
<tr class="separator:a3e240e500a80d4396f7503ca9268fb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f89089e07505024f6216bbb7fd5c3a"><td class="memItemLeft" align="right" valign="top">value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a11f89089e07505024f6216bbb7fd5c3a">operator[]</a> (signed_type Pos) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a11f89089e07505024f6216bbb7fd5c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked access to an element by their position in the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>.  <a href="#a11f89089e07505024f6216bbb7fd5c3a">More...</a><br/></td></tr>
<tr class="separator:a11f89089e07505024f6216bbb7fd5c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04a32ab965d08a6d028fe515d5f4b3a"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#af04a32ab965d08a6d028fe515d5f4b3a">operator[]</a> (signed_type Pos) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:af04a32ab965d08a6d028fe515d5f4b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked access to an element by their position in the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>.  <a href="#af04a32ab965d08a6d028fe515d5f4b3a">More...</a><br/></td></tr>
<tr class="separator:af04a32ab965d08a6d028fe515d5f4b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a023d059f84ec5f2798381208458708"><td class="memItemLeft" align="right" valign="top">value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a1a023d059f84ec5f2798381208458708">front</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a1a023d059f84ec5f2798381208458708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the first element in the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>.  <a href="#a1a023d059f84ec5f2798381208458708">More...</a><br/></td></tr>
<tr class="separator:a1a023d059f84ec5f2798381208458708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21565c8b856507c247539f6ae95c00a4"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a21565c8b856507c247539f6ae95c00a4">front</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a21565c8b856507c247539f6ae95c00a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const_reference to the first element in the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>.  <a href="#a21565c8b856507c247539f6ae95c00a4">More...</a><br/></td></tr>
<tr class="separator:a21565c8b856507c247539f6ae95c00a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6267e7911794d81f93dd9c2d1c3c7e69"><td class="memItemLeft" align="right" valign="top">value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a6267e7911794d81f93dd9c2d1c3c7e69">back</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a6267e7911794d81f93dd9c2d1c3c7e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the last element in the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>.  <a href="#a6267e7911794d81f93dd9c2d1c3c7e69">More...</a><br/></td></tr>
<tr class="separator:a6267e7911794d81f93dd9c2d1c3c7e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f097cc0a4cd7632ccd18e3b3f7ff924"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a3f097cc0a4cd7632ccd18e3b3f7ff924">back</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="memdesc:a3f097cc0a4cd7632ccd18e3b3f7ff924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const_reference to the last element in the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>.  <a href="#a3f097cc0a4cd7632ccd18e3b3f7ff924">More...</a><br/></td></tr>
<tr class="separator:a3f097cc0a4cd7632ccd18e3b3f7ff924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96c66fa72edf0ef712130cc4fa7f06b"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:ab96c66fa72edf0ef712130cc4fa7f06b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#ab96c66fa72edf0ef712130cc4fa7f06b">push_front</a> (P &amp;&amp;D)</td></tr>
<tr class="memdesc:ab96c66fa72edf0ef712130cc4fa7f06b"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in the front of the container  <a href="#ab96c66fa72edf0ef712130cc4fa7f06b">More...</a><br/></td></tr>
<tr class="separator:ab96c66fa72edf0ef712130cc4fa7f06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f613175cd44addf8058f7306b38e2f"><td class="memTemplParams" colspan="2">template&lt;class P , class Function &gt; </td></tr>
<tr class="memitem:aa0f613175cd44addf8058f7306b38e2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#aa0f613175cd44addf8058f7306b38e2f">push_front_if</a> (P &amp;&amp;D, Function &amp;&amp;M)</td></tr>
<tr class="memdesc:aa0f613175cd44addf8058f7306b38e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in the front of the container  <a href="#aa0f613175cd44addf8058f7306b38e2f">More...</a><br/></td></tr>
<tr class="separator:aa0f613175cd44addf8058f7306b38e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be15443e2ba2c9d6666ab991b2a67bd"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a9be15443e2ba2c9d6666ab991b2a67bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#a9be15443e2ba2c9d6666ab991b2a67bd">emplace_front</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a9be15443e2ba2c9d6666ab991b2a67bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in the front of the container  <a href="#a9be15443e2ba2c9d6666ab991b2a67bd">More...</a><br/></td></tr>
<tr class="separator:a9be15443e2ba2c9d6666ab991b2a67bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e72a26ab0ff49e1bffbe3116c15609a"><td class="memTemplParams" colspan="2">template&lt;class Function , class... Args&gt; </td></tr>
<tr class="memitem:a8e72a26ab0ff49e1bffbe3116c15609a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#a8e72a26ab0ff49e1bffbe3116c15609a">emplace_front_if</a> (Function &amp;&amp;M, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a8e72a26ab0ff49e1bffbe3116c15609a"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in the front of the container  <a href="#a8e72a26ab0ff49e1bffbe3116c15609a">More...</a><br/></td></tr>
<tr class="separator:a8e72a26ab0ff49e1bffbe3116c15609a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0c5876998af5ac0c86db6f74dbabf2"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:abe0c5876998af5ac0c86db6f74dbabf2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#abe0c5876998af5ac0c86db6f74dbabf2">push_back</a> (P &amp;&amp;D)</td></tr>
<tr class="memdesc:abe0c5876998af5ac0c86db6f74dbabf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert one element in the back of the container.  <a href="#abe0c5876998af5ac0c86db6f74dbabf2">More...</a><br/></td></tr>
<tr class="separator:abe0c5876998af5ac0c86db6f74dbabf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa8e978249e699a3bc51e6bf92bd7e1"><td class="memTemplParams" colspan="2">template&lt;class P , class Function &gt; </td></tr>
<tr class="memitem:a0aa8e978249e699a3bc51e6bf92bd7e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#a0aa8e978249e699a3bc51e6bf92bd7e1">push_back_if</a> (P &amp;&amp;D, Function &amp;&amp;M)</td></tr>
<tr class="memdesc:a0aa8e978249e699a3bc51e6bf92bd7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert one element in the back of the container.  <a href="#a0aa8e978249e699a3bc51e6bf92bd7e1">More...</a><br/></td></tr>
<tr class="separator:a0aa8e978249e699a3bc51e6bf92bd7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d926610131daae834ac3d18ded02cae"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a5d926610131daae834ac3d18ded02cae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#a5d926610131daae834ac3d18ded02cae">emplace_back</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a5d926610131daae834ac3d18ded02cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert one element in the back of the container.  <a href="#a5d926610131daae834ac3d18ded02cae">More...</a><br/></td></tr>
<tr class="separator:a5d926610131daae834ac3d18ded02cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeef50a32dcd4b39ba09b01a226e9ccf"><td class="memTemplParams" colspan="2">template&lt;class Function , class... Args&gt; </td></tr>
<tr class="memitem:aeeef50a32dcd4b39ba09b01a226e9ccf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#aeeef50a32dcd4b39ba09b01a226e9ccf">emplace_back_if</a> (Function &amp;&amp;M, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:aeeef50a32dcd4b39ba09b01a226e9ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert one element in the back of the container.  <a href="#aeeef50a32dcd4b39ba09b01a226e9ccf">More...</a><br/></td></tr>
<tr class="separator:aeeef50a32dcd4b39ba09b01a226e9ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1056e6c2f0d47ea05f5bb5260fe6a1ad"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a1056e6c2f0d47ea05f5bb5260fe6a1ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#a1056e6c2f0d47ea05f5bb5260fe6a1ad">insert_pos</a> (signed_type Pos, P &amp;&amp;D)</td></tr>
<tr class="memdesc:a1056e6c2f0d47ea05f5bb5260fe6a1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in a specified position  <a href="#a1056e6c2f0d47ea05f5bb5260fe6a1ad">More...</a><br/></td></tr>
<tr class="separator:a1056e6c2f0d47ea05f5bb5260fe6a1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a9c2a94f9a3b08149b92810cf5b212"><td class="memTemplParams" colspan="2">template&lt;class P , class Function &gt; </td></tr>
<tr class="memitem:a56a9c2a94f9a3b08149b92810cf5b212"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#a56a9c2a94f9a3b08149b92810cf5b212">insert_pos_if</a> (signed_type Pos, P &amp;&amp;D, Function &amp;&amp;M)</td></tr>
<tr class="memdesc:a56a9c2a94f9a3b08149b92810cf5b212"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in a specified position  <a href="#a56a9c2a94f9a3b08149b92810cf5b212">More...</a><br/></td></tr>
<tr class="separator:a56a9c2a94f9a3b08149b92810cf5b212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7d34c3f93974224d263f663a9af05a"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a5d7d34c3f93974224d263f663a9af05a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#a5d7d34c3f93974224d263f663a9af05a">emplace_pos</a> (signed_type Pos, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a5d7d34c3f93974224d263f663a9af05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in a specified position  <a href="#a5d7d34c3f93974224d263f663a9af05a">More...</a><br/></td></tr>
<tr class="separator:a5d7d34c3f93974224d263f663a9af05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05d8cb59e290303cf5ddd0e1bf79204"><td class="memTemplParams" colspan="2">template&lt;class Function , class... Args&gt; </td></tr>
<tr class="memitem:aa05d8cb59e290303cf5ddd0e1bf79204"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#aa05d8cb59e290303cf5ddd0e1bf79204">emplace_pos_if</a> (signed_type Pos, Function &amp;&amp;M, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:aa05d8cb59e290303cf5ddd0e1bf79204"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in a specified position  <a href="#aa05d8cb59e290303cf5ddd0e1bf79204">More...</a><br/></td></tr>
<tr class="separator:aa05d8cb59e290303cf5ddd0e1bf79204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16fcf1d84ae36c1e907c7fa73a25604"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:af16fcf1d84ae36c1e907c7fa73a25604"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#af16fcf1d84ae36c1e907c7fa73a25604">insert</a> (<a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> iter, P &amp;&amp;D)</td></tr>
<tr class="memdesc:af16fcf1d84ae36c1e907c7fa73a25604"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in the previous position to the pointed by the iterator  <a href="#af16fcf1d84ae36c1e907c7fa73a25604">More...</a><br/></td></tr>
<tr class="separator:af16fcf1d84ae36c1e907c7fa73a25604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aec1dc9be475d2d09c41f352e648c1e"><td class="memTemplParams" colspan="2">template&lt;class P , class Function &gt; </td></tr>
<tr class="memitem:a8aec1dc9be475d2d09c41f352e648c1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#a8aec1dc9be475d2d09c41f352e648c1e">insert_if</a> (<a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> iter, P &amp;&amp;D, Function &amp;&amp;M)</td></tr>
<tr class="memdesc:a8aec1dc9be475d2d09c41f352e648c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in the previous position to the pointed by the iterator  <a href="#a8aec1dc9be475d2d09c41f352e648c1e">More...</a><br/></td></tr>
<tr class="separator:a8aec1dc9be475d2d09c41f352e648c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf158fcb2cef65354f7c7d41baf1c3c1"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:acf158fcb2cef65354f7c7d41baf1c3c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#acf158fcb2cef65354f7c7d41baf1c3c1">emplace</a> (<a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> iter, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:acf158fcb2cef65354f7c7d41baf1c3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in the previous position to the pointed by the iterator  <a href="#acf158fcb2cef65354f7c7d41baf1c3c1">More...</a><br/></td></tr>
<tr class="separator:acf158fcb2cef65354f7c7d41baf1c3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f9db416a3547bfbd0b8118f595abaa"><td class="memTemplParams" colspan="2">template&lt;class Function , class... Args&gt; </td></tr>
<tr class="memitem:a12f9db416a3547bfbd0b8118f595abaa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#a12f9db416a3547bfbd0b8118f595abaa">emplace_if</a> (<a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> iter, Function &amp;&amp;M, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a12f9db416a3547bfbd0b8118f595abaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert an element in the previous position to the pointed by the iterator  <a href="#a12f9db416a3547bfbd0b8118f595abaa">More...</a><br/></td></tr>
<tr class="separator:a12f9db416a3547bfbd0b8118f595abaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6200a9cf80f813e2dc6b4b1d609bc9"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:acd6200a9cf80f813e2dc6b4b1d609bc9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#acd6200a9cf80f813e2dc6b4b1d609bc9">insert</a> (<a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> iter, unsigned_type n, const P &amp;D)</td></tr>
<tr class="memdesc:acd6200a9cf80f813e2dc6b4b1d609bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert n elements with the value D element in the position specified by an iterator  <a href="#acd6200a9cf80f813e2dc6b4b1d609bc9">More...</a><br/></td></tr>
<tr class="separator:acd6200a9cf80f813e2dc6b4b1d609bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36aff656106d6a2693f3ad696bc96bf7"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a36aff656106d6a2693f3ad696bc96bf7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#a36aff656106d6a2693f3ad696bc96bf7">insert</a> (<a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> iter, InputIterator A_first, InputIterator A_last)</td></tr>
<tr class="memdesc:a36aff656106d6a2693f3ad696bc96bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a range of lements defined by the pair of iterators A_first, A_last in the position defined by the iterator iter.  <a href="#a36aff656106d6a2693f3ad696bc96bf7">More...</a><br/></td></tr>
<tr class="separator:a36aff656106d6a2693f3ad696bc96bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eff243476f27f2d7f1dd8d9888a91a6"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Function &gt; </td></tr>
<tr class="memitem:a1eff243476f27f2d7f1dd8d9888a91a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#a1eff243476f27f2d7f1dd8d9888a91a6">insert_if</a> (<a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> iter, InputIterator A_first, InputIterator A_last, Function &amp;&amp;M)</td></tr>
<tr class="memdesc:a1eff243476f27f2d7f1dd8d9888a91a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a range of lements defined by the pair of iterators A_first, A_last in the position defined by the iterator iter. But insert only the elements which make true the function M  <a href="#a1eff243476f27f2d7f1dd8d9888a91a6">More...</a><br/></td></tr>
<tr class="separator:a1eff243476f27f2d7f1dd8d9888a91a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e762b6d54e5a3fdfd00b65b0561dde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a12e762b6d54e5a3fdfd00b65b0561dde">pop_front</a> (void)</td></tr>
<tr class="memdesc:a12e762b6d54e5a3fdfd00b65b0561dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the container  <a href="#a12e762b6d54e5a3fdfd00b65b0561dde">More...</a><br/></td></tr>
<tr class="separator:a12e762b6d54e5a3fdfd00b65b0561dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e47feeae3ef2e7e758602474657ea62"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a2e47feeae3ef2e7e758602474657ea62"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#a2e47feeae3ef2e7e758602474657ea62">pop_front_if</a> (Function &amp;&amp;M1)</td></tr>
<tr class="memdesc:a2e47feeae3ef2e7e758602474657ea62"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the container  <a href="#a2e47feeae3ef2e7e758602474657ea62">More...</a><br/></td></tr>
<tr class="separator:a2e47feeae3ef2e7e758602474657ea62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848f40ed32e2e4811bf6f4fa79e514ac"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a848f40ed32e2e4811bf6f4fa79e514ac">pop_copy_front</a> (value_t &amp;V)</td></tr>
<tr class="memdesc:a848f40ed32e2e4811bf6f4fa79e514ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the tree and return a copy  <a href="#a848f40ed32e2e4811bf6f4fa79e514ac">More...</a><br/></td></tr>
<tr class="separator:a848f40ed32e2e4811bf6f4fa79e514ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6040c13aa1eef6fd6d853a7adb7fff50"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a6040c13aa1eef6fd6d853a7adb7fff50"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#a6040c13aa1eef6fd6d853a7adb7fff50">pop_copy_front_if</a> (value_t &amp;V, Function &amp;&amp;M1)</td></tr>
<tr class="memdesc:a6040c13aa1eef6fd6d853a7adb7fff50"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the tree and return a copy  <a href="#a6040c13aa1eef6fd6d853a7adb7fff50">More...</a><br/></td></tr>
<tr class="separator:a6040c13aa1eef6fd6d853a7adb7fff50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c948029fb21c4aa0f412041660438cd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a9c948029fb21c4aa0f412041660438cd">pop_move_front</a> (value_t &amp;V)</td></tr>
<tr class="memdesc:a9c948029fb21c4aa0f412041660438cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the tree and return a copy with rvalues  <a href="#a9c948029fb21c4aa0f412041660438cd">More...</a><br/></td></tr>
<tr class="separator:a9c948029fb21c4aa0f412041660438cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69ef4c732e8af9e6aa6ba3c51dac0e9"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:aa69ef4c732e8af9e6aa6ba3c51dac0e9"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#aa69ef4c732e8af9e6aa6ba3c51dac0e9">pop_move_front_if</a> (value_t &amp;V, Function &amp;&amp;M1)</td></tr>
<tr class="memdesc:aa69ef4c732e8af9e6aa6ba3c51dac0e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the first element of the tree and return a copy with rvalues  <a href="#aa69ef4c732e8af9e6aa6ba3c51dac0e9">More...</a><br/></td></tr>
<tr class="separator:aa69ef4c732e8af9e6aa6ba3c51dac0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0e7ffff475fd1dd217d7b6d7011d77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a3d0e7ffff475fd1dd217d7b6d7011d77">pop_back</a> (void)</td></tr>
<tr class="memdesc:a3d0e7ffff475fd1dd217d7b6d7011d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the container  <a href="#a3d0e7ffff475fd1dd217d7b6d7011d77">More...</a><br/></td></tr>
<tr class="separator:a3d0e7ffff475fd1dd217d7b6d7011d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07097aafe2ce6155a0eac0d4332b3a5e"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a07097aafe2ce6155a0eac0d4332b3a5e"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#a07097aafe2ce6155a0eac0d4332b3a5e">pop_back_if</a> (Function &amp;&amp;M1)</td></tr>
<tr class="memdesc:a07097aafe2ce6155a0eac0d4332b3a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the container  <a href="#a07097aafe2ce6155a0eac0d4332b3a5e">More...</a><br/></td></tr>
<tr class="separator:a07097aafe2ce6155a0eac0d4332b3a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc192c22d58d3672538f555e85c27677"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#acc192c22d58d3672538f555e85c27677">pop_copy_back</a> (value_t &amp;V)</td></tr>
<tr class="memdesc:acc192c22d58d3672538f555e85c27677"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the tree and return a copy  <a href="#acc192c22d58d3672538f555e85c27677">More...</a><br/></td></tr>
<tr class="separator:acc192c22d58d3672538f555e85c27677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bea3beb87377960b728420bfabe5ade"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a9bea3beb87377960b728420bfabe5ade"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#a9bea3beb87377960b728420bfabe5ade">pop_copy_back_if</a> (value_t &amp;V, Function &amp;&amp;M1)</td></tr>
<tr class="memdesc:a9bea3beb87377960b728420bfabe5ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the tree and return a copy in V  <a href="#a9bea3beb87377960b728420bfabe5ade">More...</a><br/></td></tr>
<tr class="separator:a9bea3beb87377960b728420bfabe5ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf0be597d2da20cb13f60452edc561e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#accf0be597d2da20cb13f60452edc561e">pop_move_back</a> (value_t &amp;V)</td></tr>
<tr class="memdesc:accf0be597d2da20cb13f60452edc561e"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the tree and return a copy with rvalues  <a href="#accf0be597d2da20cb13f60452edc561e">More...</a><br/></td></tr>
<tr class="separator:accf0be597d2da20cb13f60452edc561e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf1c9c014f8e6e39ac70cfb95323b9c"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a2bf1c9c014f8e6e39ac70cfb95323b9c"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#a2bf1c9c014f8e6e39ac70cfb95323b9c">pop_move_back_if</a> (value_t &amp;V, Function &amp;&amp;M1)</td></tr>
<tr class="memdesc:a2bf1c9c014f8e6e39ac70cfb95323b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the last element of the tree and return a copy with rvalues  <a href="#a2bf1c9c014f8e6e39ac70cfb95323b9c">More...</a><br/></td></tr>
<tr class="separator:a2bf1c9c014f8e6e39ac70cfb95323b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77ceb4ed076de0fc04d97202cac2caf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ac77ceb4ed076de0fc04d97202cac2caf">erase</a> (<a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> iter)</td></tr>
<tr class="memdesc:ac77ceb4ed076de0fc04d97202cac2caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element pointed by iter  <a href="#ac77ceb4ed076de0fc04d97202cac2caf">More...</a><br/></td></tr>
<tr class="separator:ac77ceb4ed076de0fc04d97202cac2caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d43c8c099bb987abc8a35093ae8c611"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a0d43c8c099bb987abc8a35093ae8c611"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#a0d43c8c099bb987abc8a35093ae8c611">erase_if</a> (<a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> iter, Function &amp;&amp;M1)</td></tr>
<tr class="memdesc:a0d43c8c099bb987abc8a35093ae8c611"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element pointed by iter if the function return true  <a href="#a0d43c8c099bb987abc8a35093ae8c611">More...</a><br/></td></tr>
<tr class="separator:a0d43c8c099bb987abc8a35093ae8c611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace99e43aa93880be75facb3bcbaf05f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ace99e43aa93880be75facb3bcbaf05f7">erase_pos</a> (signed_type Pos)</td></tr>
<tr class="memdesc:ace99e43aa93880be75facb3bcbaf05f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element of the position pos  <a href="#ace99e43aa93880be75facb3bcbaf05f7">More...</a><br/></td></tr>
<tr class="separator:ace99e43aa93880be75facb3bcbaf05f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42487a34ec2d6402d2c75355c770b148"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a42487a34ec2d6402d2c75355c770b148"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#a42487a34ec2d6402d2c75355c770b148">erase_pos_if</a> (signed_type Pos, Function &amp;&amp;M)</td></tr>
<tr class="memdesc:a42487a34ec2d6402d2c75355c770b148"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the element of the position pos  <a href="#a42487a34ec2d6402d2c75355c770b148">More...</a><br/></td></tr>
<tr class="separator:a42487a34ec2d6402d2c75355c770b148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553e33fd6be44e45a85800a6ed148c0c"><td class="memItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a553e33fd6be44e45a85800a6ed148c0c">erase</a> (<a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> first_it, <a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> last_it)</td></tr>
<tr class="memdesc:a553e33fd6be44e45a85800a6ed148c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase a range of elements between first_it and last_it  <a href="#a553e33fd6be44e45a85800a6ed148c0c">More...</a><br/></td></tr>
<tr class="separator:a553e33fd6be44e45a85800a6ed148c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99c510b33aa962b6018e6c2d010a442"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:aa99c510b33aa962b6018e6c2d010a442"><td class="memTemplItemLeft" align="right" valign="top">signed_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#aa99c510b33aa962b6018e6c2d010a442">erase_if</a> (<a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> first_it, <a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> last_it, Function &amp;&amp;M1)</td></tr>
<tr class="memdesc:aa99c510b33aa962b6018e6c2d010a442"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase a range of elements between first_it and last_it  <a href="#aa99c510b33aa962b6018e6c2d010a442">More...</a><br/></td></tr>
<tr class="separator:aa99c510b33aa962b6018e6c2d010a442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8dc242c5e9162a0099ecdd49543ddf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a9a8dc242c5e9162a0099ecdd49543ddf">erase_pos</a> (signed_type First, signed_type NElem)</td></tr>
<tr class="memdesc:a9a8dc242c5e9162a0099ecdd49543ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the NElem elements after the position First  <a href="#a9a8dc242c5e9162a0099ecdd49543ddf">More...</a><br/></td></tr>
<tr class="separator:a9a8dc242c5e9162a0099ecdd49543ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18cf30f6f9c9778be3a8f20e6e46f371"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a18cf30f6f9c9778be3a8f20e6e46f371"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#a18cf30f6f9c9778be3a8f20e6e46f371">erase_pos_if</a> (signed_type First, signed_type NElem, Function &amp;&amp;M)</td></tr>
<tr class="memdesc:a18cf30f6f9c9778be3a8f20e6e46f371"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the NElem elements after the position First if the function M return true when receives the element as parameter  <a href="#a18cf30f6f9c9778be3a8f20e6e46f371">More...</a><br/></td></tr>
<tr class="separator:a18cf30f6f9c9778be3a8f20e6e46f371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe72de2023c4ba8c686f793eeffa73a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#abe72de2023c4ba8c686f793eeffa73a0">modify</a> (<a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> It, const <a class="el" href="a00019.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;D)</td></tr>
<tr class="memdesc:abe72de2023c4ba8c686f793eeffa73a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy D to the element pointed by It  <a href="#abe72de2023c4ba8c686f793eeffa73a0">More...</a><br/></td></tr>
<tr class="separator:abe72de2023c4ba8c686f793eeffa73a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bd7113108bb0d2a724b851b7333e1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a76bd7113108bb0d2a724b851b7333e1d">modify</a> (<a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> It, <a class="el" href="a00019.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;&amp;D)</td></tr>
<tr class="memdesc:a76bd7113108bb0d2a724b851b7333e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">move D to the element pointed by It  <a href="#a76bd7113108bb0d2a724b851b7333e1d">More...</a><br/></td></tr>
<tr class="separator:a76bd7113108bb0d2a724b851b7333e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832bd66d4122e9870ced10d34e51234b"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a832bd66d4122e9870ced10d34e51234b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#a832bd66d4122e9870ced10d34e51234b">modify</a> (<a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> It, Function &amp;&amp;M)</td></tr>
<tr class="memdesc:a832bd66d4122e9870ced10d34e51234b"><td class="mdescLeft">&#160;</td><td class="mdescRight">modify the element pointed by It with a function M  <a href="#a832bd66d4122e9870ced10d34e51234b">More...</a><br/></td></tr>
<tr class="separator:a832bd66d4122e9870ced10d34e51234b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9450defa202f7281531a9d74f98e7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#aae9450defa202f7281531a9d74f98e7b">modify_pos</a> (signed_type Pos, const <a class="el" href="a00019.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;D)</td></tr>
<tr class="memdesc:aae9450defa202f7281531a9d74f98e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign D to the element of the position Pos  <a href="#aae9450defa202f7281531a9d74f98e7b">More...</a><br/></td></tr>
<tr class="separator:aae9450defa202f7281531a9d74f98e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c06816505cafa4b03959ac6dab37a5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a0c06816505cafa4b03959ac6dab37a5f">modify_pos</a> (signed_type Pos, <a class="el" href="a00019.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;&amp;D)</td></tr>
<tr class="memdesc:a0c06816505cafa4b03959ac6dab37a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">move D to the element of the position Pos  <a href="#a0c06816505cafa4b03959ac6dab37a5f">More...</a><br/></td></tr>
<tr class="separator:a0c06816505cafa4b03959ac6dab37a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7079328b76dd313aa97146c9efdb3b0b"><td class="memTemplParams" colspan="2">template&lt;class Function &gt; </td></tr>
<tr class="memitem:a7079328b76dd313aa97146c9efdb3b0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#a7079328b76dd313aa97146c9efdb3b0b">modify_pos</a> (signed_type Pos, Function &amp;&amp;M)</td></tr>
<tr class="memdesc:a7079328b76dd313aa97146c9efdb3b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">modify the element of the position Pos with the function M  <a href="#a7079328b76dd313aa97146c9efdb3b0b">More...</a><br/></td></tr>
<tr class="separator:a7079328b76dd313aa97146c9efdb3b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dafe2d43c54cbb61761b3509bc676c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a5dafe2d43c54cbb61761b3509bc676c9">is_mine</a> (<a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> P1) const </td></tr>
<tr class="memdesc:a5dafe2d43c54cbb61761b3509bc676c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the iterator is pointing to this <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>.  <a href="#a5dafe2d43c54cbb61761b3509bc676c9">More...</a><br/></td></tr>
<tr class="separator:a5dafe2d43c54cbb61761b3509bc676c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cf78fe631c8a850ceff7c6602e516f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a31cf78fe631c8a850ceff7c6602e516f">is_mine</a> (<a class="el" href="a00019.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a> P1) const </td></tr>
<tr class="memdesc:a31cf78fe631c8a850ceff7c6602e516f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the iterator is pointing to this <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>.  <a href="#a31cf78fe631c8a850ceff7c6602e516f">More...</a><br/></td></tr>
<tr class="separator:a31cf78fe631c8a850ceff7c6602e516f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d7ffb109841406412ddb587cb11e48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a92d7ffb109841406412ddb587cb11e48">iterator_pos</a> (signed_type Pos1)</td></tr>
<tr class="memdesc:a92d7ffb109841406412ddb587cb11e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a position in the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>.  <a href="#a92d7ffb109841406412ddb587cb11e48">More...</a><br/></td></tr>
<tr class="separator:a92d7ffb109841406412ddb587cb11e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31b98694ed8525f90cb4deb8b98957d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ab31b98694ed8525f90cb4deb8b98957d">const_iterator_pos</a> (signed_type Pos1) const </td></tr>
<tr class="memdesc:ab31b98694ed8525f90cb4deb8b98957d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a position in the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>.  <a href="#ab31b98694ed8525f90cb4deb8b98957d">More...</a><br/></td></tr>
<tr class="separator:ab31b98694ed8525f90cb4deb8b98957d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31b3e45d90b7a96bbd7a9c320f5ea1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#aa31b3e45d90b7a96bbd7a9c320f5ea1b">it_begin</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aa31b3e45d90b7a96bbd7a9c320f5ea1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4b6e31674152b9cb651a9dedd96ded"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a4d4b6e31674152b9cb651a9dedd96ded">begin</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a4d4b6e31674152b9cb651a9dedd96ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bd0195e0f7fa434e8f1240f2886f2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#af1bd0195e0f7fa434e8f1240f2886f2d">it_end</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:af1bd0195e0f7fa434e8f1240f2886f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca25490ad91ef590a20ecc1feeaf5d1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#aca25490ad91ef590a20ecc1feeaf5d1b">end</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aca25490ad91ef590a20ecc1feeaf5d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56c18a3c1d2a1ea9ccda3d787b299bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#aa56c18a3c1d2a1ea9ccda3d787b299bb">it_rbegin</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aa56c18a3c1d2a1ea9ccda3d787b299bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeace62194fd6dceb1eb9a7e74ab4d585"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#aeace62194fd6dceb1eb9a7e74ab4d585">it_rend</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aeace62194fd6dceb1eb9a7e74ab4d585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d66de8d33541dd0bc004e26d1603048"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a4d66de8d33541dd0bc004e26d1603048">cit_begin</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a4d66de8d33541dd0bc004e26d1603048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7537430437e3583341d559bbed347d28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a7537430437e3583341d559bbed347d28">begin</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a7537430437e3583341d559bbed347d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7a976297f187d1c362e3ffadfa02a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#aca7a976297f187d1c362e3ffadfa02a9">cbegin</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aca7a976297f187d1c362e3ffadfa02a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed021874a605ccbdad59b75bd0338e00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#aed021874a605ccbdad59b75bd0338e00">cit_end</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aed021874a605ccbdad59b75bd0338e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9288d9389d1bdd2cc8695253de7cf545"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a9288d9389d1bdd2cc8695253de7cf545">end</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a9288d9389d1bdd2cc8695253de7cf545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba145affac65da63ef632a3e4b3d2ab8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#aba145affac65da63ef632a3e4b3d2ab8">cend</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aba145affac65da63ef632a3e4b3d2ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7280b6a156afd2c913adc442ea4bf96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#aa7280b6a156afd2c913adc442ea4bf96">cit_rbegin</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:aa7280b6a156afd2c913adc442ea4bf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448209fbdd7f9bc800fccdbcef156828"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a448209fbdd7f9bc800fccdbcef156828">cit_rend</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a448209fbdd7f9bc800fccdbcef156828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78b1ce43f0c85bceda1d91902863166"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#af78b1ce43f0c85bceda1d91902863166">rit_begin</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:af78b1ce43f0c85bceda1d91902863166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b381c905e49bd704dab3bc32f3442d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a9b381c905e49bd704dab3bc32f3442d3">rit_end</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a9b381c905e49bd704dab3bc32f3442d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc23d344971d36d528707a9e0a6af17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#affc23d344971d36d528707a9e0a6af17">rit_rbegin</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:affc23d344971d36d528707a9e0a6af17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89ea00525332c83fcc5a7139f17557e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#af89ea00525332c83fcc5a7139f17557e">rbegin</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:af89ea00525332c83fcc5a7139f17557e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5680c212c840c8841989dbe07b1a48ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a5680c212c840c8841989dbe07b1a48ee">rit_rend</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a5680c212c840c8841989dbe07b1a48ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b59a192483536c9dbbec54e608548d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a9b59a192483536c9dbbec54e608548d5">rend</a> (void) <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a9b59a192483536c9dbbec54e608548d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc568bbd22027687f7033f0ee20f6538"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#adc568bbd22027687f7033f0ee20f6538">crit_begin</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:adc568bbd22027687f7033f0ee20f6538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b52753fa26fe35c0cea9f3c82aa76d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a6b52753fa26fe35c0cea9f3c82aa76d6">crit_end</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a6b52753fa26fe35c0cea9f3c82aa76d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d3200e06a8e1f80a1b5b1b9b1001e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ac1d3200e06a8e1f80a1b5b1b9b1001e2">crit_rbegin</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ac1d3200e06a8e1f80a1b5b1b9b1001e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376df61f6285b5f2b5ad9d9161038b4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a376df61f6285b5f2b5ad9d9161038b4b">rbegin</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a376df61f6285b5f2b5ad9d9161038b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1e48e0ea2638eec6b6484c95b72eb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#abc1e48e0ea2638eec6b6484c95b72eb6">crbegin</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:abc1e48e0ea2638eec6b6484c95b72eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d3643852ac5c502852a80655710981"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ab6d3643852ac5c502852a80655710981">crit_rend</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ab6d3643852ac5c502852a80655710981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5f9653fa7c0eacbf21a40c44922e1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a5e5f9653fa7c0eacbf21a40c44922e1c">rend</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:a5e5f9653fa7c0eacbf21a40c44922e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad210f0ec4ff240fddbfca2b3cbef3841"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ad210f0ec4ff240fddbfca2b3cbef3841">crend</a> (void) const <a class="el" href="a00116.html#a10a59554805ac7ce3905fd3540f98137">NOEXCEPT</a></td></tr>
<tr class="separator:ad210f0ec4ff240fddbfca2b3cbef3841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2ab2c5cf22418bb0a5fe2fa2f5b1c1"><td class="memItemLeft" align="right" valign="top">alloc_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ade2ab2c5cf22418bb0a5fe2fa2f5b1c1">get_allocator</a> () const </td></tr>
<tr class="memdesc:ade2ab2c5cf22418bb0a5fe2fa2f5b1c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the object allocator of the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>  <a href="#ade2ab2c5cf22418bb0a5fe2fa2f5b1c1">More...</a><br/></td></tr>
<tr class="separator:ade2ab2c5cf22418bb0a5fe2fa2f5b1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a402632b3199b6a84dc51e1312de37bfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#a7df32d590dc511949720cfa75f878018">mtx_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a402632b3199b6a84dc51e1312de37bfd">BD</a></td></tr>
<tr class="separator:a402632b3199b6a84dc51e1312de37bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a439da6f9eefc2ca2267d20db7bc08d2e"><td class="memItemLeft" align="right" valign="top">alloc_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a439da6f9eefc2ca2267d20db7bc08d2e">value_alloc</a></td></tr>
<tr class="separator:a439da6f9eefc2ca2267d20db7bc08d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c395854fb54d4b307488590e0f4e60d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#adc0f814170aa1d0ab669794e311f638b">node_alloc_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a2c395854fb54d4b307488590e0f4e60d">node_alloc</a></td></tr>
<tr class="separator:a2c395854fb54d4b307488590e0f4e60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1704766d3e53c5b8fc77286ad0c6525b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00019.html#a43753d3c0e064cc6d601496645811657">tree_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a1704766d3e53c5b8fc77286ad0c6525b">T</a></td></tr>
<tr class="separator:a1704766d3e53c5b8fc77286ad0c6525b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a5d141ff25b2b38d29d8e6b76e1d5108e"><td class="memTemplParams" colspan="2">template&lt;class value_t2 , bool cnc2, class alloc_t2 &gt; </td></tr>
<tr class="memitem:a5d141ff25b2b38d29d8e6b76e1d5108e"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00019.html#a5d141ff25b2b38d29d8e6b76e1d5108e">cntree_vector</a></td></tr>
<tr class="separator:a5d141ff25b2b38d29d8e6b76e1d5108e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt;<br/>
class countertree::cntree_vector&lt; value_t, cnc, alloc_t &gt;</h3>

<p>This class have the same interface than the STL vector, but istead of be a vector is a tree. <br/>
 Due to this all the operations ( insert, delete, access) a O( logN). <br/>
. </p>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00051">51</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ad0a9f2752a974795fba5d7ae1cad3695"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef alloc_t <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html#ad0a9f2752a974795fba5d7ae1cad3695">allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00114_source.html#l00072">72</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abcb62c282670d63c6ae02c0d9b6c096b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00103.html#aaf68addaf301fecce33fc7c2a82987d5">tree_t::const_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00114_source.html#l00075">75</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7d5f52cde3f23c059262c35b8dd529c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="a00019.html#a87cf343c3367539a136887208feeee1d">value_type</a>* <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html#a7d5f52cde3f23c059262c35b8dd529c4">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00114_source.html#l00069">69</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7707089005acdf518d94759af5176b40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="a00019.html#a87cf343c3367539a136887208feeee1d">value_type</a>&amp; <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html#a7707089005acdf518d94759af5176b40">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00114_source.html#l00071">71</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a43bd4af0141eb3ccd69c9385f94f3e0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00103.html#afb8570b4b8f3076f34067fa4ec34afca">tree_t::const_reverse_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00114_source.html#l00077">77</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1206c13bbfb20d762a1b3e28662e784e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00103.html#ac4899fc42db7c3418d99a86118933342">tree_t::difference_type</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html#a1206c13bbfb20d762a1b3e28662e784e">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00114_source.html#l00066">66</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad7de56907efcce713cbd358c14b5906c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00103.html#a752155609649dc94fe17ae0239376f04">tree_t::iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00114_source.html#l00074">74</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7df32d590dc511949720cfa75f878018"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00023.html">config_fastmutex</a>&lt;cnc&gt;::fastmutex_data <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html#a7df32d590dc511949720cfa75f878018">mtx_data</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00114_source.html#l00057">57</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a57eb20355ea7a0d1070446429100d7d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00051.html">mutex_read</a>&lt;<a class="el" href="a00019.html#a7df32d590dc511949720cfa75f878018">mtx_data</a>&gt; <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html#a57eb20355ea7a0d1070446429100d7d8">mtx_read</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00114_source.html#l00058">58</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f58e9b32cfb6fd6d7b037664ef7a27e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00053.html">mutex_write</a>&lt;<a class="el" href="a00019.html#a7df32d590dc511949720cfa75f878018">mtx_data</a>&gt; <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html#a6f58e9b32cfb6fd6d7b037664ef7a27e">mtx_write</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00114_source.html#l00059">59</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a225e342728d3e2d927f54aa78728f883"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt; <a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>, bool&gt; <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html#a225e342728d3e2d927f54aa78728f883">mypair</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00114_source.html#l00078">78</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adc0f814170aa1d0ab669794e311f638b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef alloc_t::template rebind&lt;<a class="el" href="a00019.html#a4defa8ea643d60d28ab7e0b32aa7a37f">node_t</a>&gt;::other <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html#adc0f814170aa1d0ab669794e311f638b">node_alloc_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00114_source.html#l00062">62</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4defa8ea643d60d28ab7e0b32aa7a37f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00065.html">countertree::forest::node</a>&lt;value_t&gt; <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html#a4defa8ea643d60d28ab7e0b32aa7a37f">node_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00114_source.html#l00061">61</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a38e3cfb56871236abfb5dceb841797b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00019.html#a87cf343c3367539a136887208feeee1d">value_type</a>* <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html#a38e3cfb56871236abfb5dceb841797b0">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00114_source.html#l00068">68</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a75e5b16f508fded9604f1708112c75b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00019.html#a87cf343c3367539a136887208feeee1d">value_type</a>&amp; <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html#a75e5b16f508fded9604f1708112c75b5">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00114_source.html#l00070">70</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7be73be0ae348fa005c4e399186d91ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00103.html#a9cc1af3e272082d169789594bdcd0114">tree_t::reverse_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00114_source.html#l00076">76</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a76cf48091959d644080dfdfb462998c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00103.html#af62e7d9749b95b2cfe4aa45a1ba09d3a">tree_t::size_type</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html#a76cf48091959d644080dfdfb462998c2">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00114_source.html#l00065">65</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a43753d3c0e064cc6d601496645811657"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00103.html">c_forest::tree</a>&lt;value_t, <a class="el" href="a00019.html#adc0f814170aa1d0ab669794e311f638b">node_alloc_t</a>&gt; <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html#a43753d3c0e064cc6d601496645811657">tree_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00114_source.html#l00063">63</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a87cf343c3367539a136887208feeee1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef value_t <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html#a87cf343c3367539a136887208feeee1d">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00114_source.html#l00067">67</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a344c20c31fd347cf4ed4f16ab0d438fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html">cntree_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const alloc_t &amp;&#160;</td>
          <td class="paramname"><em>ALLC</em> = <code>alloc_t&#160;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from an object Allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>: Allocator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00138">138</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a594872e2afc204197d7660571659c2dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html">cntree_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00019.html">cntree_vector</a>&lt; value_t, cnc, alloc_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>VT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VT</td><td>: <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00145">145</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad81e0fdbc22bb24af7aa0f84e899c97a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html">cntree_vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00019.html">cntree_vector</a>&lt; value_t, cnc, alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>VT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VT</td><td>: <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00155">155</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aba70b9a3a7162c384dd3bdf2b0f6913f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename alloc_t2  = alloc_t, bool cnc2 = cnc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html">cntree_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00019.html">cntree_vector</a>&lt; value_t, cnc2, alloc_t2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>VT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor from a vector of different allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VT</td><td>: <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> after the copy </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00164">164</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac8675fd4c7e9a6631c1b881dfdad894b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;bool cnc2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html">cntree_vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00019.html">cntree_vector</a>&lt; value_t, cnc2, alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>VT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor from a vector with the same allocator and different. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VT</td><td>: <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00177">177</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acb9632c5c54d53f81381d6e3668c533a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html">cntree_vector</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>Val</em> = <code>value_t()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const alloc_t &amp;&#160;</td>
          <td class="paramname"><em>A</em> = <code>alloc_t()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from a value repeated a number of times and an object Allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: Number of repetitions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Val</td><td>: Value to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>: Allocator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00188">188</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa1190b582c791f6e9c09301608ff3aac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::<a class="el" href="a00019.html">cntree_vector</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const alloc_t &amp;&#160;</td>
          <td class="paramname"><em>A</em> = <code>alloc_t()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from a pair of iterators and an object Allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>: iterator to the first element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>: iterator to the last element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A1</td><td>: Allocator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00203">203</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af145677a55604df5465cfbaba5e3dba4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::~<a class="el" href="a00019.html">cntree_vector</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="a00114_source.html#l00213">213</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae271710d82d3a0165821169863316945"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a range of data, It's like the assignation operator but with several parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">it_first</td><td>: iterator to the first element to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">it_last</td><td>: Iterator to the end of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00306">306</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a42638c1a9c3da5539fe5b488d09ad6f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">unsigned_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a range of data, dropping all the elements of the container It's like the assignation operator but with several parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: number of elements to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00320">320</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0663c9418c1d3fafe3221eda53e7086e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator , class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::assign_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>it_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a range of data, dropping all the elements of the container It's like the assignation operator but with several parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">it_first</td><td>: iterator to the first element to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">it_last</td><td>: Iterator to the end of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function which receives an element and when return true the element is inserted and when false , not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00337">337</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a430b67855e0b0796d8086d7138c50414"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_t&amp; <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::at </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checked access to an element by their position in the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the object selected </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (log(N)) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00475">475</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3e240e500a80d4396f7503ca9268fb8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t&amp; <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::at </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checked access to an element by their position in the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the object selected </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (log(N)) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00486">486</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6267e7911794d81f93dd9c2d1c3c7e69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_t&amp; <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the last element in the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the last element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00541">541</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3f097cc0a4cd7632ccd18e3b3f7ff924"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t&amp; <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const_reference to the last element in the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the last element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00552">552</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d4b6e31674152b9cb651a9dedd96ded"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01612">1612</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7537430437e3583341d559bbed347d28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01673">1673</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad9d3c4a6ad67cd69128d8f9e1c948b19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::capacity </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the maximun size of the container </p>
<dl class="section return"><dt>Returns</dt><dd>maximun size of the container </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00419">419</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca7a976297f187d1c362e3ffadfa02a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01680">1680</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aba145affac65da63ef632a3e4b3d2ab8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::cend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01702">1702</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d66de8d33541dd0bc004e26d1603048"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::cit_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01665">1665</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed021874a605ccbdad59b75bd0338e00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::cit_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01687">1687</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa7280b6a156afd2c913adc442ea4bf96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::cit_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01709">1709</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a448209fbdd7f9bc800fccdbcef156828"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::cit_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01717">1717</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afeeba4da0cb6bd0e93e170f23d31d6ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete all the elements of the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. It's a function O(N) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00349">349</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab31b98694ed8525f90cb4deb8b98957d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::const_iterator_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos1</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a position in the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the position. If don't exists throws an exception </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log N) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01585">1585</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc1e48e0ea2638eec6b6484c95b72eb6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::crbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01830">1830</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad210f0ec4ff240fddbfca2b3cbef3841"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::crend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01852">1852</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adc568bbd22027687f7033f0ee20f6538"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::crit_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01799">1799</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b52753fa26fe35c0cea9f3c82aa76d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::crit_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01807">1807</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac1d3200e06a8e1f80a1b5b1b9b1001e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::crit_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01815">1815</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab6d3643852ac5c502852a80655710981"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::crit_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01837">1837</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acf158fcb2cef65354f7c7d41baf1c3c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in the previous position to the pointed by the iterator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>: Iterator indicating the position to insert the value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>:group of arguments for to build the object to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the iterator is <a class="el" href="a00019.html#a9b59a192483536c9dbbec54e608548d5">rend()</a> there is an error because we can't insert before it </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00841">841</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5d926610131daae834ac3d18ded02cae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert one element in the back of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>:group of arguments for to build the object to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00683">683</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeeef50a32dcd4b39ba09b01a226e9ccf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::emplace_back_if </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert one element in the back of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format bool( value_t &amp;). if return true the element is iserted , if false not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>:group of arguments for to build the object to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted, if not return <a class="el" href="a00019.html#aca25490ad91ef590a20ecc1feeaf5d1b">end()</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00697">697</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9be15443e2ba2c9d6666ab991b2a67bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::emplace_front </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in the front of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>: group of arguments for to build the object to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00615">615</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8e72a26ab0ff49e1bffbe3116c15609a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::emplace_front_if </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in the front of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format bool( value_t &amp;). if return true the element is iserted , if false not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>: group of arguments for to build the object to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted, if not return <a class="el" href="a00019.html#aca25490ad91ef590a20ecc1feeaf5d1b">end()</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00630">630</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a12f9db416a3547bfbd0b8118f595abaa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::emplace_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in the previous position to the pointed by the iterator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>: Itera which indicates the position to insert the value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>:group of arguments for to build the object to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format bool( value_t &amp;). if return true the element is iserted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the iterator is <a class="el" href="a00019.html#a9b59a192483536c9dbbec54e608548d5">rend()</a> there is an error because we can't insert before it </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00863">863</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5d7d34c3f93974224d263f663a9af05a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::emplace_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in a specified position </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>:group of arguments for to build the object to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to insert the value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00776">776</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa05d8cb59e290303cf5ddd0e1bf79204"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::emplace_pos_if </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in a specified position </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>:group of arguments for to build the object to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to insert the value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format bool( value_t &amp;). if return true the element is iserted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted if not <a class="el" href="a00019.html#aca25490ad91ef590a20ecc1feeaf5d1b">end()</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00793">793</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab05fa08d8156b2cf1be54148874731b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>indicate if the map is empty </p>
<dl class="section return"><dt>Returns</dt><dd>true if the map is empty, false in any other case </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00428">428</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca25490ad91ef590a20ecc1feeaf5d1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01627">1627</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9288d9389d1bdd2cc8695253de7cf545"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01695">1695</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac77ceb4ed076de0fc04d97202cac2caf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element pointed by iter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>: iterator to the element to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return the iterator to the next element </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01261">1261</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a553e33fd6be44e45a85800a6ed148c0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase a range of elements between first_it and last_it </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first_it</td><td>: iterator to the first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last_it</td><td>: iterator to the final element of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements erased </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01336">1336</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0d43c8c099bb987abc8a35093ae8c611"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element pointed by iter if the function return true </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>: iterator to the element to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format ( bool M (value_t &amp;)) if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the next element to iter </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01276">1276</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa99c510b33aa962b6018e6c2d010a442"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase a range of elements between first_it and last_it </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first_it</td><td>: iterator to the first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last_it</td><td>: iterator to the final element of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M1</td><td>: function with the format ( bool M (value_t &amp;)) if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of elements erased </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01353">1353</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ace99e43aa93880be75facb3bcbaf05f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::erase_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element of the position pos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>: position to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01294">1294</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9a8dc242c5e9162a0099ecdd49543ddf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::erase_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>First</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>NElem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the NElem elements after the position First </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">First</td><td>: position to the first element to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NElem</td><td>: number of elements to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01369">1369</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a42487a34ec2d6402d2c75355c770b148"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::erase_pos_if </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the element of the position pos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>: position to delete </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format ( bool M (value_t &amp;)) if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true -&gt;deleted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01314">1314</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a18cf30f6f9c9778be3a8f20e6e46f371"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::erase_pos_if </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>First</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>NElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the NElem elements after the position First if the function M return true when receives the element as parameter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">First</td><td>: position to the first element to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NElem</td><td>: number of elements to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format( bool M (value_t &amp;)) if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01387">1387</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1a023d059f84ec5f2798381208458708"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_t&amp; <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the first element in the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the first element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00519">519</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a21565c8b856507c247539f6ae95c00a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t&amp; <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const_reference to the first element in the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the first element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant)) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00530">530</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ade2ab2c5cf22418bb0a5fe2fa2f5b1c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">alloc_t <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the object allocator of the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>object allocator </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01871">1871</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af16fcf1d84ae36c1e907c7fa73a25604"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in the previous position to the pointed by the iterator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>: Iterator which indicates the position to insert the value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert Can ve a value, a reference or an rvalue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the iterator is <a class="el" href="a00019.html#a9b59a192483536c9dbbec54e608548d5">rend()</a> there is an error because we can't insert before it </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00810">810</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acd6200a9cf80f813e2dc6b4b1d609bc9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert n elements with the value D element in the position specified by an iterator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>: Iterator which indicates the position to insert the value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: Number of elements to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the iterator is <a class="el" href="a00019.html#a9b59a192483536c9dbbec54e608548d5">rend()</a> there is an error because we can't insert before it </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00884">884</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a36aff656106d6a2693f3ad696bc96bf7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>A_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>A_last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a range of lements defined by the pair of iterators A_first, A_last in the position defined by the iterator iter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>: Iterator which indicates the position to insert the value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_first</td><td>: InputIterator to the first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_last</td><td>: InputIterator to the next element of the last </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the iterator is <a class="el" href="a00019.html#a9b59a192483536c9dbbec54e608548d5">rend()</a> there is an error because we can't insert before it </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00904">904</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8aec1dc9be475d2d09c41f352e648c1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class P , class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::insert_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in the previous position to the pointed by the iterator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>: Iterator which indicates the position to insert the value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert Can ve a value, a reference or an rvalue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format bool( value_t &amp;). if return true the element is iserted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted if not false() </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the iterator is <a class="el" href="a00019.html#a9b59a192483536c9dbbec54e608548d5">rend()</a> there is an error because we can't insert before it </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00826">826</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1eff243476f27f2d7f1dd8d9888a91a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator , class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::insert_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>A_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>A_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert a range of lements defined by the pair of iterators A_first, A_last in the position defined by the iterator iter. But insert only the elements which make true the function M </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>: Iterator which indicates the position to insert the value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_first</td><td>: InputIterator to thje first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_last</td><td>: InputIterator to the next element of the last </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format bool( value_t &amp;). if return true the element is iserted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the iterator is <a class="el" href="a00019.html#a9b59a192483536c9dbbec54e608548d5">rend()</a> there is an error because we can't insert before it </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00927">927</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1056e6c2f0d47ea05f5bb5260fe6a1ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::insert_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in a specified position </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert. Can ve a value, a reference or an rvalue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to insert the value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00748">748</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a56a9c2a94f9a3b08149b92810cf5b212"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class P , class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::insert_pos_if </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in a specified position </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to insert the value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert Can ve a value, a reference or an rvalue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format bool( value_t &amp;). if return true the element is iserted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log(N) ) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00763">763</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5dafe2d43c54cbb61761b3509bc676c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::is_mine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00019.html#abcb62c282670d63c6ae02c0d9b6c096b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>P1</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the iterator is pointing to this <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: iterator to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(true/false ) Indicate if it is pointing to this <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01551">1551</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a31cf78fe631c8a850ceff7c6602e516f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::is_mine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00019.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a>&#160;</td>
          <td class="paramname"><em>P1</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the iterator is pointing to this <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>: iterator to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(true/false ) Indicate if it is pointing to this <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01562">1562</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa31b3e45d90b7a96bbd7a9c320f5ea1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::it_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01604">1604</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af1bd0195e0f7fa434e8f1240f2886f2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::it_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01619">1619</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa56c18a3c1d2a1ea9ccda3d787b299bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::it_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01634">1634</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeace62194fd6dceb1eb9a7e74ab4d585"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::it_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01642">1642</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a92d7ffb109841406412ddb587cb11e48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::iterator_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a position in the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the position. If don't exists throw an exception </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( log N) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01573">1573</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a13ce0a0cb03c86dc51c655fab20eaa9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::max_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the maximun size of the container </p>
<dl class="section return"><dt>Returns</dt><dd>maximun size of the container </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00395">395</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abe72de2023c4ba8c686f793eeffa73a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::modify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td>
          <td class="paramname"><em>It</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00019.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy D to the element pointed by It </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">It</td><td>: iterator to the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: new value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01431">1431</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a76bd7113108bb0d2a724b851b7333e1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::modify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td>
          <td class="paramname"><em>It</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00019.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move D to the element pointed by It </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">It</td><td>: iterator to the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: new value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01447">1447</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a832bd66d4122e9870ced10d34e51234b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::modify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a>&#160;</td>
          <td class="paramname"><em>It</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>modify the element pointed by It with a function M </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">It</td><td>; iterator to the element to modify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format (void M (value_type &amp;)) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01464">1464</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aae9450defa202f7281531a9d74f98e7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::modify_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00019.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>assign D to the element of the position Pos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: position to modify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: new value to assign </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01479">1479</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0c06816505cafa4b03959ac6dab37a5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::modify_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00019.html#a87cf343c3367539a136887208feeee1d">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move D to the element of the position Pos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: position to modify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: new value to assign </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01495">1495</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7079328b76dd313aa97146c9efdb3b0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::modify_pos </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>modify the element of the position Pos with the function M </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: position to modify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function to modify the element with the format (void M (value_type &amp;)) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01513">1513</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a106653ec27cdda561bd86fb08ccfcf03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html">cntree_vector</a>&amp; <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00019.html">cntree_vector</a>&lt; value_t, cnc, alloc_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>VT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asignation operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VT</td><td>: <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> after the copy </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00251">251</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab1bf41521b42e053728c32d649e584c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename alloc_t2 , bool cnc2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html">cntree_vector</a>&amp; <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00019.html">cntree_vector</a>&lt; value_t, cnc2, alloc_t2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>VT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asignation operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VT</td><td>: <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> from where copy the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> after the copy </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00267">267</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac2164589da63a2f4cb2c1416eec65436"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;bool cnc2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html">cntree_vector</a>&amp; <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00019.html">cntree_vector</a>&lt; value_t, cnc2, alloc_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asignation operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>: <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> from where move the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> after the copy </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00285">285</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a11f89089e07505024f6216bbb7fd5c3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_t&amp; <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checked access to an element by their position in the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the object selected </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (log(N)) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00497">497</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af04a32ab965d08a6d028fe515d5f4b3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t&amp; <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>Pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checked access to an element by their position in the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pos</td><td>: Position to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the object selected </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(log(N)) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00508">508</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3d0e7ffff475fd1dd217d7b6d7011d77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::pop_back </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01115">1115</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a07097aafe2ce6155a0eac0d4332b3a5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::pop_back_if </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format ( bool M (value_t &amp;)) if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree 2 - Function returns false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(constant) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01132">1132</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acc192c22d58d3672538f555e85c27677"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::pop_copy_back </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the tree and return a copy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01152">1152</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9bea3beb87377960b728420bfabe5ade"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::pop_copy_back_if </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the tree and return a copy in V </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format ( bool M (value_t &amp;)) if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree 2 - Function returns false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01175">1175</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a848f40ed32e2e4811bf6f4fa79e514ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::pop_copy_front </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the tree and return a copy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01012">1012</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6040c13aa1eef6fd6d853a7adb7fff50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::pop_copy_front_if </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the tree and return a copy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where copy the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format ( bool M (value_t &amp;)) if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree 2 - Function returns false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01035">1035</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a12e762b6d54e5a3fdfd00b65b0561dde"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::pop_front </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (constant) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00974">974</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2e47feeae3ef2e7e758602474657ea62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::pop_front_if </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format ( bool M (value_t &amp;)) if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree 2 - Function returns false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O (constant) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00991">991</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="accf0be597d2da20cb13f60452edc561e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::pop_move_back </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the tree and return a copy with rvalues </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where move the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01195">1195</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2bf1c9c014f8e6e39ac70cfb95323b9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::pop_move_back_if </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the last element of the tree and return a copy with rvalues </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where move the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format ( bool M (value_t &amp;)) if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree 2 - Function returns false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01218">1218</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9c948029fb21c4aa0f412041660438cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::pop_move_front </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the tree and return a copy with rvalues </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where move the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01055">1055</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa69ef4c732e8af9e6aa6ba3c51dac0e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::pop_move_front_if </td>
          <td>(</td>
          <td class="paramtype">value_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the first element of the tree and return a copy with rvalues </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>: reference to a variable where move the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format ( bool M (value_t &amp;)) if return true the element is deleted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code of the operation 0- Element erased 1 - Empty tree </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O(1) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01077">1077</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abe0c5876998af5ac0c86db6f74dbabf2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert one element in the back of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert. Can ve a value, a reference or an rvalue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00659">659</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0aa8e978249e699a3bc51e6bf92bd7e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class P , class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::push_back_if </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert one element in the back of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert. Can ve a value, a reference or an rvalue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format bool(  value_t &amp;). if return true the element is iserted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted, if not return <a class="el" href="a00019.html#aca25490ad91ef590a20ecc1feeaf5d1b">end()</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00672">672</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab96c66fa72edf0ef712130cc4fa7f06b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in the front of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert. Can ve a value, a reference or an rvalue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00591">591</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa0f613175cd44addf8058f7306b38e2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class P , class Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#ad7de56907efcce713cbd358c14b5906c">iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::push_front_if </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>insert an element in the front of the container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>: value to insert. Can ve a value, a reference or an rvalue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>: function with the format bool(  value_t &amp;). if return true the element is iserted , if false not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element inserted, if not return <a class="el" href="a00019.html#aca25490ad91ef590a20ecc1feeaf5d1b">end()</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This operation is O ( const ) </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00604">604</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af89ea00525332c83fcc5a7139f17557e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01762">1762</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a376df61f6285b5f2b5ad9d9161038b4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01823">1823</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9b59a192483536c9dbbec54e608548d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01777">1777</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5e5f9653fa7c0eacbf21a40c44922e1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#a43bd4af0141eb3ccd69c9385f94f3e0f">const_reverse_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01845">1845</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a154c3aadf8e287cd2f35cf8721846857"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the capacity for to contain , at least n elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: number of elements for the new capacity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function has not utility. It is provided only for compatibility with the STL vector interface </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00440">440</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0399fba189f3010653664f2a07ba387f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">signed_type&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_t&#160;</td>
          <td class="paramname"><em>c</em> = <code>value_t()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>resize the current vector size and change to sz.<br/>
 If sz is smaller than the current size, delete elements to end<br/>
 If sz is greater than the current size, insert elements to the end with the value c </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>: new size of the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> after the resize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>: Value to insert if sz is greather than the current size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00409">409</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af78b1ce43f0c85bceda1d91902863166"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::rit_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator to the first element </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01738">1738</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9b381c905e49bd704dab3bc32f3442d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::rit_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator to the next element after the last </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01746">1746</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="affc23d344971d36d528707a9e0a6af17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::rit_rbegin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator to the last element </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01754">1754</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5680c212c840c8841989dbe07b1a48ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#a7be73be0ae348fa005c4e399186d91ff">reverse_iterator</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::rit_rend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator to the previous elemento to the first </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l01769">1769</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a938c8e7b8066ef4e3907c256f953f098"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed_type <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the number of elements in the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> </p>
<dl class="section return"><dt>Returns</dt><dd>number of elements in the <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00386">386</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afbb8161d8d8e5a3e5a31c358fa565bfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00019.html">cntree_vector</a>&lt; value_t, cnc, alloc_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>swap the data between the two <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>: <a class="el" href="a00019.html" title="This class have the same interface than the STL vector, but istead of be a vector is a tree...">cntree_vector</a> to swap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="a00114_source.html#l00360">360</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a5d141ff25b2b38d29d8e6b76e1d5108e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class value_t2 , bool cnc2, class alloc_t2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="a00019.html">cntree_vector</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00114_source.html#l00093">93</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a402632b3199b6a84dc51e1312de37bfd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#a7df32d590dc511949720cfa75f878018">mtx_data</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::BD</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00114_source.html#l00092">92</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2c395854fb54d4b307488590e0f4e60d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#adc0f814170aa1d0ab669794e311f638b">node_alloc_t</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::node_alloc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00114_source.html#l00085">85</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1704766d3e53c5b8fc77286ad0c6525b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00019.html#a43753d3c0e064cc6d601496645811657">tree_t</a> <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::T</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00114_source.html#l00086">86</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a439da6f9eefc2ca2267d20db7bc08d2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t, bool cnc = false, typename alloc_t = cntree_allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">alloc_t <a class="el" href="a00019.html">countertree::cntree_vector</a>&lt; value_t, cnc, alloc_t &gt;::value_alloc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00114_source.html#l00084">84</a> of file <a class="el" href="a00114_source.html">cntree_vector.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00114_source.html">cntree_vector.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00147.html">countertree</a></li><li class="navelem"><a class="el" href="a00019.html">cntree_vector</a></li>
    <li class="footer">Generated on Mon Oct 14 2013 22:46:59 for [ countertree + suballocator ] by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
