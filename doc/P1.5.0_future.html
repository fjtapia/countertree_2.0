<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <meta content="application/xhtml+xml; charset=UTF-8" http-equiv="content-type" />
    <meta name="generator" content="HTML Tidy for Windows (vers 1st November 2003), see www.w3.org" />
    <title>Boost C++ Libraries</title>
    <link rel="icon" href="img/favicon.ico" type="image/ico" />
    <link rel="stylesheet" type="text/css" href="css/section-welcome.css" />
    <link rel="stylesheet" type="text/css" href="css/code.css" />
    <!--[if IE 7]> <style type="text/css"> body { behavior: url(/style-v2/csshover3.htc); } </style> <![endif]-->
    <meta name="google-site-verification" content="mpr2HgFpodnbF_8fv4qXd9roIClVwtX3C-Kd3F6r61w" />
    <!--
Note: Editing website content is documented at:http://www.boost.org/development/website_updating.html-->
  </head>
  <body>
    <div id="heading">
      <div class="heading-inner">
        <h1 class="heading-title"> <a href="http://www.boost.org/"> <img src="img/space.png"
              alt="Boost C++ Libraries" class="heading-logo" /> <span class="heading-boost">Boost</span>
            <span class="heading-cpplibraries">C++ Libraries</span> <img style="width: 300px; height: 80px;"
              alt="Preliminary" src="img/preliminary.gif" /> </a></h1>
        <p class="heading-quote"> <q>...one of the most highly regarded and
            expertly designed C++ library projects in the world.</q> <span class="heading-attribution">—
            <a href="http://www.gotw.ca/" class="external">Herb Sutter</a> and <a
              href="http://en.wikipedia.org/wiki/Andrei_Alexandrescu" class="external">Andrei
              Alexandrescu</a>, <a href="http://safari.awprofessional.com/?XmlId=0321113586"
              class="external">C++ Coding Standards</a></span></p>
      </div>
    </div>
    <div class="clear"> </div>
    <div class="cuerpo_central"> <br />
      <div class="cuerpo_texto"> <br />
        <span style="font-size: 24pt;"> <span style="font-weight: bold; color: black;">
            <a href="index.html">The [ Counter Tree + Suballocator ] Library</a>
          </span></span><br />
        <div>
          <div class="author">
            <h3 class="author"><br />
              <span class="firstname"></span></h3>
            <h3 style="font-size: 10pt; font-style: italic; font-weight: bold" class="author">
              <span style="font-weight: bold;"><span class="firstname" style="font-weight: bold;">Francisco
                  Jose Tapia</span>   Copyright © 2010-2013 Francisco Jose Tapia</span></h3>
          </div>
        </div>
        <div class="legalnotice">
          <p><span style="font-size: 10pt; font-style: italic; font-weight: bold">Distributed
              under the Boost Software License, Version 1.0. (See accompanying
              file LICENSE_1_0.txt or copy at <a href="file:///LICENSE_1_0.txt"
                target="_top"> http://www.boost.org/LICENSE_1_0.txt )</a></span>
          </p>
        </div>
        <br />
        <br />
        <br />
        <div class="caja_menu"> <span style="font-size: 16pt; color: black;"><br />
            Table of Contents</span> <br />
          <div style="margin-left: 40px;">
            <div style="margin-left: 40px;"> <a href="P1.0_introduction.html#introduction">1.-
                Introduction</a><br />
              <div style="margin-left: 40px;"><a href="P1.0_introduction.html#countertree">1.1.-
                  Description of the Counter Trees</a><br />
                <a href="P1.0_introduction.html#benchmark">1.2.- Benchmark of
                  parallel algorithms</a><br />
                <a href="P1.3.0_new_elements.html#new_elements">1.3.- New
                  elements of the library</a><br />
                <div style="margin-left: 40px;"><a href="P1.3.0_new_elements.html#position">1.3.1.-
                    Access by position and random access iterators </a> <br />
                  <a href="P1.3.0_new_elements.html#deletion">1.3.2.- Deletion
                    in the first/last position</a><br />
                </div>
                <div style="margin-left: 40px;"><a href="P1.3.0_new_elements.html#iterators">1.3.3.-
                    Iterators</a></div>
                <div style="margin-left: 40px;"> <a href="P1.3.4_description_suballocators.html#suballocator">1.3.4.-
                    Memory Problems (Suballocators)</a><br />
                  <a href="P1.3.4_description_suballocators.html#countertree_suballocator">1.3.5.-
                    Description of Counter Trees + Suballocators </a><br />
                  <a href="P1.3.6_lock_system.html#lock">1.3.6.- New Lock system
                    (Single Write Multiple Read Mutex)</a> <br />
                  1<a href="P1.3.6_lock_system.html#new_functions">.3.7.- Safe
                    concurrent programming. (New functions)</a><br />
                </div>
                <a href="P1.4_class_structure.html#class_structure">1.4.- Class
                  structure Code description</a><br />
                <div style="margin-left: 40px;"> <a href="P1.4_class_structure.html#description">1.4.1.-
                    Description of the classes of the library</a><br />
                </div>
                <a href="P1.5.0_future.html#next_improvements">1.5.- Future
                  Improvements</a><br />
                <div style="margin-left: 40px;"><a href="P1.5.0_future.html#strategies">1.5.1-
                    Strategies for many core Systems. Parallel algorithms for
                    very large trees</a> <br />
                </div>
                <div style="margin-left: 40px;"><a href="P1.5.0_future.html#redesign">1.5.2-
                    Redesign of the internal algorithm</a><br />
                  <a href="P1.5.0_future.html#augmented">1.5.3- Augmented trees</a></div>
                <br />
                <br />
              </div>
            </div>
          </div>
        </div>
        <br />
        <br />
        <br />
        <p><a name="next_improvements"></a> <span style="font-size: 18pt;font-weight: bold; color: black;">1.5.-
            Future improvements</span></p>
        <p class="cuerpo_texto"> <br />
        </p>
        The Counter Tree Library  is a long term project with 6 steps. The first
        3  are done <br />
        <br />
        <div style="margin-left: 40px;">
          <ol>
            <li>Design and implementation of the countertree</li>
            <li>Design and implementation of suballocator</li>
            <li>Concurrent version of countertree and suballocator</li>
            <li>Design and implementation of parallel functions for very large
              trees. ( parallel copy and clear, parallel fast logic functions
              (union, intersection, nor intersection) with trees, parallel copy
              to and from a vector, and  several parallel functions of
              &lt;algorithms&gt; )</li>
            <li>Redesign the internal algorithm.</li>
            <li> Augmented trees</li>
          </ol>
        </div>
        <br />
        <br />
        <br />
        <p><a name="strategies"></a> <span style="font-size: 18pt;font-weight: bold; color: black;">1.5.1.-
            Strategies for many core systems. Parallel algorithms for very large
            trees <br />
          </span></p>
        <br />
        <span style="font-size: 14pt;font-weight: bold; text-decoration: underline;">PROBLEM
          DESCRIPTION</span><br />
        <br />
        Until now, the main problem in the design of parallel algorithms over
        tree data structures had been the difficult to assign the elements
        stored in the tree between an arbitrary number of threads. With this
        library, this problem is removed. Now, it's time to face the next
        problems in the design of parallel algorithms.<br />
        <br />
        The main problem is the lock contention when the number of threads
        grows, in the operations which need an exclusive lock over the data
        structure ( insertion, deletion, modification ...). The lock contention
        appear when the number of threads doing operations with exclusive lock
        grows. <br />
        <br />
        In order to talk about parallel algorithms we have two kinds of
        algorithms:<br />
        <br />
        <div style="margin-left: 40px;">a) <span style="font-weight: bold;">Algorithms
            with lock contention</span> , when the number of threads grows. We
          can find two kinds of algorithms with lock contentions:<br />
          <ol style="margin-left: 40px;">
            <li>Algorithms with high contentions Algorithms which use the
              external interface of the classes, and implicit the locks used by
              these functions. Are very easy to use, but the number of
              concurrent threads is limited by the delays introduced by the lock
              system.</li>
            <li>Algorithm with low contentions. Algorithms which use the
              internal structure of the tree, and use the lock system only by a
              few short operations. Due this, the number of concurrent threads
              can be several times the number of the previous kind. More
              difficult to program</li>
          </ol>
          <br />
          b)<span style="font-weight: bold;"> Algorithms without lock contention</span> 
          when the number of threads grows. These algorithms use the internal
          structure of the tree, and or don't use the lock system. Due this the
          number of concurrent threads can be very high, and is limited only by
          the HW (When many cores of a processor try to access to the memory,
          the cache rate down ans all the process are slow down ), or by the
          compiler (the std::allocator of GCC 4.8 when four threads access
          simultaneously, instead of be four times faster is 60% slower)</div>
        <br />
        Due to the limitations  of the memory allocator of the compilers when
        the number of threads grows, I had designed a <span style="font-weight: bold;">new
          memory suballocator</span> , with <span style="font-weight: bold;">speed
          linear with the number of threads</span>, expecting to reach more than
        100 threads at full speed.<br />
        <br />
        All the algorithms mentioned here, are designed on paper, and many of
        them are implemented. The idea is to include many of them in the next
        version.  But others require the modification of the internal algorithm
        of the tree, in order to implement operations of split and join over
        trees.<br />
        <br />
        These new algorithms affect to the semantic of the functions, by
        example  how to pass to the tree destructor the number of threads to
        use? The solution to these problems need a study in deep for to evaluate
        the options and select the best solution.<br />
        <br />
        <br />
        <span style="font-size: 14pt;font-weight: bold; text-decoration: underline;">SOLUTIONS<br />
        </span><br />
        With the trees we can find the next operations :<br />
        <br />
        <span style="font-weight: bold; text-decoration: underline;">1.- CONSULT</span><br />
        Any number of threads can access simultaneously to the tree without 
        lock contention problems.<br />
        <br />
        <span style="text-decoration: underline; font-weight: bold;">2.- ACCESS
          TO THE ELEMENTS.</span><br />
        Any number of threads can access simultaneously to the tree without 
        lock contention problems, but without the access by position it is very
        difficult to distribute between an arbitrary number of threads, imagine
        a tree with 200000000 nodes and a Xeon Phis with 244 threads.)<br />
        <br />
        <span style="font-weight: bold; text-decoration: underline;">3.-
          INSERTION ,DELETION AND MODIFICATION.</span><br />
        These operations present problems of lock contentions with an intensive
        use, when the number of threads grows.  But there is a strategy in order
        to minimize the problem.<br />
        <br />
        If the number of operations is small, the problem is small too. But if
        you have a great number of operations, you have an algorithm for to
        resolve it.  This algorithm need to sort the operations , in order to
        distribute between the threads.<br />
        <br />
        There are two solutions:<br />
        <br />
        <ol style="margin-left: 40px;">
          <li> Each threads look for the position to insert, delete or modify 
            concurrently. This operation spend time because must  and only use
            the exclusive locks in the operation with the node, which is a sort
            and fast operation, because involve only a few nodes around. This
            can be implemented with the actual version and multiply several
            times the number of write operations per second compared with the
            algorithms of high lock contentions.</li>
          <br />
          <li>Need operations of split the tree ( we have sub trees ordered) and
            the join operations of ordered sub trees. (These operations don't be
            in the actual version of the algorithm, and  they are planned for
            future versions, as comment in the point 1.5.3.- Redesign of the
            internal algorithm). The idea is split the main tree in several sub
            trees and each thread manages a sub tree. When all the threads
            finish the operations, we join all the trees obtaining a new main
            tree.</li>
        </ol>
        <br />
        You need to sort all the operations to do, and assign to each thread a
        range of operations. After this, split the tree between the number of
        threads and do all the operation over each sub tree. When finish, join
        the sub trees and it's done.<br />
        <br />
        <span style="font-weight: bold; text-decoration: underline;">Insertions
          in the tree</span><br />
        <br />
        <img src="img/arbol1.png" alt="tree" /><br />
        <br />
        In the picture you can see, we have 8 operations to insert and we have 4
        threads. The vector are the elements to insert and  have 4 threads.<br />
        <br />
        <span style="font-weight: bold; text-decoration: underline;">Insertions
          in split trees</span><br />
        <br />
        <img src="img/arbol2.png" alt="split tree" /><br />
        Each sub tree have the same number of operations to do, and when finish,
        join the sub trees obtaining a new main tree.<br />
        <br />
        This algorithm can be implemented with any number of threads without
        lock contentions.  The operations of split and join the sub trees are
        similar in cost to the insertion or the deletion of a node in the tree.<br />
        <br />
        <span style="font-weight: bold; text-decoration: underline;"><br />
          4.- COPY AND DELETE THE TREE.</span><br />
        <br />
        Actually the compilers are using an algorithm O(N) with the copy and
        clear the tree. Even with this algorithm, these operations spend a great
        time if the tree is big.<br />
        <br />
        I have designed  and implemented for to be included in the next version 
        the next parallel algorithms :<br />
        <br />
        <ul style="margin-left: 40px;">
          <li> <span style="font-weight: bold;">Parallel Copy</span> a Tree  (O
            (N) ) Algorithm without lock contentions. The limitations are caused
            by the memory allocator of the compiler.</li>
          <li> <span style="font-weight: bold;">Parallel Delete</span> a Tree </li>
          <li> <span style="font-weight: bold;">Parallel Copy of a Vector in a
              Tree</span> (O (N) ) Algorithm without lock contentions. With very
            large vectors, the limitations are caused by the slow down of the
            cache rate of the processor.</li>
          <li> <span style="font-weight: bold;">Parallel copy of a Tree in a
              Vector</span> (O (N) ) Algorithm without lock contentions. With
            very large vectors, the limitations are caused by the slow down of
            the cache rate of the processor.</li>
        </ul>
        <br />
        <span style="font-weight: bold; text-decoration: underline;"><br />
          5.- UNION, INTERSECTION AND NON INTERSECTION OPERATIONS</span><br />
        <br />
        Many times the maps and sets are used as index. When make a search in
        the map, obtain a set of keys. In the selection process you must combine
        several sets of keys with logical functions (union, intersection,
        non-intersection....). Many times these set are very large, the time and
        the memory used too, like in the map-reduce systems. The <span style="font-weight: bold;">map
          reduce system</span> are the heart of the <span style="font-weight: bold;">Big
          Data applications</span>. With the random-access iterators is easy to
        make these functions parallel. The idea is to create a rich set of
        parallel fast logical functions in order to simplify the process, reduce
        the memory used in the process and cut the time needed with the
        concurrent process.<br />
        <br />
         <img alt="benchmark set intersection" src="img/benchmark_set_intersection_cnc.png" /><br />
        This graph is the benchmark of an parallel algorithm with high
        contentions. The algorithm shows promising results  in this kind of
        operations. ( you can find the code in the benchmark cnc folder
        benchmark_set_intersection_cnc.cpp.)<br />
        <br />
        The next algorithms planned are :<br />
        <ul style="margin-left: 40px;">
          <li> <span style="font-weight: bold;">Parallel Intersection of two
              trees</span> (O (N logN) ) Algorithm with low contentions. Very
            fast compared with the included in &lt;algorithms&gt;</li>
          <li> <span style="font-weight: bold;">Parallel non Intersection of
              two trees</span> (O (N logN) ) Algorithm with low contentions.
            Very fast compared with the included in &lt;algorithms&gt;</li>
          <li> <span style="font-weight: bold;">Parallel Union of two trees</span>
            (O (N logN) ) Algorithm with low contentions. Very fast compared
            with the included in &lt;algorithms&gt;</li>
          <li><span style="font-weight: bold;">Parallel Intersection  and not
              intersection of two trees </span>(O (N logN) ) Algorithm with low
            contentions. Very fast compared with the included in
            &lt;algorithms&gt;</li>
        </ul>
        <br />
        With the access by position it's easy design parallel algorithms for to
        do these operations , but have lock contention in the insertion of the
        result in the final data structure. With the operations of split and
        join the tree we can design these algorithms without lock contentions.<br />
        <br />
        <br />
        <p><a name="redesign"></a> <span style="font-size: 18pt;font-weight: bold; color: black;">1.5.2.-
            Redesign of the internal algorithm</span></p>
        <br />
        When you design a <span class="il">tree</span>, you must develop a
        balanced algorithm in order to prevent a degenerate <span class="il">tree</span>
        ( <span class="il">Tree</span> like a linked list). You have several
        types of balanced trees ( mainly Red-Black and <span>AVL</span> ). 
        That decision about the type of balance tree  have influence on the
        quality of the balance and the speed of the <span class="il">tree</span>.
        The most used are the red-black trees. You have an excellent description
        with code in <span style="font-style: italic;">“Introduction to
          Algorithms”</span> ( Cormen , Leiserson, Rivest). <br />
        <img align="middle" src="img/balanceo.png" alt="red-black balancing" style="border: 25px solid white;" />
        <p style="margin-bottom:0in">But , even the same type of balance tree,
          ,it  can be done in several ways,</p>
        <p style="margin-bottom:0in"><br />
        </p>
        <p style="margin-bottom:0in">In order to design an algorithm for to
          insert, delete and balance a red-black tree you must take care about</p>
        <p style="margin-bottom: 0in; margin-left: 40px;">1.- What of the
          solutions do you want </p>
        <div style="margin-left: 40px;"> </div>
        <p style="margin-bottom: 0in; margin-left: 40px;">2.- How do you define
          the rules, which applying obtain the desired solution.</p>
        <div style="margin-left: 40px;"> </div>
        <p style="margin-bottom: 0in; margin-left: 40px;">3.- What's the cost in
          time of process .</p>
        <div style="margin-left: 40px;"> </div>
        <p style="margin-bottom: 0in; margin-left: 40px;">4.- Benefits,
          advantage  of this solution respect the others </p>
        <br />
        <p style="margin-bottom:0in">When I decided add the <span class="il">counter</span>
          to the nodes for the design of the <span><span class="il">CounterTree</span></span>,
          I tried to use the code showed in "Introduction to algorithms", but
          was very complex the management of  the counters, and decide design my
          own balanced algorithm based on the 234Tree description. The result is
          the actual version of <span><span class="il">CounterTree</span></span>.
          It is 10% more or less slower than the <span>GCC</span>
          implementation, but is logic , because must manage the pointers and
          the counters.</p>
        <p style="margin-bottom:0in"><br />
        </p>
        It's only a first version. I am convinced, this algorithm can be
        improved in the design and in the implementation, Looking for a way for
        to improve the speed , I examined others implementations of Red-Black
        trees, several books an mainly with the experience obtained with the <span>Suballocator</span>.
        I decided to change several things of the algorithm and the
        implementation, pursuing to improve the speed. I have a first design
        done on paper.<br />
        <br />
        Some parallel functions of the tree, described in the previous point,
        with a big number of threads can appear bottleneck effects. The redesign
        of several algorithms using techniques of split and join the tree,
        permit to be used by hundreds of threads without bottleneck effects.
        This technique permit to make parallel functions didn't done previously.
        The redesign of the algorithm must provide the split and join trees
        functions, which permit to redesign several functions of the trees in
        order to be efficient in a manycore system.<br />
        <br />
        The new algorithm must provide a low level catalog of operations with
        the nodes. ( insert, delete , rotations, swap... ) in order to provide
        support to the next point,  the <span style="font-weight: bold;">AUGMENTED
          TREES</span><br />
        <br />
        <br />
        <p><a name="augmented"></a> <span style="font-size: 18pt;font-weight: bold; color: black;">1.5.3.-
            Augmented trees<br />
          </span></p>
        <br />
        The augmented trees are trees with additional information, which is not
        fixed. It must be processed and changed when you insert, delete or move
        an node in the tree.<br />
        The augmented trees have  in each node a data not fixed( augmented
        data). This data depend of the node and others node of the tree ( their
        data, position, number of them  ...). Due this, each change, insertion,
        deletion or movement, generates changes in the augmented information in
        all the nodes related.<br />
        <br />
        <img alt="interval tree" src="img/augmented_1.jpg" /><br />
        <br />
        This is an interval tree. The tree is ordered by the lower value of the
        fixed information. The augmented information represent the interval of
        the node and all the nodes under it including itself.<br />
        <br />
        <img alt="accumulator tree" src="img/augmented_2.jpg" /><br />
        <br />
        This tree is unordered ( The unordered trees are vector_tree). The
        augmented information  represent the addition of the augmented
        information of the nodes under it , plus its fixed information.<br />
        <br />
        <img alt="countertree" src="img/ctree_02.png" /><br />
        <br />
        The countertrees are augmented trees. The fixed information don't exist,
        and the augmented information represent the number of nudes under it.
        Every time you  insert, delete or move a  node in the tree, this
        information must be recalculate. <br />
        <br />
        You can find augmented trees with a wide variety of informations in
        areas from the statistical or games, to the biology. Even you can find
        trees with several augmented informations simoultaneously<br />
        <br />
        For the speed the best solution is to include the information and the
        process inside the <span class="il">tree</span>. With this, you
        customize your <span class="il">tree</span> and obtain the maximum
        speed.<br />
        <br />
        In the new version of the algorithm, all the internal process of the <span
          class="il">tree</span> can be decomposed in a set of small operations
        of a “catalog” like:<br />
        <br />
        <div style="margin-left: 40px;">
          <ul>
            <li>Insert/delete a node in the right/left pointer of a node.</li>
            <li>All the rotations with nodes</li>
            <li>Swap of nodes directly linked and not directly linked</li>
            <li>Design the information to insert in the node</li>
          </ul>
        </div>
        <br />
        When you want have an augmented tree, you must codify, what must do with
        your augmented information in each operation of the "catalog" . When the
        tree execute its the code of each operation , execute also the code of
        the same operation of your augmented information.<br />
        <br />
        You can have augmented trees by several concepts simultaneously. Each
        concept have codified the code of all the operations of the catalog. And
        then when the tree execute the code of the operation, execute too the
        code of all the augmented information of the tree.<br />
        <br />
        You have compiled augmented trees, balanced, robust and with the maximal
        speed, and with all the benefits of the countertrees, concurrent and,
        thread-safe operations, access by position, use of suballocators....<br />
      </div>
      <br />
      <a title="vector_tree" href="P2.0_vector_tree.html" style="float:right"><img
          alt="link to unordered page" src="img/next.png" /></a> <a title="introduction"
        href="P1.0_introduction.html" style="float:right"><img alt="go to head of the page"
          src="img/up.png" /></a> <a title="concurrent" href="P1.4_class_structure.html#class_structure"
        style="float:right"><img src="img/prev.png" alt="previous page" /></a> <a
        title="index.html" href="index.html" style="float:right"><img src="img/home.png"
          alt="home page" /></a> <br />
      <table width="100%" xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision">
        <tbody>
          <tr>
            <td align="left">
              <p><small>Last revised: September  30, 2012 at 21:42:41 GMT</small></p>
            </td>
            <td align="right"> <br />
            </td>
          </tr>
        </tbody>
      </table>
      <hr />
      <div id="footer">
        <div id="footer-left">
          <div id="copyright">
            <p>Copyright Francisco Jose Tapia 2010-2012.</p>
          </div>
          <div id="license">
            <p>Distributed under the <a class="internal" href="/LICENSE_1_0.txt">Boost
                Software License, Version 1.0</a>.</p>
          </div>
        </div>
        <div id="footer-right">
          <div id="banners">
            <p id="banner-xhtml"> <a class="external" href="http://validator.w3.org/check?uri=referer">XHTML
                1.0</a></p>
            <p id="banner-css"> <a class="external" href="http://jigsaw.w3.org/css-validator/check/referer">CSS</a></p>
            <p id="banner-osi"> <a class="external" href="http://www.opensource.org/docs/definition.php">OSI
                Certified</a></p>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
